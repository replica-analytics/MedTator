<!doctype html>
<html lang="en">
<head>
<!-- Required meta tags -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="0" />
<title>MedTator</title>
<meta name="description" content="MedTator is a serverless text annotation tool for corpus development, which can process data 100% within your web browser and no need for a server support.">

<link href="./static/img/favicon.ico" rel="shortcut icon" type="image/x-icon" />

<!-- Font Awesome CSS -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" />

<!-- Metro UI style -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/metro/4.3.5/css/metro-all.min.css">

<!-- jquery UI style -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.css" />

<!-- code mirror style -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.0/codemirror.min.css" />

<!-- for the metro UI -->
<meta name="metro4:init" content="false">

<style id="app_style">
.box {
    display: flex;
    flex-direction: column;
}

.box-header {
    width: 100%;
    padding: 3px 0;
    display: flex;
    flex-direction: row;
}

.box-header a {
    font-size: 1em;
}

.box-header h4 {
    padding: 0;
    margin: 0;
    font-size: 1.2em;
    height: 1.5em;
    line-height: 1.5em;
    margin: 3px 0;
}

.box-header button,
.box-body button,
.box-footer button {
    height: 1.6em;
    line-height: 1em;
    font-size: .9em;
    margin: 4px;
}

.box-header input,
.box-body input {
    height: 1.2em;
    line-height: 1.2em;
    font-size: 1em;
    margin: 4px 4px 0 4px;
    padding-bottom: 2px;
}

.box-header select {
    height: 2em;
    line-height: 1.2em;
    font-size: .9em;
    margin: 4px;
}

.box-header span {
    font-size: 1em;
    height: 2em;
    line-height: 2.4em;
}

.box-header-right {
    font-size: 1em;
    height: 2em;
    line-height: 2em;
    margin: 3px 0;
    text-align: right;
}

.box-body {
    width: 100%;
}

.box-body-item {
    padding: 5px 0 2px 0;
    display: flex;
    flex-direction: column;
    border-bottom: 1px dotted #cccccc;
}

.box-body-item ul {
    margin: 0;
}

.box-body-item ul input {
    vertical-align:middle;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

.box-body-item ul label {
    vertical-align:middle;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

.box-body-item-left {
    width: 73%;
}

.box-body-item-right {
    width: 24%;
    display: flex;
    flex-direction: row;
}

.box-body-item-label {
    width: 54%;
    font-size: 1em;
    line-height: 1.8em;
}

.box-body-item-value {
    width: 45%;
}

.box-body-item select {
    width: 100%;
}

.box-body h5 {
    padding: 0;
    margin: 0;
    font-size: 1.1em;
    height: 1.5em;
    line-height: 1.5em;
    margin: 1px 0;
    font-weight: bold;
}

.box-body h6 {
    padding: 0;
    margin: 0;
    font-size: 1em;
    height: 1.2em;
    line-height: 1.2em;
    margin: 1px 0;
    font-weight: bold;
}

.box-p {
    width: 100%;
    padding: 0;
    margin: 0;
    font-size: 1em;
}

.box-p-fixlen {
    white-space: nowrap;
    text-overflow: ellipsis;
    overflow: hidden;
}

.box-footer {
    width: 100%;
    min-height: 20px;
    padding: 5px 0 5px 0;
}
html,body {
    width: 100%;
    height: 100%;
    overflow: hidden;
    font-size: 12px;
}
.code {
    font-family: 'Courier New', Courier, monospace;
    background-color: #eeeeee;
    font-size: 12px;
}
.white-space-nowrap {
    white-space: nowrap;
}
.cursor-pointer {
    cursor: pointer;
}
/* a start screen for IE and hiding init */
#start-screen {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 9999;
    background: white;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
}
#ss-msg {
    width: 100%;
    padding: 10px 0;
    text-align: center;
}
.link-btn {
    color: #555555;
}
.h-splitter {
    width: 5px;
    height: 100%;
    background-color: #e9e9e9;
}
.h-splitter-menu {
    width: 1px;
    height: 64px;
    background-color: #dadbdc;
}
.v-splitter {
    width: 100%;
    height: 5px;
    background-color: #e9e9e9;
}
#app_info {
    position: absolute;
    top: 2px;
    right: 10px;
    color: #777777;
    z-index: 98;
}
#app_info a {
    color: #777777;
}
#app_info a:hover {
    color: black;
}
#mui_filelist {
    overflow-y: hidden;
    width: 250px;
}
#mui_filelist_toolbar {
    height: 30px;
    min-height: 30px;
    max-height: 30px;
    border-bottom: 1px solid #cccccc;
}
#mui_filelist_list {
    height: calc(100% - 32px);
    overflow-y: auto;
}
#mui_filelist_pager {
    position: sticky;
    bottom: 0;
    background-color: white;
    padding: 1px 0;
}
#mui_texteditor {
    width: calc(100% - 250px); 
    height: 100%;
}
#mui_dtdlist {
    overflow-y: auto;
    width: 250px;
}
#mui_annlist {
    padding-left: 5px;
    overflow-y: auto; 
    width: calc(100% - 250px);
}
#mui_stat_summary {
    width: 250px;
    border-right: 1px solid #e9e9e9;
}
#mui_stat_details {
    width: calc(100% - 250px);
}
#mui_iaa_summary {
    width: 240px;
    border-right: 1px solid #e9e9e9;
    overflow-y: auto;
}
#mui_iaa_anns {
    width: 300px;
    padding-right: 5px;
    border-right: 1px solid #e9e9e9;
    overflow-y: auto;
}
#mui_iaa_cohenk_summary {
    /* width: 540px; */
    padding-right: 5px;
    /* border-right: 1px solid #e9e9e9; */
    overflow-y: auto;
}
#mui_iaa_tags {
    width: calc(100% - 550px);
    /* flex-grow: 1; */
    padding-right: 5px;
    /* border-right: 1px solid #e9e9e9; */
    overflow-y: auto;
}
#mui_ruleset_result {
    
}
#iaa_display_tab {
    margin-top: 5px;
}

.stat-doc-sum-tags-header {
    font-size: 1.2em;
    font-weight: bold;
    border-bottom: 1px solid #cccccc;
    padding: 0.2em 0;
    margin: 0 0 0.2em 0;
}
.stat-doc-sum-tags-body {
    width: 100%;
    height: 100%;
    max-height: 400px;
    overflow-y: auto;
}
.stat-tag-count {
    white-space: nowrap;
}
.stat-item-row {

}
.stat-item-row:hover {
    background-color: whitesmoke;
}
.stat-item-label {
    width: 120px;
    max-width: 120px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}
.stat-item-label-lg {
    width: 180px !important;
    max-width: 180px !important;
}
.stat-item-value {
    width: 120px;
    max-width: 120px;
    text-align: right;
}
.stat-item-value-sm {
    width: 70px;
    max-width: 70px;
    text-align: right;
}
#stat_doc_tag_detailbox {
    z-index: 99;
    position: absolute;
    top: 0px;
    background: white;
    box-shadow: #eaeaea 5px 5px 5px;
}
.stat-doc-sum-tags-box {
    border: 1px solid #efefef; 
    padding: 0 1em 0 1em;
}
/* for slider */
input[type=range] {
    height: 24px;
    -webkit-appearance: none;
    margin: 0;
    width: 100%;
    background: transparent;
}

input[type=range]:focus {
    outline: none;
}

input[type=range]::-webkit-slider-runnable-track {
    width: 100%;
    height: 8px;
    cursor: pointer;
    animate: 0.2s;
    box-shadow: 0px 0px 0px #000000;
    background: #E6E6E6;
    border-radius: 4px;
    border: 1px solid #A6A6A6;
}

input[type=range]::-webkit-slider-thumb {
    box-shadow: 1px 1px 1px #828282;
    border: 1px solid #8A8A8A;
    height: 16px;
    width: 16px;
    border-radius: 7px;
    background: #EBEBEB;
    cursor: pointer;
    -webkit-appearance: none;
    margin-top: -5px;
}

input[type=range]:focus::-webkit-slider-runnable-track {
    background: #E6E6E6;
}

input[type=range]::-moz-range-track {
    width: 100%;
    height: 8px;
    cursor: pointer;
    animate: 0.2s;
    box-shadow: 0px 0px 0px #000000;
    background: #E6E6E6;
    border-radius: 4px;
    border: 1px solid #A6A6A6;
}

input[type=range]::-moz-range-thumb {
    box-shadow: 1px 1px 1px #828282;
    border: 1px solid #8A8A8A;
    height: 16px;
    width: 16px;
    border-radius: 7px;
    background: #EBEBEB;
    cursor: pointer;
}

input[type=range]::-ms-track {
    width: 100%;
    height: 8px;
    cursor: pointer;
    animate: 0.2s;
    background: transparent;
    border-color: transparent;
    color: transparent;
}

input[type=range]::-ms-fill-lower {
    background: #E6E6E6;
    border: 1px solid #A6A6A6;
    border-radius: 8px;
    box-shadow: 0px 0px 0px #000000;
}

input[type=range]::-ms-fill-upper {
    background: #E6E6E6;
    border: 1px solid #A6A6A6;
    border-radius: 8px;
    box-shadow: 0px 0px 0px #000000;
}

input[type=range]::-ms-thumb {
    margin-top: 1px;
    box-shadow: 1px 1px 1px #828282;
    border: 1px solid #8A8A8A;
    height: 16px;
    width: 16px;
    border-radius: 7px;
    background: #EBEBEB;
    cursor: pointer;
}

input[type=range]:focus::-ms-fill-lower {
    background: #E6E6E6;
}

input[type=range]:focus::-ms-fill-upper {
    background: #E6E6E6;
}

#app_hotpot {
    margin-top: 2px;
}
.dropzone {
    width: 200px;
    height: 60px;
    line-height: 60px;
    text-align: center;
    font-size: 1em;
    border: 1px dotted rgb(17, 61, 110);
    border-radius: 4px;
}
.dropzone:hover {
    border-color: rgb(0, 89, 255);
    font-weight: bold;
}
.disabled-zone {
    opacity: .5;
}
.zone-text {
    margin-top: 8px; 
    line-height: 1.2em;
    padding-left: 5px;
    padding-right: 5px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}
#dropzone_dtd {
    /* width: 190px; */
    /* width: 245px; */
    width: 180px;
    height: 60px;
    line-height: 60px;
    text-align: center;
    font-size: 1em;
    border: 1px dotted rgb(17, 61, 110);
    border-radius: 4px;
}
#dropzone_ann {
    width: 180px;
    height: 60px;
    line-height: 60px;
    text-align: center;
    font-size: 1em;
    border: 1px dotted rgb(17, 61, 110);
    border-radius: 4px;
}
#dropzone_txt {
    width: 176px;
    height: 60px;
    line-height: 60px;
    text-align: center;
    font-size: 1em;
    border: 1px dotted rgb(17, 61, 110);
    border-radius: 4px;
}
.dropzone-menu-box {
    width: 166px;
    height: 60px;
    line-height: 60px;
    text-align: center;
    font-size: 1em;
    border: 1px dotted rgb(17, 61, 110);
    border-radius: 4px;
}
.pos-corner-br {
    position: absolute; 
    right: 0; 
    bottom: 0;
}
.tag-list-row {
    background-color: white;
}
.tag-list-row-actived {
    background-color: #fffee8;
    border-bottom: 1px solid #999999;
    border-left: 5px solid #d3d3d3;
    padding-left: 5px !important;
}
.badge-shortcut {
    padding: 1px 1px 1px 2px;
    font-size: 10px;
    font-family: 'Courier New', Courier, monospace;
    color: black;
    background-color: #EAEAEA;
    border: 1px solid #EFEFEF;
    border-right: 1px solid #cccccc;
    border-bottom: 1px solid #cccccc;
}
.mark-hint {
    cursor: pointer;
    border: 2px dotted #999999;
    border-left: 0;
    border-right: 0;
    position: relative;
    /* display: inline-block; */
}
.mark-hint:hover {
    font-weight: bold;
    border-color: #333333;
}
.mark-hint-info {
    margin: 0 5px 0 0;
    padding: 0px 4px;
    color: white;
}
.mark-hint-text {

}
.mark-hint .mark-hint-tooltip {
    visibility: hidden;
    min-width: 100px;
    width: auto;
    background-color: #cccccc;
    color: black;
    text-align: center;
    font-size: .9em;
    font-weight: normal;
    font-family: sans-serif;
    border-radius: 6px;
    padding: 1px 5px;
    position: absolute;
    z-index: 999;
    top: 135%;
    left: 50%;
    margin-left: -50%;
    opacity: 0;
    transition: opacity 0.3s;
}
.mark-hint .tooltiptext::after {
    content: "";
    position: absolute;
    top: 130%;
    left: 50%;
    margin-left: -5px;
    border-width: 5px;
    border-style: solid;
    border-color: transparent transparent #cccccc transparent;
}
.mark-hint:hover .mark-hint-tooltip {
    visibility: visible;
    opacity: 1;
}
.mark-tag {
    border-radius: 3px;
    /* padding: 1px 3px; */
    padding: 1px 0;
    margin-right: 0;
    cursor: pointer;
    border: 1px solid white;
    border-left: 0;
    border-right: 0;
}
.mark-tag:hover{
    border-color: red;
}
@keyframes glow {
    0% {
        border-color: #efefef;
        box-shadow: 0 0 5px #efefef;
    }
    100% {
        border-color: #333333;
        box-shadow: 0 0 10px #555555;
    }
}
.mark-tag-active {    
    border-top: 3px solid;
    border-bottom: 3px solid;
    animation: glow 500ms ease-out infinite alternate;
}
.mark-tag-info {
    font-size: .75em;
    margin: 0 2px;
    padding: 0px 2px;
    background: white;
    border-radius: 4px;
}
.mark-tag-info-inline {
}
.mark-tag-info-offset {
    position: relative;
    right: -.7em;
    top: -.7em;
    font-size: .85em;
    color: transparent;
    border-radius: .5em;
}
.mark-tag:hover .mark-tag-info-offset{
    display: inline;
    position: relative;
    right: -.7em;
    top: -.7em;
    font-size: .85em;
    color: grey;
    background-color: white;
}
.mark-tag:hover .mark-tag-info-offset:hover {
    color: black;
    background-color: white;
}
.mark-tag-text {
    margin-right: -.5em;
}
.mark-round {
    border-radius: 8px;
    padding: 0 1px 0 0;
    color: black !important;
}
#cm_editor {
    height: 100%;
}
.CodeMirror {
    height: 100%;
    font-size: 14px;
    line-height: 2em;
}
.CodeMirror-activeline-background {
    background-color: #e3f3fb;
}
.CodeMirror-plots {
    position: absolute;
    width: 100%;
    height: 100%;
}
#cm_svg_plots {
    width: 100%;
    height: 100%;
}
.tag-polyline {
	fill: none;
    stroke: black;
    stroke-width: 1;
    /* vector-effect: non-scaling-stroke; */
    /* stroke-dasharray: 2, 1; */
    opacity: .5;
}
.tag-polyline:hover {
    opacity: .95;
}
.tag-linkdot {
    font-size: 8px;
    padding: 0 1px;
    border-left: 1px solid;
    font-family: 'Courier New', Courier, monospace;
}
.tag-linktext {
    font-size: 9px;
    padding: 0 3px;
}
.tag-linktext-bg {
    stroke-width: 0;
    rx: 3px;
    opacity: 1;
}
.tag-cap {
    font-size: 9px;
    font-family: 'Courier New', Courier, monospace;
    /* font-weight: bold; */
}
.tag-cap-AB,
.tag-cap-ab {
    fill: green;
}
.tag-cap-A,
.tag-cap-a {
    fill: orangered;
}
.tag-cap-B,
.tag-cap-b {
    fill: royalblue;
}
.tag-cap-G,
.tag-cap-g {
    fill: goldenrod;
}
/* span[data-descr] {
    position: relative;
    cursor: help;
}
span[data-descr]:hover::after,
span[data-descr]:focus::after {
    content: attr(data-descr);
    position: absolute;
    left: 0;
    top: 20px;
    min-width: 150px;
    border: 1px solid #eeeeee;
    border-radius: 5px;
    background-color: rgba(218, 218, 218, 0.959);
    padding: 4px;
    color: #000000;
    font-size: 1rem;
    line-height: 1.2rem;
    z-index: 999;
} */
.tag-desc-item {
    padding: 0 0 0 3px;
    border-left: 1px solid #bdbdbd;
    margin-bottom: 1px;
}
.tag-desc-attr {
    font-style: italic;
}
.tag-desc-value {
    
}
#hoverbox_etag {
    position: absolute;
    background-color: #efefefee;
    color: black;
    padding: 5px;
    border: 1px solid #cccccc;
    border-radius: 5px;
    z-index: 888;
    max-width: 300px;
}

/* for the pop menu */
#popmenu_tag {
    z-index: 998;
    min-width: 100px;
    position: absolute;
    left: -100px;
    padding: 1px 3px;
    box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);
}
/* for the context menu */
#ctxmenu_sel {
    z-index: 999;
    position: absolute;
    left: -100px;
    padding: 1px 3px;
    box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);
}
#ctxmenu_nce {
    z-index: 998;
    position: absolute;
    left: -100px;
    padding: 1px 3px;
    box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);
}
.ctxmenu-item {
    padding: 1px;
    cursor: pointer;
}
.ctxmenu-item:hover {
    background-color: rgb(221, 221, 221);
}
.ctxmenu-divider {
    height: 2px;
    margin: 2px 0;
    background-color: #dfdfdf;
}
.ui-widget-header {
    border: 0;
    height: 2em;
    line-height: 2em;
    text-indent: 0.5em;
    background-color: #EAEAEA;
}
.box-clear-times {
    margin-left: -16px;
    margin-right: 6px;
    z-index: 10;
    cursor: pointer;
    color: lightgrey;
}
.box-clear-times:hover {
    color: #333333;
}
.file-list {
    font-size: .9em;
    padding: 2px;
}
.file-list li {
    border-bottom: 1px dotted #eeeeee;
}
.file-list li.file-selected {
    font-weight: bold;
    background-color: #EFEFEF;
    border-left: 3px solid #1ba1e2;
    padding-left: 5px;
}
.file-list-item {
    margin-bottom: 1px;
}
.file-list-item:hover {
    background-color: #e9e8e8;
}
.file-list-item-name {
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    cursor: pointer;
}
.file-list-item-name-unsaved {
    font-style: italic;
}
/* tag list */
.tag-list {
    font-size: 1em;
    padding: 2px;
}
.tag-list li {
    padding: 2px 0;
    border-bottom: 1px dotted #eeeeee;
}
.tag-list li:hover {
    background-color: #EAEAEA;
}
.tag-list-row-name {
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;

    cursor: pointer;
    flex-grow: 1;
}
.tag-list-row-name-id-prefix {
    font-weight: bold;
    /* text-decoration: underline; */
}
.tag-list-row-count-0 {
    color: #bdbdbd;
    font-size: .95em;
}
.tag-list-row-all-tags {
    position: sticky;
    top: 0;
    z-index: 99;
}
.tag-table {
    font-size: .9em;
    position: relative;
}
.tag-table th, 
.tag-table td {
    padding: 2px;
}
.tag-table th {
    border-bottom: 1px solid #aaaaaa;
    text-align: left;
    position: sticky;
    top: 0;
    background-color: #efefef;
    z-index: 5;
    padding: 4px 0;
}
tr.tag-table-tr-actived {
    /* border-left: 5px solid #d3d3d3; */
    background-color: #fffee8; 
}
.tag-table th.tag-name {
    max-width: 200px;
    width: 180px;
}
.tag-table th.tag-id {
    max-width: 100px;
    width: 60px;
}
.tag-table th.tag-spans {
    max-width: 220px;
    width: 140px;
}
.tag-table td {
    border-bottom: 1px dotted #aaaaaa;
}
.tag-table tr:hover {
    background-color: #EAEAEA;
}
.tag-table td.td-text {
    max-width: 120px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}
.tag-attr-box {
    background-color: whitesmoke;
    border-radius: 3px;
    padding: 1px 5px;
    margin-bottom: 2px;
}
.tag-attr-box:hover{
    background-color: rgb(209, 209, 209);
}
.tag-attr-name {
    font-size: .9em;
}
input[type=text].tag-attr-input {
    padding: 0 3px;
    width: auto;
    max-width: 120px;
    line-height: 1.5em;
    height: 2em;
    display: inline;
    font-size: 1em;
    border: 0;
    border-bottom: 1px solid #999999;
}
select.tag-attr-select {
    padding: 0 3px;
    width: auto;
    max-width: 120px;
    line-height: 1.5em;
    height: 2em;
    display: inline;
    font-size: 1em;
    border: 0;
    border-bottom: 1px solid #999999;
}
.btn {
    padding: 2px 4px;
    border-top: 1px solid #EAEAEA;
    border-left: 1px solid #EAEAEA;
    border-right: 1px solid #aaaaaa;
    border-bottom: 1px solid #aaaaaa;
}
.btn:hover {
    border-top: 1px solid #aaaaaa;
    border-left: 1px solid #aaaaaa;
    border-right: 1px solid #858585;
    border-bottom: 1px solid #858585;
}
.btn:active {
    border-top: 1px solid #858585;
    border-left: 1px solid #858585;
    border-right: 1px solid #aaaaaa;
    border-bottom: 1px solid #aaaaaa;
}
.btn-xs {
    font-size: .9em;
}
.select-xs {
    font-size: .9em;
    padding: 0 3px;
    width: auto;
    max-width: 120px;
    line-height: 1.5em;
    height: 2em;
    display: inline;
}
.page-current-index {
    border-top: 0;
    border-left: 0;
    border-right: 0;
    font-weight: bold;
}
.page-total-number {
    font-size: .9em;
    line-height: 2em;
    height: 2em;
    display: inline;
}
.btn-dense {
    padding: 1px 2px !important;
}
.btn-black {
    color: #333333;
}
.btn-black:hover {
    color: #000000;
}
.btn-red {
    color: #b99090;
}
.btn-red:hover {
    color: red;
}
.btn-green {
    color: rgb(77, 118, 15);
}
.btn-green:hover {
    color: #68e22f;
}
.btn-orange {
    color: rgb(186, 107, 42);
}
.btn-orange:hover {
    color: rgb(239, 145, 45);
}
.btn-blue {
    color: rgb(24, 70, 139);
}
.btn-blue:hover {
    color: rgb(70, 166, 235);
}
input[type=text].ipt-xs {
    font-size: 1em;
    line-height: 1em;
    height: 1.4em;
    padding: 2px 3px;
    max-width: 80px;
    display: inline;
    border: 0;
    border: 1px solid #999999;
}
input[type=text].ipt-md {
    font-size: 1.2em;
    line-height: 1.2em;
    height: 1.6em;
    padding: 2px 3px;
    max-width: 150px;
    display: inline;
    border: 0;
    border: 1px solid #999999;
}
input[type=text].ipt-spinner-xs {
    font-size: 1em;
    line-height: 1em;
    height: 1.4em;
    padding: 2px 3px;
    max-width: 80px;
    display: inline;
    border: 0;
}
.icon-fg-unsaved {
    color: #daaf5f;
}
.icon-fg-unsaved:hover {
    color: #ffa600;
}

.ruleset-tag-item {
    /* cursor: pointer; */
    border-bottom: 1px dotted #ececec;
}
.ruleset-tag-item:hover {
    background-color: whitesmoke;
}
.ruleset-tag-name {
    width: 180px;
    min-width: 180px;
    border-left: 1px solid;
}
.ruleset-tag-name-str {
    width: 140px;
    min-width: 140px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}
.ruleset-tag-text {
    padding: 0px 2px;
}
.ruleset-tag-text-str {
    padding: 0px 3px;
    border-bottom: 1px solid #dadada;
}
.ruleset-tag-text-count {
    padding: 0px 5px;
    background-color: #dadada;
    border-bottom: 1px solid #dadada;
}
.ruleset-tag-text-filelist {
    padding: 1px 0 1px 4px;
    border-left: 1px solid #EFEFEF;
    border-bottom: 1px solid #EFEFEF;
    max-height: 115px;
    overflow-y: auto;
}
.ruleset-tag-text-filelist-item {
    /* cursor: pointer; */
    color: #333333;
    padding: 2px 0;
}
.ruleset-tag-text-filelist-item:hover {
    color: rgb(1, 84, 207);
    background-color: #efefef;
}
.ruleset-tag-text-filelist-item-count {
    padding: 0px 2px;
    background-color: #eaeaea;
}
.iaa-tag-attr-name {
    font-size: 0.8em;
}
.iaa-annotator-AB,
.iaa-annotator-ab {
    color: green;
}
.iaa-annotator-A,
.iaa-annotator-a {
    color: orangered;
}
.iaa-annotator-B,
.iaa-annotator-b {
    color: royalblue;
}
.iaa-annotator-G,
.iaa-annotator-g {
    color: goldenrod;
}
.iaa-row-header {
    font-weight: bold;
}
.iaa-row {
    border-bottom: 1px dotted #efefef;
    padding-top: 3px;
    padding-bottom: 3px;
    cursor: pointer;
}
.iaa-row-actived {
    background-color: #dfdfdf;
}
.iaa-row:hover {
    background-color: #efefef;
}
.iaa-bar {
    background-color: #1ba1e2;
    height: 1em;
}
.iaa-bar-box {
    width: 120px;
}
.iaa-bar-name-box {
    width: 100px;
    /* fix the overflow of concept name */
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}
.iaa-bar-filename {
    font-size: 0.8em;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}
.iaa-bar-value {
    font-size: 0.9em;
    font-weight: bold;
}
.iaa-bar-filename-box {
    width: 150px;
}
.iaa-file-cm-box {
    font-size: 0.8em;
}
.iaa-file-gs-box {
    font-size: 0.8em;
}
.iaa-tag-name {
    text-align: center;
    padding-top: 5px;
    border-top: 2px dotted #dfdfdf;
    /* border-bottom: 1px dashed #dfdfdf; */
}
.iaa-tag-detail {
    /* border-bottom: 1px dashed #dfdfdf; */
    margin-top: 5px;
    margin-bottom: 5px;
}
.iaa-tag-detail:hover {
    background-color: #efefef;
}
.iaa-tag-detail-header {
    /* border-bottom: 1px dashed #dfdfdf; */
    font-weight: bold;
    text-align: center;
    font-size: 1.1em;
    margin-bottom: 5px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}
.iaa-tag-detail-info {
    border: 1px;
    border-radius: 5px;
    padding: 5px;
}
.iaa-tag-detail-info-tp {
    border: 1px solid #61a51d;
}
.iaa-tag-detail-info-fp {
    border: 1px dotted #ff7878;
}
.iaa-tag-detail-info-fn {
    border: 1px dotted #ff7878;
}
.iaa-tag-detail-info-gs {
    border: 1px dotted #dfdfdf;
}
.iaa-tag-detail-info-text-ab {
    margin-top: 14px;
}
.iaa-tag-detail-info-text-gs {
    margin-top: 14px;
}
.iaa-tag-detail-a {
    margin-right: 5px;
}
.iaa-tag-detail-b {
    margin-right: 5px;
}
.iaa-tag-detail-g-header {
    cursor: pointer;
}
.iaa-tag-detail-g {
    border-left: 1px dotted #dfdfdf;
    padding-left: 4px;
}
.iaa-tag-detail-g:hover {
    border-left-color: #999999;
    background-color: rgb(253, 236, 205);
}
.iaa-tag-detail-oper {
    display: none;
    position: absolute;
    top: -7px;
    left: -6px;
}
.iaa-tag-detail-info:hover 
.iaa-tag-detail-oper {
    display: block;
}
.iaa-tag-attr {
    border-bottom: 1px solid #aaaaaa;
}
.iaa-tag-attr-name {
    font-size: 0.8em;
}
.iaa-tag-context {
    font-size: 1.2em;
}
.iaa-w-100 {
    width: 100% !important;
}
.iaa-w-80 {
    width: 80% !important;
}
.iaa-w-50 {
    width: 50% !important;
}
.iaa-w-40 {
    width: 40% !important;
}
.iaa-w-20 {
    width: 20% !important;
}
.iaa-op-50 {
    opacity: 0.5;
}
.iaa-select-sm {
    width: 140px;
    padding: 0 !important;
    -webkit-appearance: auto !important;
}
/* for text display */
.clr-red {
    color: red;
}
.clr-grey {
    color: grey;
}
.clr-black {
    color: black;
}
.clr-trans {
    color: transparent;
}
.txt-sm {
    font-size: 0.8em;
}
.txt-bold {
    font-weight: bold;
}
.txt-hover-bold:hover {
    font-weight: bold;
}
.txt-italic {
    font-style: italic;
}
/* fix for metro */
.radio .caption, .radio .check {
    font-size: 1em;
}
.switch .caption, .switch .check {
    font-size: 1em;
}
.switch {
    height: 30px;
}
.radio {
    height: 30px;
}
.ribbon-menu {
    /* to meet the needs of long item list */
    min-width: 1450px;
}
.ribbon-toggle-group .ribbon-icon-button {
    height: 20px;
}
ol[class], ul[class] {
    list-style: none inside;
    margin: 0;
    padding: 0;
}
/* for the linking panel */
#pan_working_tag {
    position: absolute;
    top: 10px;
    left: 10px;
    max-width: 300px;
    max-height: 400px;
    overflow-x: hidden;
    overflow-y: auto;
    border: 1px solid #aaaaaa;
    background: white;
    box-shadow: 0 0 15px #828282;
    z-index: 999;
}
#pan_working_tag_title {
    cursor: grab;
    background-color: whitesmoke;
}
#pan_working_tag_title:active {
    cursor: grabbing;
}
.rtag-attr-name {
    align-items: center;
    min-width: 100px;
    max-width: 200px;
}
.rtag-attr-value {
    max-width: 150px;
}
.rtag-attr-row:hover {
    background-color: rgb(211, 211, 211) !important;
}
.rtag-attr-row:nth-child(even) {
    background-color: white;
}
.rtag-attr-row:nth-child(odd) {
    background-color: whitesmoke;
}

/* app_settings */
#app_settings {
    position: absolute;
    top: 20px;
    right: 5px;
    width: 280px;
    padding: 5px;
    background-color: white;
    border: 1px solid #828282;
    z-index: 10;
}
.setting-tab {
    border-bottom: 1px solid #aaaaaa;
    cursor: pointer;
}
.active-setting-tab {
    font-weight: bold;
    border: 1px solid #aaaaaa;
    border-bottom: 0;
}
/* fix for code mirror dialog style within metro */
.CodeMirror-dialog input,
.CodeMirror-dialog-top input {
    display: inline;
    height: 1.5rem;
    line-height: 1.5rem;
}
.CM-gutter-test {
    border-left: 2px solid red;
}

/* rules for the statistics tab */
.doctag-table {
    cursor: default;
}
.doctag-table tr:nth-child(even) {
    background: #ffffff;
}
.doctag-table tr:nth-child(odd) {
    background: #f5f5f5aa;
}

.doctag-table td:nth-child(even) {
    /* background: #f5f5f5aa; */
}
.doctag-table td:nth-child(odd) {
    background: #f5f5f5aa;
    /* background: #f5f5f5aa; */
}
.doctag-table tr {
    border-bottom: 1px solid transparent;
}
.doctag-table tr:hover {
    background-color: rgb(219, 219, 219);
    border-color: #646464 !important;
}
.doctag-table th {
    vertical-align: bottom;
    text-align: center;
    border-bottom: 1px solid #cccccc;
    min-width: 30px;
    max-width: 40px;
    padding-top: 5px;
}
.doctag-table th span.rotate-90 {
  -ms-writing-mode: tb-rl;
  -webkit-writing-mode: vertical-rl;
  writing-mode: vertical-rl;
  transform: rotate(180deg);
  white-space: nowrap;
}
.doctag-table td {
    vertical-align: center;
    text-align: center;
    padding: 2px;
}
.doctag-table td.td-summary {
    font-weight: bold;
}
.doctag-table td.td-filename {
    border-left: 5px solid transparent;
    padding-left: 5px;
    padding-right: 10px;
    width: 180px;
    max-width: 280px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    cursor: pointer;
}
.doctag-table tr:hover td.td-filename{
    border-left-color: #646464;
    font-weight: bold;
    font-style: italic;
}
.doctag-table .td-count {
    display: inline-block;
    width: 100%;
    border: 1px solid transparent;
}
.doctag-table .td-count:hover {
    border-color: #646464;
}
.doctag-table .td-count-0 {
    font-size: 0.9em;
    color: #eeeeee;
}
/* annotation viewer */
#annviewer_bratvis {
    width: 100%;
    height: 100%;
    z-index: 110;
    top: 5px;
}
/* schema editor */
.pop-window {
    min-width: 600px !important;
    max-width: 80% !important;
    z-index: 99;
    display: none;
    top: 5px;
}
.pop-window .window-content {
    overflow-y: auto;
    overflow-x: hidden;
}
.window-menu {
    position: sticky;
    background: white;
    top: 0;
    z-index: 100;
    border-bottom: 1px solid #cccccc;
    min-width: 830px !important;
}
.se-button {
    height: 30px !important;
    line-height: 30px !important;
    font-size: 1em;
}
.se-menu-sep-line {
    height: 30px;
    line-height: 30px;
}
.se-tag-row {

}
.se-tag-row:hover {
    background-color: #f5f5f5;
}
.se-tag-attr-cell {
    min-width: 150px;
}
.se-tag-attr-cell:hover {
    background-color: #e6e6e6;
}
.se-input-field-legend {
    font-size: .6em;
    position: absolute;
    z-index: 9;
    margin-top: -6px;
    margin-left: 5px;
    color: #777777;
    background: white;
    padding: 0 1px;
}
.se-input-tag-name {
    width: 120px !important;
    height: 24px !important;
    font-weight: bold !important;
    /* border-top: 0 !important;
    border-left: 0 !important;
    border-right: 0 !important; */
}
.se-btn-link {
    color: #444444 !important;
    padding: 3px 5px;
    cursor: pointer;
}
.se-btn-link:hover {
    color: #333333 !important;
    background-color: rgb(255, 255, 255);
}
.se-tag-attr-del {
}
.se-tag-attr-del:hover {
    color: #fc6262 !important;
}
.se-input-att-name {
    width: 120px !important;
    height: 24px !important;
    /* border-top: 0 !important;
    border-left: 0 !important;
    border-right: 0 !important; */
}
.se-input-att-value {
    width: 90px !important;
    height: 20px !important;
    font-size: .9em !important;
    font-style: italic;
}
.se-input-att-list-values {
    max-width: 150px !important;
    height: 20px !important;
    font-size: .9em !important;
    font-style: italic;
    cursor: pointer;
    pointer-events: auto !important;
}
.se-select-att-value {
    font-size: .9em !important;
    font-style: italic;
    height: 20px !important;
    width: 65px !important;
    line-height: 20px !important;
}
.se-select-att-type {
    font-size: .9em !important;
    font-style: italic;
    height: 20px !important;
    width: 50px !important;
    line-height: 20px !important;
}

/* labels */
.label-red {
    color: #ff4e2f;
}
.label-yellow {
    color: #f3dd34;
}
.label-green {
    color: #61a51d;
}
.label-blue {
    color: #3287e8;
}
.label-purple {
    color: #f200f2;
}

/* annotator-actions */
.box-annotator-actions { 
    display: none;
}
.tag-table-row:hover .box-annotator-actions {
    display: inline;
}

/* for converter */
.converter-dropzone {
    border: 1px solid #999999;
    padding: 5px;
    width: 300px;
    min-height: 250px;
}
.converter-dropzone h5 {
    background-color: white;
}
.converter-button {
    height: auto !important;
    line-height: 1.2em;
}
.converter-file-list {
    max-height: 300px;
    overflow-y: auto;
}
.converter-file-row {
    border-bottom: 1px dotted #cccccc;
    padding: 0 0 0 5px;
    display: flex;
    flex-direction: row;
}
.converter-file-row a {
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}
.converter-result-box {
    padding: 0 0 0 1em;
    /* border-left: 1px dotted #cccccc; */
}
.converter-result-download {
    padding: 0 2px;
    color: white;
    background-color: #99d8b3;
}
.converter-result-download:hover {
    background-color: #23911b;
}

/* for changelog display */
.changelog-h3 {
    margin: 0.5em 0;
}
.changelog-p {
    margin: 0;
}

/* for text quick viewer */
.tq-viewer-box {
    position: absolute;
    border: 1px solid #cacaca;
    background-color: white;
    width: 500px;
    box-shadow: 3px 3px #eaeaea;
}
.tq-viewer-header {
    height: 2em;
    line-height: 2em;
    font-weight: bold;
    padding: 0 5px;
    color: #333333;
    background-color: whitesmoke;
    cursor: grab;
}
.tq-viewer-footer {
    height: 2em;
    font-size: 0.9em;
    color: #333333;
    padding: 3px 5px;
    text-align: right;
}
.tq-viewer-oper {
    height: 1.5em;
}
.tq-viewer-content {
    border: 0;
    border-bottom: 1px solid #999999;
    min-height: 180px;
    overflow-y: auto;
    font-family: 'Courier New', Courier, monospace;
    font-size: 0.8em;
}
.razer-hbar {
    width: 100%;
    margin-bottom: 2px;
    border-bottom: 1px solid transparent;
}
.razer-hbar:hover {
    background-color: #eaeaea;
    border-bottom-color: #777777;
}
.razer-hbar-label {
    margin-right: 5px;
    width: 100px;
    min-width: 100px;
    height: 1.2em;
    line-height: 1.2em;
    font-style: italic;
    text-align: right;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}
.razer-hbar-bar-box {
    width: 110px;
    min-width: 110px;
    display: flex;
    flex-direction: row;
}
.razer-hbar-bar {
    height: 1.3em;
}
.razer-bg-FP,
.razer-hbar-bar-FP {
    background-color: #F98686;
    fill: #F98686;
}
.razer-bg-FN,
.razer-hbar-bar-FN {
    background-color: #56B3F6;
    fill: #56B3F6;
}
.razer-hbar-bar-num {
    font-size: 0.8em;
    line-height: 1.5em;
    height: 1.3em;
    margin-left: 2px;
}
.razer-hbar-group {
    padding: 0 0 0 3px;
    border-bottom: 1px dotted #cccccc;
}
.razer-hbar-group:last-child {
    border-bottom: 0;
}
#razer_pan_err_def {
    position: absolute;
    top: 400px;
    right: 0;
    padding: 0.5em;
    border: 1px solid #cccccc;
    box-shadow: 3px 3px 5px #cccccc;
    background-color: white;
    z-index: 99;
    width: min-content;
}
.pan-close {
    position: absolute; 
    left: -7px;
    top: -8px;
    font-size: 1em;
    border-radius: 5px;
    background-color: white;
}
.pan-close:hover {
    color: white;
    background-color: rgb(235, 91, 91);
}
.err-cate-idx {
    font-weight: bold;
    color: black;
    background-color: #d5d5d5;
    padding: 0 2px;;
}
.err-type-row {
    border-bottom: 1px solid transparent
}
.err-type-row:hover {
    background-color: #dedede;
    border-bottom: 1px solid #eaeaea;
}
.err-type-idx {
    color: transparent;
    background-color: transparent;
    padding: 0 2px;;
}
.err-cate-section:hover .err-type-idx {
    color: #333333;
    background-color: #dedede;
}
.err-type-label {
    font-size: 0.9em;
    font-style: italic;
}
.err-cate-section {
    padding: 0 0.5em;
    
    border-right: 1px dotted #ededed;
}
.err-cate-section:last-child {
    border: 0;
}
.err-cate-section:hover {
    background-color: whitesmoke;
}

.err-list-row {
    padding: 3px 16px 3px 0;
    margin: 3px 0;
    min-width: 200px;
    border-bottom: 1px dotted #b3b3b3;
}
.err-list-row:hover {
    background-color: whitesmoke;
}
.err-list-row-sentence {
    font-size: 0.95em;
    color: #535353;
}
.razer-err-list-seq-num {
    position: absolute;
    right: 5px;
    top: -4px;
    font-size: 1.5em;
    color: #e1e1e1;
}
.err-list-row:hover .razer-err-list-seq-num {
    color: #c0c0c0;
    font-weight: bold;
}
.btn-add-err-type {
    border: 1px dashed #cccccc;
    background-color: white;
    width: 40px;
    text-align: center;
    color: #888888;
}
.btn-add-err-type:hover {
    border: 1px dashed #888888;
    color: #333333;
}
#err_sankey_box {
    width: 630px;
    height: 420px;
    padding: 5px;
}
#razer_sankey_diagram {
    width: 630px;
    height: 420px;
}
.sankey-node:hover {
    filter: brightness(88%);
}
.sankey-link {
    fill: none;
    pointer-events: all;
}
.sankey-link:hover {
    filter: brightness(88%);
}
#razer_tag_scatter {
    width: 630px;
    height: 400px;
}

.err-label {
    padding: 0 11px;
    border-radius: 5px;
    font-size: 0.9em;
    height: 1.6em;
    background-color: whitesmoke;
    border: 1px solid #eaeaea;
    cursor: default;
}
.err-label:hover {
    filter: brightness(90%);
}
.err-label .pan-close {
    display: none;
    left: -1px !important;
    top: -1px !important;
    padding: 1px 2px;
}
.err-label:hover .pan-close {
    display: inline;
}
.razer-lane-1 {
    width: 240px;
    min-width: 240px;
}
.razer-lane-3 {
    width: 640px;
    min-width: 640px;
}
/* for the vpp simple item list */
.simple-item-list {
    width: 100%;
    height: 100%;
}
.simple-item-list-header {
    margin-bottom: 3px;
    border-bottom: 1px solid #DFDFDF;
}
.simple-item-list-body {
    max-height: calc(100% - 90px); 
    overflow-x: hidden; 
    overflow-y: auto;
}
.simple-item-list-footer {
    width: 100%;
}

.item-list {
    font-size: .9em;
    padding: 2px;
}
.item-list li {
    border-bottom: 1px dotted #eeeeee;
}
.item-list li.item-selected {
    font-weight: bold;
    background-color: #EFEFEF;
    border-left: 3px solid #1ba1e2;
    padding-left: 5px;
}
.item-list-row {
    margin-bottom: 1px;
}
.item-list-row:hover {
    background-color: #e9e8e8;
}
.item-list-row-name {
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    cursor: pointer;
}
.item-list-row-name-unsaved {
    font-style: italic;
}
.dropfile-box {
    border-radius: 8px;
    border: 1px dotted #bcbcbc;
    text-align: center;
}
.ribbon-menu-divider {
    height: calc(100% - 7px);
    width: 1px;
    margin: 4px !important;
    border-right: 1px solid #dadbdc;
}
</style>

<style id="dtd_style">
</style>

</head>

<body>

<div id="start-screen">
    <h1>
        <i class="fa fa-highlighter"></i>
        MedTator
    </h1>
    <div id="ss-msg">Loading data and initializing GUI ...</div>
</div>

<div id="app_hotpot">

    <nav data-role="ribbonmenu">
        <ul class="tabs-holder">
            <li title="Text annotation of entities and relations in multiple documents"
                v-on:click="switch_mui('annotation')"
                v-bind:class="{'active': section=='annotation'}">
                <a id="tab_link_annotation" href="#section-1-1">
                    <i class="fa fa-highlighter"></i>
                    Annotation
                </a>
            </li>

            <li title="Real-time statistics on the annotated corpus"
                v-on:click="switch_mui('statistics')"
                v-bind:class="{'active': section=='statistics'}">
                <a href="#section-1-5">
                    <i class="fa fa-chart-bar"></i>
                    Statistics
                </a>
            </li>

            <li title="Export the annotated corpus to other formats for downstream tasks" 
                v-on:click="switch_mui('ruleset')"
                v-bind:class="{'active': section=='ruleset'}">
                <a href="#section-1-4">
                    <i class="fa fa-file-export"></i>
                    Export
                </a>
            </li>

            <li title="Adjudicate the annotations from two annotators"
                v-on:click="switch_mui('iaa')"
                v-bind:class="{'active': section=='iaa'}">
                <a href="#section-1-6">
                    <i class="fa fa-people-arrows"></i>
                    Adjudication
                </a>
            </li>

            <li title="Convert the files to MedTator XML format"
                v-on:click="switch_mui('corpus')"
                v-bind:class="{'active': section=='corpus'}">
                <a href="#section-1-2">
                    <i class="fas fa-mortar-pestle"></i>
                    Converter
                </a>
            </li>

            <li title="Analyze the errors by NLP systems with gold standard corpus made by MedTator"
                v-if="is_show_new_ui_for_ea()"
                v-on:click="switch_mui('razer')"
                v-bind:class="{'active': section=='razer'}">
                <a href="#section-1-3">
                    <i class="fas fa-car-crash"></i>
                    Error Analysis
                </a>
            </li>

            <li title="A set of tools for various NLP related tasks" 
                v-if="is_show_new_ui_for_tk()"
                v-on:click="switch_mui('toolkit')"
                v-bind:class="{'active': section=='toolkit'}">
                <a href="#section-1-7">
                    <i class="fas fa-toolbox"></i>
                    Toolkit
                </a>
            </li>
        </ul>

        <div class="content-holder">
            
            <!-- the section for annotation -->
<div class="section" id="section-1-1" 
v-bind:class="{'active': section=='annotation'}">

<div class="group">

    <div id="dropzone_dtd" 
        class="dropzone"
        title="Drop a schema file (.dtd) that contains the annotation task"
        v-on:click="on_click_open_dtd_file"
        v-on:dragover="on_dragover_prevent_default"
        v-on:drop="on_drop_dropzone_dtd">
        <div v-if="dtd != null" class="zone-text">
            <b>{{ dtd.name }}</b><br>
            {{ dtd.etags.length }} Entity Tags<br>
            {{ dtd.rtags.length }} Link Tags
        </div>
        <div v-else>
            Drop a <b>Schema</b> File Here
        </div>
    </div>

    <span class="title">

        Schema File (.yaml / json / dtd)

        <span v-if="dtd != null">
            <a href="javascript:void(0);"
                title="Download the current schema file"
                class="link-btn"
                v-on:click="download_schema_as_dtd">
                <i class="fa fa-download"></i>
            </a>
        </span>
    </span>
</div>


<div class="group">
    <div id="dropzone_ann" 
        title="Drop the file(s) for annotation (.xml or .txt) or folder(s) containing annotation files"
        v-on:click="on_click_open_ann_files"
        v-on:dragover="on_dragover_prevent_default"
        v-on:drop="on_drop_filelist"
        v-bind:class="{'disabled-zone': dtd == null, 'dropzone': dtd != null}">

        <div v-if="dtd == null"
            title="Load the schema for annotation task first">
            <i class="fa fa-arrow-left"></i>
            Load schema file first
        </div>
        <div v-else-if="virtual_anns.v_anns.length == 0" 
            title="Drop the file(s) for annotation (.xml or .txt) or folder(s) containing annotation files"
            class="zone-text">
            Drop <b>Annotation</b> <br>
            File(s) / Folder Here
        </div>
        <div v-else-if="ann_idx == null"
            title="Drop the file(s) for annotation (.xml or .txt) or folder(s) containing annotation files"
            class="zone-text">
            Select <b>Annotation File</b> <br>
            in the File List
        </div>
        <div v-else
            title="Drop the file(s) for annotation (.xml or .txt) or folder(s) containing annotation files"
            class="zone-text">
            <b>{{ anns[ann_idx]._filename }}</b><br>
            {{ anns[ann_idx].text.length }} chars<br>
            {{ anns[ann_idx].tags.length }} tags
        </div>
    </div>

    <span class="title">Annotation File (.xml)</span>
</div>


<div v-if="ann_idx != null"
    class="group">
    <button class="ribbon-button"
        title="Save the current editing annotation file to local disk (Ctrl + S)"
        v-if="has_FSA_API()"
        v-on:click="save_xml">
        <span class="icon">
            <i class="far fa-save"></i>
        </span>
        <span class="caption">Save</span>
    </button>

    <!-- 
    <button class="ribbon-button"
        title="Save a copy of the current editing annotation file"
        v-if="has_FSA_API()"
        v-on:click="save_as_xml">
        <span class="icon">
            <i class="far fa-copy"></i>
        </span>
        <span class="caption">Save as</span>
    </button> 
    -->

    <div class="ribbon-split-button"
        id="btn_annotation_save_">
        <button class="ribbon-main"
            title="Save a copy of the current editing annotation file"
            v-on:click="save_as_xml">
            <span class="icon">
                <i class="far fa-copy"></i>
            </span>
        </button>
        <span class="ribbon-split dropdown-toggle">
            Save as
        </span>
        <ul class="ribbon-dropdown text-left" 
            data-role="dropdown" 
            data-duration="100">

            <li class="divider"></li>

            <li title="Download a copy of the current annotation as MedTator XML format"
                v-on:click="download_copy_as_xml">
                <a href="javascript:void(0);">Download a copy</a>
            </li>

            <li title="Download a copy of the current annotation as BioC XML format"
                v-on:click="download_copy_as_bioc">
                <a href="javascript:void(0);">Download a copy as BioC format</a>
            </li>

            <li class="divider"></li>

            <li title="Download all annotation files as a ZIP file"
                v-on:click="download_all_as_zip(true)">
                <a href="javascript:void(0);">Download all as a ZIP file</a>
            </li>

            <li title="Download all annotation files and the schema file as a ZIP file"
                v-on:click="download_all_as_zip(false)">
                <a href="javascript:void(0);">Download all with schema as a ZIP file</a>
            </li>
        </ul>
    </div>

    <button class="ribbon-button"
        title="Due to limited browser support, the current annotation file could only be downloaded."
        v-if="!has_FSA_API()"
        v-on:click="download_copy_as_xml">
        <span class="icon">
            <i class="fa fa-file-download"></i>
        </span>
        <span class="caption">Download</span>
    </button>
    
    <a id="downloadAnchorElem" style="display:none"></a>

    <span class="title">Save</span>
</div>

<div v-if="ann_idx != null"
    class="group">
    
    <div class="ribbon-split-button"
        id="btn_annotation_save_">
        <button class="ribbon-main"
            title="Set a Green label to the current file"
            v-on:click="set_label('green')">
            <span class="icon">
                <i class="far fa-bookmark"></i>
            </span>
        </button>
        <span class="ribbon-split dropdown-toggle">Set Labels</span>
        <ul class="ribbon-dropdown text-left" 
            data-role="dropdown" 
            data-duration="100">
            <li title="Set a Green label to the current file"
                v-on:click="set_label('green')">
                <a href="javascript:void(0);">Set <b class="label-green"> <i class="fa fa-bookmark"></i> Green</b> Label</a>
            </li>
            <li title="Set a red label to the current file"
                v-on:click="set_label('red')">
                <a href="javascript:void(0);">Set <b class="label-red"> <i class="fa fa-bookmark"></i> Red</b> Label</a>
            </li>
            <li title="Set a yellow label to the current file"
                v-on:click="set_label('yellow')">
                <a href="javascript:void(0);">Set <b class="label-yellow"> <i class="fa fa-bookmark"></i> Yellow</b> Label</a>
            </li>
            <li title="Set a blue label to the current file"
                v-on:click="set_label('blue')">
                <a href="javascript:void(0);">Set <b class="label-blue"> <i class="fa fa-bookmark"></i> Blue</b> Label</a>
            </li>
            <!-- <li title="Set a purple label to the current file"
                v-on:click="set_label('purple')">
                <a href="javascript:void(0);">Set <b class="label-purple"> <i class="fa fa-bookmark"></i> Purple</b> Label</a>
            </li> -->

            <li class="divider"></li>

            <li title="Download all annotation files and the schema file as a ZIP file"
                v-on:click="remove_labels()">
                <a href="javascript:void(0);">Remove Labels</a>
            </li>
        </ul>
    </div>
    
    <span class="title">File Label</span>
</div>

<div class="group">
    <div title="Display the current annotation file in its original format or sentence by sentence">
        <input type="radio" 
            name="display_mode" 
            value="document" 
            data-role="radio" 
            data-caption="Document" 
            checked 
            title="Display the current annotation file in its original format"
            v-model="cm.display_mode"
            @change="on_change_display_mode">
        <br>
        <input type="radio" 
            name="display_mode" 
            value="sentences" 
            data-role="radio" 
            data-caption="Sentences" 
            title="Display the current annotation file sentence by sentence. The sentence tokenization algorithm could be changed in settings."
            v-model="cm.display_mode"
            @change="on_change_display_mode">
    </div>



    <div class="ribbon-split-button">
        <button class="ribbon-main"
            title="Visualize the text and annotated tags of the selected text or the whole document."
            v-bind:disabled="dtd == null || anns.length == 0 || ann_idx == null"
            v-on:click="show_avbrat(true)">
            <span class="icon">
                <i class="fas fa-igloo"></i>
            </span>
        </button>
        <span class="ribbon-split dropdown-toggle">Visualize</span>
        <ul class="ribbon-dropdown text-left" 
            data-role="dropdown" 
            data-duration="100">

            <li title="Visualize the selected text and annotated tags."
                v-on:click="show_avbrat(true)">
                <a href="javascript:void(0);">Visualize Selection</a>
            </li>

            <li title="Visualize the whole document and annotated tags."
                v-on:click="show_avbrat(false)">
                <a href="javascript:void(0);">Visualize Whole Document</a>
            </li>

            <li class="divider"></li>

            <li title="The best practices for corpus annotation."
                v-on:click="show_avbrat_help()">
                <a href="javascript:void(0);">How to use?</a>
            </li>
        </ul>
    </div>

    <span class="title">Display Mode</span>
</div>

<div class="group">
    <div class="d-flex flex-column">
        <button class="ribbon-icon-button"
            title="Show search bar"
            style="height: 30px;"
            v-on:click="show_search_bar">
            <span class="icon">
                <i class="fa fa-search"></i>
            </span>
            <span class="caption">Search</span>
        </button>

        <button class="ribbon-icon-button"
            title="Clear highlights of the search results"
            style="height: 30px;"
            v-on:click="clear_search_result">
            <span class="icon">
                <i class="fa fa-eraser"></i>
            </span>
            <span class="caption">Clear</span>
        </button>
    </div>
    <!-- <div>

        <button class="ribbon-button" 
            title="Show search bar"
            v-on:click="show_search_bar">
            <span class="icon">
                <i class="fa fa-search"></i>
            </span>
            <span class="caption">Search</span>
        </button>
        
        <button class="ribbon-button" 
            title="Clear highlights of the search results"
            v-on:click="clear_search_result">
            <span class="icon">
                <i class="fa fa-eraser"></i>
            </span>
            <span class="caption">Clear</span>
        </button>
        
    </div> -->

    <span class="title">Search</span>
</div>

<div class="group">
    <div>
        <input type="radio" 
            name="mark_mode" 
            value="node" 
            data-role="radio" 
            data-caption="Color + ID" 
            checked 
            title="Display the entity tags on a background color with the tag ID"
            v-model="cm.mark_mode"
            @change="on_change_mark_mode">
        <br>
        <input type="radio" 
            name="mark_mode" 
            value="span" 
            data-role="radio" 
            data-caption="Color Only" 
            title="Display the entity tags on the corresponding background color only"
            v-model="cm.mark_mode"
            @change="on_change_mark_mode">
    </div>
    <span class="title">Entity Marks</span>
</div>

<div class="group">
    <div title="Display the link tags and lines">
        <input type="checkbox" 
            class="check"
            data-role="switch" 
            data-caption="Show Links"
            title="Visualize link tags in the current document"
            v-model="cm.enabled_links"
            @change="on_change_link_settings">
        <br>
        
        <input type="checkbox" 
            class="check"
            data-role="switch" 
            data-caption="Show Lines"
            title="Visualize the line drawing of link tag"
            v-model="cm.enabled_link_complex"
            @change="on_change_link_settings">
    </div>

    <!-- <div v-show="is_linking">
        <button class="ribbon-button"
            title="Create a new link tag with selected tags"
            v-on:click="done_linking">
            <span class="icon">
                <span class="fa fa-check-circle"></span>
            </span>
            <span class="caption">Done Linking</span>
        </button>
    </div>

    <div v-show="is_linking">
        <button class="ribbon-button"
            title="Stop linking tags and discard selected tags"
            v-on:click="cancel_linking">
            <span class="icon">
                <span class="far fa-times-circle"></span>
            </span>
            <span class="caption">Cancel Linking</span>
        </button>
    </div> -->
    <span class="title">Link Marks</span>
</div>

<div class="group">
    <div class="ribbon-toggle-group">
        <button class="ribbon-icon-button active"
            title="Show simple hints based on annotated tags"
            v-on:click="on_change_hint_mode('simple')">
            <span class="icon">
                <span class="mif-list"></span>
            </span>
            <span class="caption">Simple Hint</span>
        </button>

        <!-- <button class="ribbon-icon-button"
            v-on:click="on_change_hint_mode('smart')">
            <span class="icon">
                <span class="fa fa-magic"></span>
            </span>
            <span class="caption">Smart</span>
        </button> -->

        <button class="ribbon-icon-button"
            title="Turn off hint display"
            v-on:click="on_change_hint_mode('off')">
            <span class="icon">
                <span class="fa fa-ban"></span>
            </span>
            <span class="caption">No Hint</span>
        </button>
    </div>

    <div>

        <button class="ribbon-button" 
            title="Accept all hints in the current annotation"
            v-on:click="accept_all_hints">
            <span class="icon">
                <i class="fa fa-check-double"></i>
            </span>
            <span class="caption">Accept All</span>
        </button>
        
    </div>

    <span class="title">Hint Marks</span>
</div>


<div class="group">

    <div class="ribbon-split-button"
        id="btn_annotation_load_sample">
        <button class="ribbon-main"
            title="Load a minimal task"
            v-on:click="load_sample_ds('MINIMAL_TASK')">
            <span class="icon">
                <i class="far fa-edit"></i>
            </span>
        </button>
        <span class="ribbon-split dropdown-toggle">Sample</span>
        <ul class="ribbon-dropdown text-left" 
            data-role="dropdown" 
            data-duration="100">
            <li title="Sample Text: COVID vaccine note for annotation test"
                v-on:click="load_sample_txt">
                <a href="javascript:void(0);">Sample Text: COVID Vaccine Note</a>
            </li>
            <li title="Sample Text from user's input"
                v-on:click="load_sample_txt_from_input">
                <a href="javascript:void(0);">Customize a Sample Text</a>
            </li>
            <li class="divider"></li>
            
            
            <li title="A minimal annotation task"
                v-on:click="load_sample_ds('MINIMAL_TASK');">
                <a href="javascript:void(0);">Minimal Annotation Task</a>
            </li>
            
            
            
            <li title="A sample for entity and relation annotation"
                v-on:click="load_sample_ds('ENTITY_RELATION_TASK');">
                <a href="javascript:void(0);">Entity and Relation Annotation Task</a>
            </li>
            
            
            
            <li title="A sample for document level annotation samples"
                v-on:click="load_sample_ds('DOCUMENT_LEVEL_TASK');">
                <a href="javascript:void(0);">Document-Level Annotation Task</a>
            </li>
            
            
            
            <li title="A sample for IAA calculation"
                v-on:click="load_sample_ds('IAA_TASK');">
                <a href="javascript:void(0);">IAA Calculation Task</a>
            </li>
            
            
            <li class="divider"></li>
            <li title="A sample corpus of VAERS dataset for vaccine adverse events"
                v-on:click="load_sample_ds_remote('VAERS_20_NOTES');">
                <a href="javascript:void(0);">
                    <i class="fab fa-github"></i>
                    VAERS Adverse Event Annotation Task
                </a>
            </li>
            <li title="A sample of error analysis task"
                v-on:click="load_sample_ds('SIMPLE_EA')">
                <a href="javascript:void(0);">
                    <i class="fab fa-github"></i>
                    Error Analysis of NLP System Results
                </a>
            </li>
        </ul>
    </div>

    <div style="margin-top: -2px;">
        <div class="ribbon-split-button">
            <button v-on:click="show_schema_editor(0)"
                style="height: 40px;"
                title="Edit current schema or create a new schema"
                class="ribbon-main">
                <span class="icon">
                    <span class="mif-cell-setting"></span>
                </span>
            </button>
            <span class="ribbon-split dropdown-toggle">Schema</span>
            <ul class="ribbon-dropdown text-left" 
                data-role="dropdown" data-duration="100">
                <li v-if="dtd != null"
                    title="Show the schema editor with the current schema in the annotation tab">
                    <a href="javascript:void(0);"
                    v-on:click="show_schema_editor(2)">
                    Edit Current Schema File
                </a></li>
                <li title="Show the schema editor with a new blank schema file">
                    <a href="javascript:void(0);"
                    v-on:click="show_schema_editor(1)">
                    Create New Schema File
                </a></li>
                <!-- <li><a href="javascript:void(0);" class="dropdown-toggle">
                    Sample Schema Files
                    </a>
                    <ul class="ribbon-dropdown" data-role="dropdown">
                        <li><a href="javascript:void(0);">
                            COVID-19 Symptons
                        </a></li>
                        <li><a href="javascript:void(0);">
                            Long COVID-19
                        </a></li>
                    </ul>
                </li> -->
                <li class="divider"></li>
                <li title="Show wiki page of how to use schema editor">
                    <a href="javascript:void(0);"
                    v-on:click="show_se_help">
                    How to Use Schema Editor?
                </a></li>
                <li title="Show more sample schema files in MedTator GitHub repo">
                    <a href="javascript:void(0);"
                    v-on:click="show_sample_schema_files">
                    More Sample Schema Files ...
                </a></li>
            </ul>
        </div>
    </div>

    <div class="ribbon-split-button">
        <button class="ribbon-main"
            title="MedTator wiki that includes quick start, manual, and technical details."
            v-on:click="show_wiki">
            <span class="icon">
                <i class="fa fa-info"></i>
            </span>
        </button>
        <span class="ribbon-split dropdown-toggle">Wiki</span>
        <ul class="ribbon-dropdown text-left" 
            data-role="dropdown" 
            data-duration="100">

            <li title="MedTator wiki that includes quick start, manual, and technical details."
                v-on:click="show_wiki">
                <a href="javascript:void(0);">MedTator Wiki</a>
            </li>

            <li title="The best practices for corpus annotation."
                v-on:click="show_best_practice">
                <a href="javascript:void(0);">Annotation Best Practice</a>
            </li>

            <li class="divider"></li>

            <li title="Found anything not working? Report an issue or send feedback"
                v-on:click="report_an_issue">
                <a href="javascript:void(0);">Report an Issue</a>
            </li>
        </ul>
    </div>

    <!-- <button class="ribbon-button" 
        data-role="popover"
        data-popover-position="right"
        data-popover-text="MedTator wiki that includes quick start, <br>manual, and technical details."
        v-on:click="show_wiki">
        <span class="icon">
            <i class="fa fa-info"></i>
        </span>
        <span class="caption">Wiki</span>
    </button> -->

    <span class="title">Help</span>
</div>

</div>

            <!-- the section for corpus schema -->
<div class="section" id="section-1-2"
v-bind:class="{'active': section=='corpus'}">

<div class="group">
    <button class="ribbon-button"
        title="Clear all files for conversion"
        v-on:click="clear_converter_corpus_all">
        <span class="icon">
            <i class="far fa-times-circle"></i>
        </span>
        <span class="caption">Clear All</span>
    </button>

    <span class="title">&nbsp;</span>
</div>

<div class="group">
    
    <button class="ribbon-button" 
        title="Set the input format as raw text"
        v-on:click="switch_corpus('raw')"
        v-bind:class="{'active': converter_corpus_task=='raw'}">
        <span class="icon">
            <i class="far fa-file-alt"></i>
        </span>
        <span class="caption">
            Raw Text
        </span>
    </button>


    <button class="ribbon-button" 
        title="Set the input format as MedTagger .ann format"
        v-on:click="switch_corpus('medtagger')"
        v-bind:class="{'active': converter_corpus_task=='medtagger'}">
        <span class="icon">
            <i class="far fa-file-code"></i>
        </span>
        <span class="caption">
            MedTagger
        </span>
    </button>

    <!-- 
    <button class="ribbon-button"
        title="Set the input format as Brat format"
        v-on:click="switch_corpus('brat')">
        <span class="icon">
            <i class="far fa-file-code"></i>
        </span>
        <span class="caption">
            Brat
        </span>
    </button>
    -->

    <span class="title">
        Input Format: 
        <b>{{ converter_corpus_task }}</b>
    </span>
</div>

<div class="group">

    <button class="ribbon-button"
        v-bind:disabled="dtd == null"
        title="Convert the loaded files to MedTator format"
        v-on:click="convert_corpus_to_medtator_format">
        <span class="icon">
            <i class="fas fa-mortar-pestle"></i>
        </span>
        <span class="caption">Convert Files</span>
    </button>

    <span class="title">Conversion</span>
</div>

<div class="group">

    <button class="ribbon-button"
        title="Download the converted MedTator format files as a zip file"
        v-bind:disabled="dtd == null"
        v-on:click="download_converted_results_as_zip">
        <span class="icon">
            <i class="fas fa-download"></i>
        </span>
        <span class="caption">Download as zip</span>
    </button>

    <span class="title">Results</span>
</div>

<div class="group">

    <button class="ribbon-button"
        title="Open the wiki page to show how to use the converter"
        v-on:click="show_converter_how_to_user">
        <span class="icon">
            <i class="fas fa-question"></i>
        </span>
        <span class="caption">How to use</span>
    </button>

    <span class="title">Help</span>
</div> 

<!-- 
<div class="group">
    <div id="dropzone_txt" class="dropzone">
        <div v-if="txt_anns.length == 0" class="zone-text">
            Drop <b>Raw Text</b> File <br>
            Here
        </div>
        <div v-else>
            {{ txt_anns.length }} txt files
        </div>
    </div>

    <button class="ribbon-button"
        :disabled="dtd == null"
        v-on:click="open_txt_files">
        <span class="icon">
            <i class="far fa-file-code"></i>
        </span>
        <span class="caption">Open .txt Files</span>
    </button>

    <span class="title">Raw Text Files</span>
</div>

<div class="group">
    
    <div class="d-flex flex-column ml-2">
        <div class="mt-1 mb-2">
            <label for="">Prefix for XML Files</label>
            <input type="text" class="ipt-md"
                v-model="txt_xml_prefix">
        </div>
        <div>
            <label for="">Suffix for XML Files</label>
            <input type="text" class="ipt-md"
                v-model="txt_xml_suffix">
        </div>
    </div>

    <button class="ribbon-button"
        :disabled="dtd == null || txt_anns.length == 0"
        v-on:click="convert_txt_anns_to_xmls">
        <span class="icon">
            <i class="far fa-file-code"></i>
        </span>
        <span class="caption">Convert to XMLs</span>
    </button>

    <span class="title">Annotation XML File</span>
</div>

<div class="group">

    <button class="ribbon-button"
        :disabled="txt_xmls.length == 0 || txt_xmls.length != txt_anns.length"
        v-on:click="download_txt_xmls_as_zip">
        <span class="icon">
            <i class="fa fa-download"></i>
        </span>
        <span class="caption">All as a ZIP</span>
    </button>

    <span class="title">Download</span>
</div> 
-->

</div>

            <!-- the section for statistics -->
<div class="section" id="section-1-5"
v-bind:class="{'active': section=='statistics'}">
<div class="group">
    <button class="ribbon-button" 
        :disabled="dtd == null"
        v-on:click="update_whole_hint_dict">
        <span class="icon">
            <i class="fa fa-sync"></i>
        </span>
        <span class="caption">Refresh</span>
    </button>

    <span class="title">&nbsp;</span>    
</div>

<div class="group">
    <button class="ribbon-button" 
        title="Download the summary of the statistics"
        :disabled="dtd == null"
        v-on:click="download_stat_summary">
        <span class="icon">
            <i class="far fa-clipboard"></i>
        </span>
        <span class="caption">Summary (.csv)</span>
    </button>

    <button class="ribbon-button" 
        title="Download the detailed statistics"
        :disabled="dtd == null"
        v-on:click="download_stat_details">
        <span class="icon">
            <i class="fas fa-clipboard-list"></i>
        </span>
        <span class="caption">Details (.xlsx)</span>
    </button>

    <span class="title">Download</span>    
</div>

<div class="group">
    <button class="ribbon-button" 
        title="Reset all filters to default values"
        :disabled="dtd == null"
        v-on:click="reset_stat_filters">
        <span class="icon">
            <i class="fas fa-undo"></i>
        </span>
        <span class="caption">Reset All</span>
    </button>

    <div class="h-splitter-menu ml-2 mr-2">&nbsp;</div>

    <div>
        <input type="checkbox" 
            class="check"
            data-role="switch" 
            data-caption="Token Text"
            v-model="stat_filter_token_text"
            v-bind:disabled="dtd == null"
            @change="on_change_stat_filters">
        <br>
    </div>

    <div class="h-splitter-menu ml-2 mr-2">&nbsp;</div>

    <div class="d-flex flex-column"
        style="width: 90px;">
        <div style="width: 100px;">
            Show Token: 
            <b v-if="stat_filter_min_tokens == 0">
                ALL
            </b>
            <b v-else>
                &leq;{{ stat_filter_min_tokens }}
            </b>
        </div>
        <input v-model.number='stat_filter_min_tokens'
            type="range" 
            name="volume"
            min="0" 
            max="10"
            style="width: 90px;">
        <div class="d-flex flex-row flex-justify-between">
            <div>
                All
            </div>
            <div>
                5
            </div>
            <div>
                10
            </div>
        </div>

    </div>

    <span class="title">Filters</span>    
</div>

</div>

            <!-- the section for ruleset -->
<div class="section" id="section-1-4"
v-bind:class="{'active': section=='ruleset'}">

<div v-if="dtd != null"
     class="group">
    <div>
        <p class="mb-1">
            <i class="fa fa-list"></i>
            Summary:
        </p>
        <p class="mb-1 mt-1">
            <b>
                {{ anns.length }}
            </b>
            Documents
            <br>
            <b>
                {{ count_tags_in_anns(anns)}}
            </b>
            Annotated Tags
        </p>
    </div>

    <span class="title">&nbsp;</span>
</div>

<div class="group">
    <button class="ribbon-button" 
        :disabled="dtd == null"
        v-on:click="download_text_tsv">
        <span class="icon">
            <i class="far fa-file-excel"></i>
        </span>
        <span class="caption">Tag Text</span>
    </button>

    <button class="ribbon-button" 
        :disabled="dtd == null"
        v-on:click="download_text_sent_tsv">
        <span class="icon">
            <i class="far fa-file-excel"></i>
        </span>
        <span class="caption">Tag &amp; Sentence</span>
    </button>

    <span class="title">Text</span>
</div>

<div class="group">
    <button class="ribbon-button" 
        :disabled="dtd == null"
        title="Download IOB2/BIO format"
        v-on:click="download_dataset_iob2">
        <span class="icon">
            <i class="far fa-file"></i>
        </span>
        <span class="caption">IOB2/BIO (.tsv)</span>
    </button>

    <button class="ribbon-button" 
        :disabled="dtd == null"
        title="Download BioC format"
        v-on:click="download_dataset_bioc">
        <span class="icon">
            <i class="far fa-file-code"></i>
        </span>
        <span class="caption">BioC (.xml)</span>
    </button>

    <span class="title">Dataset</span>
</div>

<div class="group">
    <button class="ribbon-button" 
        :disabled="dtd == null"
        v-on:click="download_ruleset_medtagger_zip">
        <span class="icon">
            <i class="far fa-file-archive"></i>
        </span>
        <span class="caption">MedTagger (.zip)</span>
    </button>

    <div class="h-splitter-menu ml-2 mr-2">&nbsp;</div>

    <button class="ribbon-button" 
        :disabled="dtd == null"
        v-on:click="download_ruleset_spacy_jsonl">
        <span class="icon">
            <i class="far fa-file-code"></i>
        </span>
        <span class="caption">spaCy (.jsonl)</span>
    </button>
    <span class="title">Ruleset</span>
</div>

<div class="group">

    <button class="ribbon-button" 
        title="Examples of how to use the exported ruleset files."
        v-on:click="show_howtouse">
        <span class="icon">
            <i class="fa fa-terminal"></i>
        </span>
        <span class="caption">How to use</span>
    </button>

    <span class="title">Help</span>
</div>

</div>

            <!-- the section for iaa -->
<div class="section" id="section-1-6"
v-bind:class="{'active': section=='iaa'}">

<div class="group">
    <button class="ribbon-button"
        title="Clear all annotation files and calculated IAA results"
        v-on:click="clear_iaa_all(null)">
        <span class="icon">
            <i class="far fa-times-circle"></i>
        </span>
        <span class="caption">Clear All</span>
    </button>

    <span class="title">&nbsp;</span>
</div> 


<div class="group">

    <div id="dropzone_iaa_0"
        v-on:dragover="on_dragover_prevent_default"
        v-on:drop="on_drop_dropzone_iaa($event, 0)"
        class="dropzone-menu-box"
        iaa_id="0">
        <div v-if="dtd == null" 
            class="zone-text">
            Load DTD file first<br>
            in the Annotation Tab
        </div>
        <div v-else-if="iaa_loading_status == 0" 
            class="zone-text">
            <i class="fas fa-spinner fa-spin"></i>
            Reading File ...
        </div>
        <div v-else-if="iaa_ann_list[0].anns.length == 0" 
            class="zone-text">
            Drop Annotation <br>
            File(s) / Folder
        </div>
        <div v-else 
            class="zone-text">
            Annotated {{ count_tags_in_anns(iaa_ann_list[0].anns) }} Tags
            <br>
            in {{ iaa_ann_list[0].anns.length }} Files
        </div>

        <button class="ribbon-tool-button pos-corner-br"
            title="Clear all annotations from annotator A"
            v-if="iaa_ann_list[0].anns.length != 0"
            v-on:click="clear_iaa_all(0)">
            <span class="icon">
                <i class="far fa-times-circle"></i>
            </span>
        </button>

    </div>

    <span class="title">
        Annotator A
    </span>

</div>

<div class="group">

    <!-- <div class="h-splitter-menu ml-2 mr-2">&nbsp;</div> -->

    <div id="dropzone_iaa_1" 
        v-on:dragover="on_dragover_prevent_default"
        v-on:drop="on_drop_dropzone_iaa($event, 1)"
        class="dropzone-menu-box"
        iaa_id="1">
        <div v-if="dtd == null" class="zone-text">
            Load DTD file first<br>
            in the Annotation Tab
        </div>
        <div v-else-if="iaa_loading_status == 1" 
            class="zone-text">
            <i class="fas fa-spinner fa-spin"></i>
            Reading File ...
        </div>
        <div v-else-if="iaa_ann_list[1].anns.length == 0" 
            class="zone-text">
            Drop Annotation <br>
            File(s) / Folder
        </div>
        <div v-else class="zone-text">
            Annotated {{ count_tags_in_anns(iaa_ann_list[1].anns) }} Tags
            <br>
            in {{ iaa_ann_list[1].anns.length }} Files
        </div>

        <button class="ribbon-tool-button pos-corner-br"
            title="Clear all annotations from annotator B"
            v-if="iaa_ann_list[1].anns.length != 0"
            v-on:click="clear_iaa_all(1)">
            <span class="icon">
                <i class="far fa-times-circle"></i>
            </span>
        </button>
    </div>

    <span class="title">
        Annotator B
    </span>
</div>

<div class="group">
    <!-- 
    <div class="mr-1">
        <input type="radio" name="match_mode" 
            value="overlap" 
            data-role="radio" 
            data-caption="<i class='fa fa-align-center'></i> Overlap" checked 
            v-model="iaa_match_mode"
            @change="on_change_iaa_settings">
        <br>
        <input type="radio" name="match_mode" 
            value="exact" 
            data-role="radio" 
            data-caption="<i class='fa fa-align-justify'></i> Exact" 
            v-model="iaa_match_mode"
            @change="on_change_iaa_settings"> 
    </div>
    -->
    
    <div v-if="iaa_match_mode == 'overlap'"
        class="p-1 ml-1 mr-1 border bd-gray border-radius">

        <div class="mt-1 mb-1">
            Overlap
            <i class="fa fa-percentage"></i>
        </div>

        <div>        
            <input id="iaa_form_overlap_ratio" 
                name="iaa_form_overlap_ratio" 
                style="width: 36px"
                type="text" 
                class="ipt-md" 
                v-model.number="iaa_overlap_ratio">
            <span class="mr-1">
                %
            </span>

            <!-- <button title="Reset the overlap ratio"
                v-on:click="iaa_overlap_ratio = iaa_overlap_ratio_default">
                <i class="fa fa-undo"></i>
            </button> -->
        </div>
    </div>

    <div class="mr-1">
        <input type="checkbox" 
            class="check"
            title="Include attributes in IAA calculation?"
            data-role="switch" 
            data-caption="Attribute"
            v-model="iaa_use_attributes"
            v-bind:disabled="dtd == null"
            @change="on_change_iaa_use_attributes">
        <br>
        <button class="ribbon-icon-button dropdown-toggle"
            title="Select the attributes to be included in IAA calculation"
            v-bind:disabled="!iaa_use_attributes">
            <span class="icon">
                <i class="fas fa-tasks"></i>
            </span>
            <span class="caption">
                Select Attributes
            </span>
        </button>
        <ul v-if="dtd != null && iaa_use_attributes"
            class="ribbon-dropdown" 
            data-role="dropdown" 
            data-duration="100">
            <li v-for="tag in dtd.etags">
                <a href="javascript:void(0);" class="dropdown-toggle">
                    {{ tag.name }}:
                    
                    <span v-for="att in tag.attrs"
                        v-show="iaa_use_tag_attrs[tag.name][att.name]"
                        class="mr-1 iaa-tag-attr-name">
                        {{ att.name }}
                    </span>
                </a>
                <ul class="ribbon-dropdown" data-role="dropdown">
                    <li v-for="att in tag.attrs"
                        v-bind:class="{'checked': iaa_use_tag_attrs[tag.name][att.name] }">
                        <a href="javascript:void(0);" 
                            v-on:click="toggle_iaa_tag_attrs(tag.name, att.name)">
                            {{ att.name }}
                        </a>
                    </li>
                </ul>
            </li>
            <li class="divider"></li>
            <li title="Select all attributes for IAA calcuation">
                <a href="javascript:void(0);"
                    v-on:click="set_all_iaa_use_tag_attrs(true)">
                    Select All Attributes
                </a>
            </li>
            <li title="Select none attributes for IAA calcuation">
                <a href="javascript:void(0);"
                    v-on:click="set_all_iaa_use_tag_attrs(false)">
                    Select None Attributes
                </a>
            </li>
        </ul>
    </div>


    <button class="ribbon-button"
        title="Calculate the IAA for the given annotation files"
        :disabled="dtd == null || iaa_ann_list[0].anns.length == 0 || iaa_ann_list[1].anns.length == 0"
        v-on:click="calc_iaa">
        <span class="icon">
            <i class="fa fa-calculator"></i>
        </span>
        <span class="caption">Calculate</span>
    </button>
<!-- 
    <div class="ribbon-split-button">
        <button class="ribbon-main">
            <span class="icon">
                <span class="mif-cogs"></span>
            </span>
        </button>
        <span class="ribbon-split dropdown-toggle">Measure</span>
        <ul class="ribbon-dropdown" data-role="dropdown" data-duration="100">
            <li v-bind:class="{'checked': iaa_display_measure == 'f1' }">
                <a href="javascript:void(0);"
                    v-on:click="set_iaa_display_measure('f1')">
                    F1 Score
                </a>
            </li>
            <li v-bind:class="{'checked': iaa_display_measure == 'cohen_kappa' }">
                <a href="javascript:void(0);"
                    v-on:click="set_iaa_display_measure('cohen_kappa')">
                    Cohen's Kappa Coefficient
                </a>
            </li>
        </ul>
    </div> 
-->


    <button class="ribbon-button" 
        :disabled="dtd == null || iaa_gs_dict == null"
        title="Download current IAA calculation result report"
        v-on:click="export_iaa_report">
        <span class="icon">
            <i class="fa fa-clipboard-list"></i>
        </span>
        <span class="caption">Report</span>
    </button>

    <span class="title">Inter-Annotator Agreement (IAA)</span>
</div>

<div class="group">
    <div>
        <input type="checkbox" 
            class="check"
            data-role="switch" 
            data-caption="Agreed Tags"
            v-model="iaa_display_tags_tp"
            v-bind:disabled="dtd == null"
            @change="on_change_iaa_settings">
        <br>

        <input type="checkbox" 
            class="check"
            data-role="switch" 
            data-caption="Tag Context"
            v-model="iaa_display_tags_context"
            v-bind:disabled="dtd == null"
            @change="on_change_iaa_settings">

    </div>
    <span class="title">Tag Display</span>
</div>


<div v-show="dtd != null && iaa_gs_dict != null"
    class="group">
    <!-- <div>
        <div>
            <input type="checkbox" 
                class="check"
                data-role="switch" 
                data-caption="Adj. Panel"
                v-model="iaa_display_adj_panel"
                @change="on_change_iaa_settings">
        </div>

        <button class="ribbon-icon-button"
            :disabled="dtd == null || iaa_dict == null"
            title="Reset current adjudication result to default status"
            v-on:click="make_default_adj">
            <span class="icon">
                <i class="far fa-object-group"></i>
            </span>
            <span class="caption">Reset Adjudication</span>
        </button>
    </div>

-->

    <!-- <div>
        <button class="ribbon-button"
            :disabled="dtd == null || iaa_dict == null"
            title="Reset current adjudication result to default status"
            v-on:click="make_default_adj">
            <span class="icon">
                <i class="far fa-object-group"></i>
            </span>
            <span class="caption">Reset</span>
        </button>

        <button class="ribbon-button" 
            :disabled="dtd == null || iaa_gs_dict == null"
            title="Edit adjudication result in annotation tab"
            v-on:click="transfer_to_annotation_tab">
            <span class="icon">
                <i class="far fa-edit"></i>
            </span>
            <span class="caption">Edit</span>
        </button>

    </div> -->

    <!-- <div class="h-splitter-menu ml-2 mr-2">&nbsp;</div>  -->

    <!-- <div class="d-flex flex-row">

        <button class="ribbon-button" 
            :disabled="dtd == null || iaa_gs_dict == null"
            title="Download current adjudication result"
            v-on:click="download_all_gs">
            <span class="icon">
                <i class="fa fa-file-download"></i>
            </span>
            <span class="caption">Download</span>
        </button>

    </div> -->

    <div class="ribbon-split-button"
        id="btn_annotation_save_">
        <button class="ribbon-main"
            :disabled="dtd == null || iaa_gs_dict == null"
            title="Download all tags from both annotator A and B"
            v-on:click="download_all_iaa_anns">
            <span class="icon">
                <i class="far fa-copy"></i>
            </span>
        </button>
        <span class="ribbon-split dropdown-toggle">Download</span>
        <ul class="ribbon-dropdown text-left" 
            data-role="dropdown" 
            data-duration="100">
            <li title="Download all tags from both annotator A and B"
                v-on:click="download_all_iaa_anns">
                <a href="javascript:void(0);">All Tags from A and B</a>
            </li>

            <li title="Download the adjudicated tags as shown below"
                v-on:click="download_all_gs">
                <a href="javascript:void(0);">Simple Adjudicated Tags</a>
            </li>
        </ul>
    </div>
    
    <span class="title">Adjudication</span>
</div>

</div>

            <div class="section" id="section-1-3"
v-bind:class="{'active': section=='razer'}">


<div class="group">
    <button class="ribbon-button"
        title="Clear all datasets"
        v-on:click="clear_razer_all()">
        <span class="icon">
            <i class="far fa-times-circle"></i>
        </span>
        <span class="caption">Clear All</span>
    </button>

    <span class="title">&nbsp;</span>
</div>



<div class="group">

    <div id="dropzone_razer_0"
        v-on:dragover="on_dragover_prevent_default"
        v-on:drop="on_drop_dropzone_razer($event, 0)"
        title="The Gold Standard Corpus"
        class="dropzone-menu-box">
        <div v-if="dtd == null" 
            class="zone-text">
            Load DTD file first<br>
            in the Annotation Tab
        </div>
        <div v-else-if="razer_loading_status == 0" 
            class="zone-text">
            <i class="fas fa-spinner fa-spin"></i>
            Reading File ...
        </div>
        <div v-else-if="razer_ann_list[0].anns.length == 0" 
            class="zone-text">
            Drop Corpus <br>
            File(s) / Folder
        </div>
        <div v-else 
            class="zone-text">
            Found <br>
            {{ count_tags_in_anns(razer_ann_list[0].anns) }} Tags <br>
            in {{ razer_ann_list[0].anns.length }} Files
        </div>

    </div>

    <span class="title">
        Gold Standard Corpus
    </span>

</div>


<div class="group">

    <div id="dropzone_razer_1"
        v-on:dragover="on_dragover_prevent_default"
        v-on:drop="on_drop_dropzone_razer($event, 1)"
        title="The dataset for error analysis"
        class="dropzone-menu-box">
        <div v-if="dtd == null" 
            class="zone-text">
            Load DTD file first<br>
            in the Annotation Tab
        </div>
        <div v-else-if="razer_loading_status == 0" 
            class="zone-text">
            <i class="fas fa-spinner fa-spin"></i>
            Reading File ...
        </div>
        <div v-else-if="razer_ann_list[1].anns.length == 0" 
            class="zone-text">
            Drop Corpus <br>
            File(s) / Folder
        </div>
        <div v-else 
            class="zone-text">
            Found <br>
            {{ count_tags_in_anns(razer_ann_list[1].anns) }} Tags <br>
            in {{ razer_ann_list[1].anns.length }} Files
        </div>

    </div>

    <span class="title">
        Dataset
    </span>

</div>


<div class="group">

    <div id="dropzone_razer_err_def"
        v-on:dragover="on_dragover_prevent_default"
        v-on:drop="on_drop_dropzone_razer_err_def($event)"
        title="The error definition for error analysis"
        class="dropzone-menu-box">
        <div v-if="dtd == null" 
            class="zone-text">
            Load DTD file first<br>
            in the Annotation Tab
        </div>
        <div v-else-if="razer_loading_status == 0" 
            class="zone-text">
            <i class="fas fa-spinner fa-spin"></i>
            Reading File ...
        </div>
        <div v-else-if="razer_err_def == null" 
            class="zone-text">
            Drop <b>Error Definition</b> <br>
            .yaml File Here <br>
            (Optional)
        </div>
        <div v-else 
            class="zone-text">
            {{ razer_err_def_info.short_title }} <br>
            <b>{{ razer_err_def_info.n_cates }}</b> categories with <br>
            <b>{{ razer_err_def_info.n_types }}</b> error types
        </div>

    </div>

    <span class="title">
        Error Definition 
        <a href="javascript:void(0);"
            v-on:click="show_help('razer_help_err_def')"
            title="What's 'Error Definition'?"
            class="link-btn">
            <i class="far fa-question-circle"></i>
        </a>
    </span>

</div>

<div class="group">


    <div id="dropzone_razer_err_labels" 
        class="dropzone-menu-box"
        title="Drop an error analysis workspace file (.json)"
        v-on:dragover="on_dragover_prevent_default"
        v-on:click="on_click_razer_load_err_labels"
        v-on:drop="on_drop_dropzone_razer_err_labels">
        <div v-if="razer_dict != null" 
            class="zone-text">
            
            <b>{{ get_razer_rst().err_stat.by_iaa.n_FP }}</b> FP and 
            <b>{{ get_razer_rst().err_stat.by_iaa.n_FN }}</b> FN Tags <br>
            <b>{{ get_razer_rst().err_stat.by_smu.total_err_labels }}</b> Error Labels

        </div>
        <div v-else-if="razer_err_labels_file != null" 
            class="zone-text">
            Loaded Error Labels <br>
            {{ razer_err_labels_file.tags.length }} Tags
        </div>
        <div v-else 
            class="zone-text">
            Drop <b>Error Labels</b> <br>
            .json File Here<br>
            (Optional)
        </div>
    </div>

    <!-- <button class="ribbon-button" 
        title="Save the current error analysis workspace"
        v-on:click="on_click_razer_load_err_labels">
        <span class="icon">
            <i class="far fa-folder-open"></i>
        </span>
        <span class="caption">
            Load 
        </span>
    </button> -->


    <!-- <button class="ribbon-button" 
        :disabled="dtd == null || razer_dict == null"
        title="Save the current error labels"
        v-on:click="download_razer_err_labels">
        <span class="icon">
            <i class="far fa-save"></i>
        </span>
        <span class="caption">
            Save 
        </span>
    </button> -->

    <span class="title">
        Error Labels

        <a href="javascript:void(0);"
            v-on:click="show_help('razer_help_err_labels')"
            title="What's 'Error Labels'?"
            class="link-btn">
            <i class="far fa-question-circle"></i>
        </a>
    </span>

</div>




<div class="group">


    <button class="ribbon-button" 
        :disabled="dtd == null || razer_ann_list[0].anns.length == 0 || razer_ann_list[1].anns.length == 0"
        title="Analyze the given dataset"
        v-on:click="parse_razer_files">
        <span class="icon">
            <i class="fas fa-cash-register"></i>
        </span>
        <span v-if="razer_dict == null"
            class="caption">
            Parse
        </span>
        <span v-else
            class="caption">
            Re-Parse
        </span>
    </button>


    <button class="ribbon-button" 
        :disabled="dtd == null || razer_dict == null"
        title="Identify the error tags automatically"
        v-on:click="show_razer_eaws_panel()">
        <span class="icon">
            <i class="fas fa-robot"></i>
        </span>
        <span class="caption">
            Identify
        </span>
    </button>


    <button class="ribbon-button" 
        :disabled="dtd == null || razer_dict == null"
        title="Identify the error tags automatically"
        v-on:click="show_razer_embedding_panel">
        <span class="icon">
            <i class="fas fa-border-none"></i>
        </span>
        <span class="caption">
            Embedding
        </span>
    </button>


    <span class="title">Error Analysis</span>



</div>


<div class="group">
    <div title="Display the tag context information">
        <input type="checkbox" 
            class="check"
            data-role="switch" 
            data-caption="Show Context"
            title="Show the context information of error tags"
            v-model="razer_flag_show_taglist_context">
        <br>
        
        <input type="checkbox" 
            class="check"
            data-role="switch" 
            data-caption="Show Labels"
            title="Show the error labels of tags"
            v-model="razer_flag_show_taglist_labels">
    </div>

    <span class="title">Tag List</span>
</div>




<div class="group">


    <button class="ribbon-button" 
        :disabled="dtd == null || razer_dict == null"
        title="Save the current error labels"
        v-on:click="download_razer_err_labels">
        <span class="icon">
            <i class="fas fa-file-download"></i>
        </span>
        <span class="caption">
            Error Labels 
        </span>
    </button>


    <button class="ribbon-button" 
        :disabled="dtd == null || razer_dict == null"
        title="Download current analysis result report"
        v-on:click="export_razer_report">
        <span class="icon">
            <i class="fa fa-clipboard-list"></i>
        </span>
        <span class="caption">Report</span>
    </button>


    <span class="title">Export</span>

</div>





</div>

            <!-- the section for toolkit -->
<div class="section" id="section-1-7"
v-bind:class="{'active': section=='toolkit'}">

<div class="group">

    <div class="d-flex flex-column">

        <button class="ribbon-icon-button"
            title="Show the visualization tool for MedTagger"
            v-on:click="tk_show_section('medtaggervis')"
            v-bind:class="{'active': toolkit_section=='medtaggervis'}">
            <span class="icon">
                <i class="fas fa-poll-h"></i>
            </span>
            <span class="caption">
                MedTaggerVis
            </span>
        </button>

        <!-- <button class="ribbon-icon-button"
            title="Edit ruleset for MedTagger"
            v-on:click="tk_show_section('ruleseteditor')"
            v-bind:class="{'active': toolkit_section=='ruleseteditor'}">
            <span class="icon">
                <i class="far fa-edit"></i>
            </span>
            <span class="caption">
                MedTagger Rule
            </span>
        </button> -->


        <!-- <button class="ribbon-icon-button"
            title="Editor for IOB2/BIO format"
            v-on:click="tk_show_section('iob2editor')"
            v-bind:class="{'active': toolkit_section=='iob2editor'}">
            <span class="icon">
                <i class="far fa-newspaper"></i>
            </span>
            <span class="caption">
                IOB2/BIO Editor
            </span>
        </button> -->

    </div>

    <span class="title">Tools</span>
</div>


<div v-if="toolkit_section == 'medtaggervis'"
    class="group">

    <button class="ribbon-button"
        title="Clear all files for conversion"
        v-on:click="tk_medtaggervis_clear_all()">
        <span class="icon">
            <i class="far fa-times-circle"></i>
        </span>
        <span class="caption">Clear All Files</span>
    </button>

    <div class="ribbon-menu-divider"></div>

    <!-- <button class="ribbon-button" 
        :disabled="tk_medtaggervis_txt_files.length == 0 || tk_medtaggervis_ann_files.length == 0"
        title="Link and analyze the MedTagger outputs with raw texts"
        v-on:click="tk_medtaggervis_parse_files()">
        <span class="icon">
            <i class="fas fa-cash-register"></i>
        </span>
        <span v-if="razer_dict == null"
            class="caption">
            Link and Parse
        </span>
    </button> -->


    <div title="Display the link tags and lines">
        <input type="checkbox" 
            class="check"
            data-role="switch" 
            data-caption="Show Certainty"
            title="Visualize the 'Certainty' attribute in output"
            v-model="tk_medtaggervis_show_attr_certainty"
            @change="tk_medtaggervis_on_change_settings">
        <br>
        
        <input type="checkbox" 
            class="check"
            data-role="switch" 
            data-caption="Show Status"
            title="Visualize the status attribute in output"
            v-model="tk_medtaggervis_show_attr_status"
            @change="tk_medtaggervis_on_change_settings">
    </div>

    <button class="ribbon-button"
        title="Show how to use MedTaggerVis"
        v-on:click="tk_medtaggervis_how_to_use">
        <span class="icon">
            <i class="fas fa-question"></i>
        </span>
        <span class="caption">How to use</span>
    </button>

    <span class="title">
        <b>MedTaggerVis</b>
    </span>

</div>




<div v-if="toolkit_section == 'iob2editor'"
    class="group">

    <button class="ribbon-button"
        title="Clear all files for conversion"
        v-on:click="tk_medtaggervis_clear_all()">
        <span class="icon">
            <i class="far fa-times-circle"></i>
        </span>
        <span class="caption">Clear All Files</span>
    </button>


    <!-- <button class="ribbon-button" 
        :disabled="tk_medtaggervis_txt_files.length == 0 || tk_medtaggervis_ann_files.length == 0"
        title="Link and analyze the MedTagger outputs with raw texts"
        v-on:click="tk_medtaggervis_parse_files()">
        <span class="icon">
            <i class="fas fa-cash-register"></i>
        </span>
        <span v-if="razer_dict == null"
            class="caption">
            Link and Parse
        </span>
    </button> -->


    <button class="ribbon-button"
        title="Show how to use MedTaggerVis"
        v-on:click="tk_medtaggervis_how_to_use">
        <span class="icon">
            <i class="fas fa-question"></i>
        </span>
        <span class="caption">How to use</span>
    </button>

    <span class="title">
        <b>MedTaggerVis</b>
    </span>

</div>




<div v-if="toolkit_section == 'ruleseteditor'"
    class="group">

    <button class="ribbon-button"
        title="Clear all files for conversion"
        v-on:click="tk_ruleseteditor_clear_all()">
        <span class="icon">
            <i class="far fa-times-circle"></i>
        </span>
        <span class="caption">Clear All Files</span>
    </button>


    <button class="ribbon-button"
        title="Show how to use MedTagger Ruleset Editor"
        v-on:click="tk_ruleseteditor_how_to_use">
        <span class="icon">
            <i class="fas fa-question"></i>
        </span>
        <span class="caption">How to use</span>
    </button>

    <span class="title">
        <b>MedTagger Ruleset Editor</b>
    </span>

</div>

</div>

        </div>

        <div id="app_info">
            MedTator 1.3.15 | 
            <a title="MedTator Settings"
                href="javascript:void(0);"
                v-on:click="cfg.enable_show_settings = true">
                <i class="fa fa-cog"></i>
                Settings
            </a> | 
            <a title="MedTator Settings"
                href="javascript:void(0);"
                v-on:click="show_changelog">
                <i class="fas fa-newspaper"></i>
                Changelog
            </a> | 
            <a target="_blank" 
                title="MedTator Source Code at GitHub"
                href="https://github.com/OHNLP/MedTator">
                <i class="fab fa-github"></i>
            </a>
        </div>

    </nav>

    <!-- the ui for main settings -->
    <div id="app_settings"
    v-show="cfg.enable_show_settings"
    class="box">
    <div class="box-header d-flex flex-justify-between">
        <h4>
            <i class="fa fa-cog"></i>
            MedTator Settings
        </h4>
        <div class="d-flex flex-row">
            <div style="line-height: 2em;">
                MEM: {{ get_metator_mem() }} MB
            </div>
            <button v-on:click="cfg.enable_show_settings = false">
                <i class="fa fa-times"></i>
            </button>
        </div>
    </div>

    <div class="box-body">
        <div class="d-flex flex-row">

            <div class="px-2 setting-tab"
                v-bind:class="{'active-setting-tab':cfg.active_setting_tab=='gui'}"
                v-on:click="switch_setting_tab('gui')">
                <i class="fa fa-table"></i>
                GUI
            </div>

            <div class="px-2 setting-tab"
                v-bind:class="{'active-setting-tab':cfg.active_setting_tab=='system'}"
                v-on:click="switch_setting_tab('system')">
                <i class="fas fa-sliders-h"></i>
                System
            </div>

            <div class="px-2 setting-tab"
                v-bind:class="{'active-setting-tab':cfg.active_setting_tab=='other'}"
                v-on:click="switch_setting_tab('other')">
                <i class="far fa-file"></i>
                Other
            </div>
        </div>

        <!-- other setting tab -->
        <div v-if="cfg.active_setting_tab == 'other'">
            <div class="box-body-item">
                <p>
                    Sentence Splitting Algorithm
                    <a href="javascript:void(0);"
                        v-on:click="show_help('sentence_splitting_algorithm')">
                        <i class="far fa-question-circle"></i>
                    </a>:
                </p>
                <ul class="box">
                    <li>
                        <input type="radio" id="cfg_ssa_v1" 
                            value="simpledot" 
                            v-on:change="on_change_setting('sentence_splitting_algorithm')"
                            v-model="cfg.sentence_splitting_algorithm">
                        <label for="cfg_ssa_v1">Simple Method (Default)</label>
                    </li>
                    <!-- <li>
                        <input type="radio" id="cfg_ssa_v2" 
                            value="compromise" 
                            v-model="cfg.sentence_splitting_algorithm">
                        <label for="cfg_ssa_v2">Compromise NLP</label>
                    </li> -->
                    <li>
                        <input type="radio" id="cfg_ssa_v3" 
                            value="wink_nlp" 
                            v-on:change="on_change_setting('sentence_splitting_algorithm')"
                            v-model="cfg.sentence_splitting_algorithm">
                        <label for="cfg_ssa_v3">Wink NLP Sentence Tokenization</label>
                    </li>
                </ul>
            </div>

            <div class="box-body-item">
                <p>
                    Save workspace in JSON file
                    <a href="javascript:void(0);"
                        v-on:click="show_help('save_workspace_as_json')">
                        <i class="far fa-question-circle"></i>
                    </a>
                </p>
                <div>
                    <button v-on:click="on_click_save_workspace_as_json()">
                        <i class="fas fa-sd-card"></i>
                        Save Workspace
                    </button>
                </div>
            </div>

            <div class="box-body-item">
                <p>
                    Reset to Default Settings
                    <a href="javascript:void(0);"
                        v-on:click="show_help('reset_to_default_settings')">
                        <i class="far fa-question-circle"></i>
                    </a>
                </p>
                <div>
                    <button v-on:click="on_click_reset_to_default_settings()">
                        <i class="fas fa-redo"></i>
                        Reset Settings
                    </button>
                </div>
            </div>
        </div>

        <!-- system setting tab -->
        <div v-if="cfg.active_setting_tab == 'system'">
            <div class="box-body-item">
                <p>
                    Auto-save annotation (Experimental)
                    <a href="javascript:void(0);"
                        v-on:click="show_help('auto_save_current_ann')">
                        <i class="far fa-question-circle"></i>
                    </a>:
                </p>
                <ul class="box">
                    <li>
                        <input type="radio" id="cfg_ui_autosave_disable" 
                            value="disable" 
                            v-on:change="on_change_setting('auto_save_current_ann')"
                            v-model="cfg.auto_save_current_ann">
                        <label for="cfg_ui_autosave_disable">Disable (Default)</label>
                    </li>
                    <li>
                        <input type="radio" id="cfg_ui_autosave_enable" 
                            value="enable" 
                            v-on:change="on_change_setting('auto_save_current_ann')"
                            v-model="cfg.auto_save_current_ann">
                        <label for="cfg_ui_autosave_enable">Enable</label>
                    </li>
                </ul>
                
            </div>


            <div class="box-body-item">
                <p>
                    Auto save/load configuration locally (Experimental)
                    <a href="javascript:void(0);"
                        v-on:click="show_help('auto_sl_current_cfg')">
                        <i class="far fa-question-circle"></i>
                    </a>:
                </p>
                <ul class="box">
                    <li>
                        <input type="radio" id="cfg_ui_autosave_cfg_disable" 
                            value="disable" 
                            v-on:change="on_change_setting('auto_sl_current_cfg')"
                            v-model="cfg.auto_sl_current_cfg">
                        <label for="cfg_ui_autosave_cfg_disable">Disable (Default)</label>
                    </li>
                    <li>
                        <input type="radio" id="cfg_ui_autosave_cfg_enable" 
                            value="enable" 
                            v-on:change="on_change_setting('auto_sl_current_cfg')"
                            v-model="cfg.auto_sl_current_cfg">
                        <label for="cfg_ui_autosave_cfg_enable">Enable</label>
                    </li>
                </ul>
                
            </div>


        </div>

        <!-- GUI setting tab -->
        <div v-else-if="cfg.active_setting_tab == 'gui'">

            <div class="box-body-item">
                <p>
                    New UI for Toolkit (Experimental)
                    <a href="javascript:void(0);"
                        v-on:click="show_help('new_ui_for_tk')">
                        <i class="far fa-question-circle"></i>
                    </a>:
                </p>
                <ul class="box">
                    <li>
                        <input type="radio" id="cfg_uitk_v1" 
                            value="disable" 
                            v-on:change="on_change_setting('new_ui_for_tk')"
                            v-model="cfg.new_ui_for_tk">
                        <label for="cfg_uitk_v1">Disable (Default)</label>
                    </li>
                    <li>
                        <input type="radio" id="cfg_uitk_v2" 
                            value="enable" 
                            v-on:change="on_change_setting('new_ui_for_tk')"
                            v-model="cfg.new_ui_for_tk">
                        <label for="cfg_uitk_v2">Enable</label>
                    </li>
                </ul>
                
            </div>


            <div class="box-body-item">
                <p>
                    New UI for Error Analysis (Development)
                    <a href="javascript:void(0);"
                        v-on:click="show_help('new_ui_for_ea')">
                        <i class="far fa-question-circle"></i>
                    </a>:
                </p>
                <ul class="box">
                    <li>
                        <input type="radio" id="cfg_uiea_v1" 
                            value="disable" 
                            v-on:change="on_change_setting('new_ui_for_ea')"
                            v-model="cfg.new_ui_for_ea">
                        <label for="cfg_uiea_v1">Disable (Default)</label>
                    </li>
                    <li>
                        <input type="radio" id="cfg_uiea_v2" 
                            value="enable" 
                            v-on:change="on_change_setting('new_ui_for_ea')"
                            v-model="cfg.new_ui_for_ea">
                        <label for="cfg_uiea_v2">Enable</label>
                    </li>
                </ul>
                
            </div>

            <div class="box-body-item">
                <p>
                    Cohen's Kappa (Experimental)
                    <a href="javascript:void(0);"
                        v-on:click="show_help('new_ui_for_ck')">
                        <i class="far fa-question-circle"></i>
                    </a>:
                </p>
                <ul class="box">
                    <li>
                        <input type="radio" id="cfg_uick_v1" 
                            value="disable" 
                            v-on:change="on_change_setting('new_ui_for_ck')"
                            v-model="cfg.new_ui_for_ck">
                        <label for="cfg_uick_v1">Disable (Default)</label>
                    </li>
                    <li>
                        <input type="radio" id="cfg_uick_v2" 
                            value="enable" 
                            v-on:change="on_change_setting('new_ui_for_ck')"
                            v-model="cfg.new_ui_for_ck">
                        <label for="cfg_uick_v2">Enable</label>
                    </li>
                </ul>
                
            </div>


            <div class="box-body-item">
                <p>
                    Linking marks selection between editor and concept list 
                    <a href="javascript:void(0);"
                        v-on:click="show_help('linking_marks_selection')">
                        <i class="far fa-question-circle"></i>
                    </a>:
                </p>
                <ul class="box">
                    <li>
                        <input type="radio" id="cfg_lms_v1" 
                            value="all_concepts" 
                            v-on:change="on_change_setting('linking_marks_selection')"
                            v-model="cfg.linking_marks_selection">
                        <label for="cfg_lms_v1">Render all marks (Default)</label>
                    </li>
                    <li>
                        <input type="radio" id="cfg_lms_v2" 
                            value="selected_concepts" 
                            v-on:change="on_change_setting('linking_marks_selection')"
                            v-model="cfg.linking_marks_selection">
                        <label for="cfg_lms_v2">Render marks of selected concept</label>
                    </li>
                </ul>
                
            </div>
        </div>

        <div v-else>
            &nbsp;
        </div>

    </div>
</div>

    <!-- the ui for main annotation -->
    <div v-show="section=='annotation'" id="main_ui" 
    class="main-ui container-fluid">
    <div class="d-flex flex-row flex-justify-start flex-align-start w-100"
        style="height: 60%;">
        <div id="mui_filelist"
            class="d-flex flex-column flex-justify-start flex-align-start h-100">
            <div id="mui_filelist_toolbar"
                class="d-flex flex-row flex-justify-between flex-align-center w-100">
                <div class="d-flex flex-row flex-justify-start flex-align-center mr-1">
                    <button class="btn-xs mr-1 dropdown-toggle">
                        {{ get_sort_by_label(this.sort_anns_by) }}
                    </button>
                    <ul class="ribbon-dropdown text-left" 
                        data-role="dropdown" 
                        data-duration="100">
                        <li title="Sort the file list by the file name A-Z"
                            v-on:click="sort_filelist_by('alphabet')">
                            <a href="javascript:void(0);">By file name (A->Z)</a>
                        </li>
                        <li title="Sort the file list by the file name Z-A"
                            v-on:click="sort_filelist_by('alphabet_r')">
                            <a href="javascript:void(0);">By file name (Z->A)</a>
                        </li>

                        <li title="Sort the file list by the number of annotated tags"
                            v-on:click="sort_filelist_by('tags')">
                            <a href="javascript:void(0);">By number of tags (0->N)</a>
                        </li>

                        <li title="Sort the file list by the number of annotated tags"
                            v-on:click="sort_filelist_by('tags_r')">
                            <a href="javascript:void(0);">By number of tags (N->0)</a>
                        </li>

                        <li title="Sort the file list by the color of labels"
                            v-on:click="sort_filelist_by('label')">
                            <a href="javascript:void(0);">By label color (Green first)</a>
                        </li>

                        <li title="Sort the file list by the color of labels"
                            v-on:click="sort_filelist_by('label_r')">
                            <a href="javascript:void(0);">By label color (Non-color first)</a>
                        </li>

                        <li class="divider"></li>

                        <li title="Sort the file list by the number of annotated tags"
                            v-on:click="sort_filelist_by('default')">
                            <a href="javascript:void(0);">By default import sequence</a>
                        </li>
                    </ul>

                    <span class="mr-1"
                        title="Filter the files by file name">
                        Filter: 
                    </span>
                    <input type="text" 
                        class="ipt-xs mr-1"
                        style="width: 55px;"
                        v-model="fn_pattern">
                    <span v-on:click="clear_filter_box"
                        class="box-clear-times"
                        title="Clear the filter input box">
                        <i class="fa fa-times"></i>
                    </span>
                
                    <span v-if="anns.length > 0">
                        {{ virtual_anns.v_anns.length }} 
                        <span class="txt-sm">files</span>
                    </span>
                </div>

                <div class="d-flex flex-row flex-justify-start flex-align-center mr-1">
                    <button class="btn-xs"
                        title="Remove all files"
                        v-on:click="remove_all_ann_files">
                        <i class="far fa-trash-alt"></i>
                        All
                    </button>
                </div>
            </div>

            <div v-if="is_loading_anns"
                id="mui_filelist_list" 
                v-on:dragover="on_dragover_prevent_default"
                v-on:drop="on_drop_filelist"
                class="d-flex text-center flex-align-center flex-justify-center w-100 h-100">
                <p>
                    <b>
                        <i v-if="is_loaded_anns" class="fas fa-hand-sparkles"></i>
                        <i v-else class="fas fa-spinner fa-spin"></i>
                        {{ msg_loading_anns }}
                    </b>
                    <br>
                    <span v-if="n_anns_droped != 0">
                        Loaded: <b>{{ n_anns_loaded }}</b> files
                    </span>
                    <br>
                    <span v-if="is_loaded_anns">
                        <button class="mt-1"
                            title="Close the statistics of loading and show all annotation files"
                            v-on:click="reset_loading_anns_status">
                            Show All <br>
                            Annotation Files
                        </button>
                    </span>
                </p>
            </div>
            <div v-else-if="virtual_anns.v_anns.length > 0"
                id="mui_filelist_list" 
                v-on:dragover="on_dragover_prevent_default"
                v-on:drop="on_drop_filelist"
                class="d-flex flex-column flex-justify-start flex-align-start w-100 h-100">
                <ul class="w-100 file-list">
                    <li v-for="v_ann in virtual_anns.v_anns_paged"
                        class="file-list-item"
                        v-bind:class="v_ann.css_class">
                        <div class="d-flex flex-row flex-justify-between">
                            <div class="file-list-item-name"
                                style="flex-grow: 1;"
                                v-on:click="set_ann_idx_by_ann(v_ann)"
                                v-bind:title="v_ann._filename"
                                v-bind:class="{'file-list-item-name-unsaved':!anns[v_ann.idx]._has_saved}">

                                <a href="javascript:void(0);"
                                    v-if="!anns[v_ann.idx]._has_saved" 
                                    v-on:click="save_xml_by_ann(v_ann)"
                                    title="Save this annotation file"
                                    class="icon-fg-unsaved mr-1">
                                    <i class="fa fa-save"></i>
                                </a>
                                <span v-if="has_any_label(anns[v_ann.idx])">
                                    <span v-for="ann_label in anns[v_ann.idx].meta.label"
                                        :class="'label-' + ann_label.color">
                                        <i class="fas fa-bookmark"></i>
                                    </span>
                                </span>
                                <span>
                                    {{ v_ann._filename }}
                                </span>
                            </div>

                            <div class="d-flex flex-row">
                                <div class="mr-2"
                                    v-bind:title="'Annotated ' + anns[v_ann.idx].tags.length + ' tags'">
                                    {{ anns[v_ann.idx].tags.length }}
                                </div>

                                <div title="Remove this annotation file">
                                    <a v-on:click="remove_ann_file_by_ann(v_ann)"
                                        class="btn btn-red btn-xs"
                                        href="javascript:void(0);">
                                        <i class="fa fa-minus-circle"></i>
                                    </a>
                                </div>
                            </div>
                        </div>
                    </li>
                </ul>

                <div id="mui_filelist_pager"
                    class="d-flex flex-row w-100 flex-justify-between"
                    v-if="get_n_pages_by_total(virtual_anns.v_anns.length) > 1">

                    <div style="margin: 0 auto;">
                        <button class="btn-xs mr-1"
                            title="Go to previous page"
                            v-bind:disabled="pg_index == 0"
                            v-on:click="goto_anns_page(pg_index - 1)">
                            <i class="fas fa-arrow-left"></i>
                        </button>

                        <select v-model="pg_index"
                            title="Select which page of annotation files to show"
                            class="select-xs page-current-index">
                            <option v-for="pg in get_pages_by_total(virtual_anns.v_anns.length)"
                                v-bind:value="pg">
                                {{ pg + 1 }}
                            </option>
                        </select>
                        <span class="mr-2 page-total-number"
                            v-bind:title="'Each page contains ' + pg_numpp + ' files'">
                            /
                            {{ get_n_pages_by_total(virtual_anns.v_anns.length) }} Pages
                        </span>

                        <button class="btn-xs"
                            title="Go to next page"
                            v-bind:disabled="pg_index == (get_n_pages_by_total(virtual_anns.v_anns.length) - 1)"
                            v-on:click="goto_anns_page(pg_index + 1)">
                            <i class="fas fa-arrow-right"></i>
                        </button>
                    </div>
                </div>
            </div>
            <div v-else 
                id="mui_filelist_list"
                v-on:dragover="on_dragover_prevent_default"
                v-on:drop="on_drop_filelist"
                class="d-flex text-center flex-align-center flex-justify-center w-100">
                
                    
                <p v-if="dtd == null"
                    class="clr-grey">
                    <i class="far fa-file-code"></i>
                    Load schema file first
                    <br>
                    Drop a .yaml or .dtd File Here
                </p>
                <p v-else
                    title="Drop the file(s) for annotation (.xml or .txt) or folder(s) containing annotation files"
                    class="txt-hover-bold">
                    Drop <b>Annotation</b> File(s) / Folder Here
                    <br>
                    (.xml)
                </p>
               
            </div>
        </div>

        <div class="h-100 h-splitter">
        </div>

        <div id="mui_texteditor">
            <div id="cm_editor" class="w-100">
                
            </div>
        </div>
        
    </div>
    <div class="v-splitter"></div>
    <div class="d-flex flex-row flex-justify-start flex-align-start w-100"
        style="height: 40%;">
        <div id="mui_dtdlist" 
            class="d-flex h-100">
            <ul v-if="dtd != null"
                class="w-100 tag-list">

                <li v-on:click="update_tag_table()"
                    class="tag-list-row tag-list-row-all-tags d-flex flex-row flex-justify-between"
                    v-bind:class="{'tag-list-row-actived':display_tag_name == '__all__'}">
                    <div class="tag-list-row-name">
                        <span class='mif-folder fg-red'></span>
                        All Tags
                    </div>
                    <div class="mr-1">
                        {{ count_n_tags(null) }}
                    </div>
                </li>

                <!-- show all etags -->
                <li v-for="etag in dtd.etags"
                    class="tag-list-row d-flex flex-row flex-justify-between"
                    v-bind:class="{'tag-list-row-actived':display_tag_name == etag.name}">
                    <div class="tag-list-row-name"
                        v-on:click="update_tag_table(etag)">
                        <i class="fa fa-tag"
                            v-bind:class="'fg-tag-' + etag.name">
                        </i>
                        <span v-if="etag.hasOwnProperty('shortcut')"
                            class="badge-shortcut mr-1">
                            {{ etag.shortcut }}
                        </span>
                        <span v-html="make_html_bold_tag_name(etag)">
                            
                        </span>
                    </div>
                    <div class="mr-1 d-flex flex-row">
                        <div v-if="ann_idx != null && etag.is_non_consuming"
                            class="mr-2">
                            <button class="btn-xs"
                                title="Add an empty entity tag"
                                v-on:click="add_empty_etag(etag)">
                                <i class="fa fa-plus"></i>
                            </button>
                        </div>
                        <div v-bind:class="'tag-list-row-count-'+count_n_tags(etag)">
                            {{ count_n_tags(etag) }}
                        </div>
                    </div>
                </li>

                <!-- show all link tags -->
                <li v-for="rtag in dtd.rtags"
                    class="tag-list-row d-flex flex-row flex-justify-between"
                    v-bind:class="{'tag-list-row-actived':display_tag_name == rtag.name}">
                    <div class="tag-list-row-name"
                        v-on:click="update_tag_table(rtag)">
                        <i class="fa fa-link"
                            v-bind:class="'fg-tag-' + rtag.name">
                        </i>
                        <span v-if="rtag.hasOwnProperty('shortcut') && rtag.shortcut != null"
                            class="badge-shortcut mr-1">
                            {{ rtag.shortcut }}
                        </span>
                        <span v-html="make_html_bold_tag_name(rtag)">
                        </span>
                    </div>
                    <div class="mr-1 d-flex flex-row">
                        <div v-if="ann_idx != null"
                            class="mr-2">
                            <button class="btn-xs"
                                title="Add an empty link tag"
                                v-on:click="add_empty_rtag(rtag)">
                                <i class="fa fa-plus"></i>
                            </button>
                        </div>
                        <div v-bind:class="'tag-list-row-count-'+count_n_tags(rtag)">
                            {{ count_n_tags(rtag) }}
                        </div>
                    </div>

                </li>

            </ul>
        </div>

        <div class="h-100 h-splitter">
        </div>

        <div id="mui_annlist" 
            class="d-flex flex-justify-start flex-align-start h-100">
            <table v-if="dtd!=null && ann_idx != null" class="tag-table w-100 mt-0 mb-0">
                <thead>
                    <tr>
                        <th class="tag-name">Tag</th>
                        <th class="tag-id">ID</th>
                        <th class="tag-spans">Spans</th>
                        <th class="tag-text">Text</th>
                        <th class="tag-attr">Attributes</th>
                    </tr>
                </thead>

                <tbody style="overflow-y: auto;">
                    <tr v-for="tag, tag_idx in anns[ann_idx].tags"
                        v-if="tag.tag == display_tag_name || display_tag_name == '__all__'"
                        v-bind:id="'tag-table-row-' + tag.id"
                        class="tag-table-row">
                        <td v-on:click="on_click_tag_table_row(tag)">
                            <div class="d-flex flex-row flex-justify-between">
                                <div>
                                    <i v-if="get_tag_def(tag.tag).type == 'etag'" 
                                        class="fa fa-tag"
                                        v-bind:class="'fg-tag-' + tag.tag">
                                    </i>
                                    <i v-else class="fa fa-link"
                                        class="fa fa-tag"
                                        v-bind:class="'fg-tag-' + tag.tag">
                                    </i>
                                    {{ tag.tag }}
                                </div>

                                <div class="mr-2">
                                    <button class="btn btn-xs btn-red"
                                        title="Delete this tag"
                                        v-on:click="delete_tag(tag.id)">
                                        <i class="fa fa-trash"></i>
                                    </button>
                                </div>
                            </div>
                        </td>

                        <td class="c-pointer"
                            v-on:click="on_click_tag_table_row(tag)">
                            <span>
                                {{ tag.id }}
                            </span>
                        </td>

                        <td v-bind:class="{'c-pointer': !is_etag_doc_level(tag)}"
                            v-on:click="on_click_tag_table_row(tag)">
                            <span v-if="tag.hasOwnProperty('_annotator')"
                                v-bind:class="'iaa-annotator-' + tag._annotator"
                                class="mr-2">
                                <i v-if="tag._annotator == 'AB'" class="fa fa-user-check"></i>
                                <i v-else class="fa fa-user-edit"></i>
                                {{ tag._annotator }}
                            </span>
                            <!-- <span v-else
                                class="mr-2">
                                &nbsp;
                            </span> -->
                                    
                            <span v-if="is_etag_doc_level(tag)">
                                DOCUMENT
                            </span>
                            <span v-else-if="is_etag(tag)"
                                class="c-pointer">
                                {{ tag.spans }}
                            </span>
                            <span v-else
                                class="c-pointer">
                                LINK
                            </span>

                            <span v-if="tag.hasOwnProperty('_annotator')"
                                class="box-annotator-actions">
                                <!-- this is a adjudication tag -->
                                <br>
                                <button class="btn btn-xs btn-green"
                                    title="Set this tag as both agreed"
                                    v-if="tag._annotator != 'AB'"
                                    v-on:click="set_tag_annotator(tag.id, 'AB')">
                                    <i class="far fa-handshake"></i>
                                    Both A and B
                                </button>
                                

                                <button class="btn btn-xs btn-orange"
                                    title="Set annotator to A"
                                    v-if="tag._annotator == 'AB'"
                                    v-on:click="set_tag_annotator(tag.id, 'A')">
                                    <i class="fas fa-user-edit"></i>
                                    Only A
                                </button>

                                <button class="btn btn-xs btn-blue"
                                    title="Set annotator to B"
                                    v-if="tag._annotator == 'AB'"
                                    v-on:click="set_tag_annotator(tag.id, 'B')">
                                    <i class="fas fa-user-edit"></i>
                                    Only B
                                </button>
                            </span>
                        </td>

                        <td class="td-text c-pointer"
                            v-on:click="on_click_tag_table_row(tag)">
                            <span v-if="is_etag(tag)">
                                {{ tag.text }}
                            </span>
                            <span v-else>
                            </span>
                        </td>

                        <td class="d-flex flex-row flex-justify-start flex-align-start flex-wrap">
                            <div v-for="(attr, attr_idx) in dtd.tag_dict[tag.tag].attrs"
                                v-if="!['id','spans','text','tag'].contains(attr.name)"
                                class="tag-attr-box mr-1 d-flex flex-column">
                                <div class="tag-attr-name">
                                    {{ attr.name }}
                                    <span v-if="attr.require == 'REQUIRED'"
                                        class="clr-red">
                                        *
                                    </span>
                                    <span v-else>
                                        &nbsp;
                                    </span>
                                </div>
                                
                                <div v-if="attr.vtype == 'list'">
                                    <select class="tag-attr-select"
                                        v-bind:id="'form-'+ann_idx+'-' + anns[ann_idx].tags[tag_idx].id + '-' + attr.name"
                                        v-model="anns[ann_idx].tags[tag_idx][attr.name]"
                                        @change="on_change_attr_value">
                                        <option v-for="val in attr.values"
                                            v-bind:value="val">
                                            {{ val }}
                                        </option>
                                        <option value="">-- EMPTY --</option>
                                    </select>
                                </div>
                                <div v-else-if="attr.vtype == 'text'">
                                    <input type="text"
                                        class="tag-attr-input"
                                        v-bind:id="'form-'+ann_idx+'-' + anns[ann_idx].tags[tag_idx].id + '-' + attr.name"
                                        v-model="anns[ann_idx].tags[tag_idx][attr.name]"
                                        @input="on_input_attr_value">
                                </div>
                                <div v-else-if="attr.vtype == 'idref'">
                                    <select class="tag-attr-select"
                                        v-bind:id="'form-'+ann_idx+'-' + anns[ann_idx].tags[tag_idx].id + '-' + attr.name" 
                                        v-model="anns[ann_idx].tags[tag_idx][attr.name]"
                                        @change="on_change_idref_value">
                                        <option v-for="s_etag, s_etag_idx in get_tags_by_type(anns[ann_idx], dtd, 'etag')"
                                            v-bind:value="s_etag.id">
                                            {{ s_etag.id }}
                                            |
                                            {{ s_etag.tag }}
                                            -
                                            {{ s_etag.text }}
                                        </option>
                                        <option value="">-- EMPTY --</option>
                                    </select>
                                </div>
                                <div v-else>
                                    <input type="text"
                                        class="tag-attr-input"
                                        v-bind:id="'form-'+ann_idx+'-' + anns[ann_idx].tags[tag_idx].id + '-' + attr.name" 
                                        v-model="anns[ann_idx].tags[tag_idx][attr.name]"
                                        @input="on_input_attr_value">
                                </div>
                            </div>
                            
                            
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>

    <div v-if="is_linking"
        ref="pan_working_tag_box"
        id="pan_working_tag"
        class="d-flex flex-column">
        <div class="p-2 mb-1"
            id="pan_working_tag_title"
            @mousedown="dragMouseDown">
            Creating a Link Tag
            <b>{{ linking_tag.tag }}</b>
        </div>
        <div class="d-flex flex-row p-1 border-bottom">
            <button class="btn-xs mr-1"
                title="Using the following values to create a link tag"
                v-on:click="done_linking();">
                <i class="fa fa-check-circle"></i>
                Done Linking
            </button>
            <button class="btn-xs"
                title="Stop creating a link tag and drop the following values"
                v-on:click="cancel_linking();">
                <i class="far fa-times-circle"></i>
                Cancel Linking
            </button>
        </div>
        <div class="d-flex flex-column p-1 pr-2">
            <div v-for="attr in linking_tag_def.attrs"
                class="d-flex flex-row rtag-attr-row p-1 mb-1">
                <div class="d-flex rtag-attr-name pr-1">
                    &nbsp;- 
                    {{ attr.name }}
                </div>
                <div class="d-flex rtag-attr-value">
                    <div v-if="attr.vtype == 'idref'"
                        class="w-100">
                        <select class="tag-attr-select"
                            v-model="linking_tag[attr.name]">
                            <option v-for="s_etag, s_etag_idx in get_tags_by_type(anns[ann_idx], dtd, 'etag')"
                                v-bind:value="s_etag.id">
                                {{ s_etag.id }}
                                |
                                {{ s_etag.tag }}
                                -
                                {{ s_etag.text }}
                            </option>
                            <option value="">-- EMPTY --</option>
                        </select>
                    </div>
                    <div v-else-if="attr.vtype == 'text'"
                        class="w-100">
                        <input type="text"
                            class="tag-attr-input"
                            v-model="linking_tag[attr.name]">
                    </div>
                    <div v-else-if="attr.vtype == 'list'"
                        class="w-100">
                        <select class="tag-attr-select"
                            v-model="linking_tag[attr.name]">
                            <option v-for="val in attr.values"
                                v-bind:value="val">
                                {{ val }}
                            </option>
                            <option value="">-- EMPTY --</option>
                        </select>
                    </div>
                    <div v-else
                        class="w-100">
                        <input type="text"
                            class="tag-attr-input"
                            v-model="linking_tag[attr.name]">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

    <!-- the ui for corpus -->
    <div v-if="section=='corpus'" id="main_ui" 
    class="main-ui container-fluid">
    
    <div class="w-100 d-flex flex-row" 
        style="height: calc(100% + 10px);">

        <div>
            <div class="box-header">
                <h4>
                    <i class="fa fa-file"></i>
                    Annotation Schema
                </h4>
            </div>

            <div class="box-body mr-2" 
                style="overflow-y: auto; height: 100%;">
                <p>
                    You need to prepare the annotation schema. 
                </p>
                <div class="converter-dropzone">
                    <p v-if="dtd == null">
                        Annotation schema is needed to parse and format the given input files to XML files. <br>
                        Please load the annotation schema file first in <br>
                        the 
                        <b class="cursor-pointer"
                            v-on:click="switch_mui('annotation')">
                            <i class="fa fa-highlighter"></i> Annotation Tab
                        </b>
                    </p>
                    <p v-else>
                        <i>Schema:</i>
                        <b>{{ dtd.name }}</b><br>
                        - <b>{{ dtd.etags.length }}</b> Entity Tags<br>
                        <span style="padding: 5px;">
                            <span v-for="tag in dtd.etags"
                                v-bind:class="'mark-tag-'+tag.name"
                                style="padding: 0 2px; margin-right: 3px;">
                                {{ tag.name }}
                            </span>
                        </span>

                        <br>
                        - <b>{{ dtd.rtags.length }}</b> Link Tags
                        <span style="padding: 5px;">
                            <span v-for="tag in dtd.rtags"
                                v-bind:class="'mark-tag-'+tag.name"
                                style="padding: 0 2px; margin-right: 3px;">
                                {{ tag.name }}
                            </span>
                        </span>
                    </p>
                </div>
            </div>

        </div>

        <div v-if="converter_corpus_task == 'raw'">
            <div class="box-header">
                <h4>
                    <i class="fa fa-list-ul"></i>
                    Raw Text Files
                </h4>
            </div>

            <div class="box-body" 
                style="overflow-y: auto; height: 100%;">
                <p>
                    You need to prepare the .txt files. 
                </p>

                <div class="d-flex flex-row">

                    <div id="mui_converter_raw_txt_filelist"
                        v-on:dragover="on_dragover_prevent_default"
                        v-on:drop="on_drop_converter_raw_txt"
                        class="converter-dropzone mr-2">
                        <h5>
                            <i class="far fa-file-alt"></i>
                            Raw .txt Text Files
                        </h5>
                        <p v-if="is_converter_loading_raw_txt_files">
                            Loading files ... <br>
                            Please wait for a little while. <br>
                            <i class="fas fa-spinner fa-spin"></i>
                        </p>
                        <p v-else-if="n_converter_corpus_raw_txt_files == 0">
                            Drag and drop the <b>.txt</b> files or the folder contains <b>.txt</b> files in this box.
                        </p>
                        <p v-else>
                            Loaded <b>{{ n_converter_corpus_raw_txt_files }} </b> text files (.txt).
                            <span v-if="n_converter_corpus_raw_txt_files > max_converter_display_files">
                                As too many files are loaded, only show the first {{ max_converter_display_files }}.
                            </span>
                        </p>

                        <div v-if="!is_converter_loading_raw_txt_files && converter_corpus_raw_txt_files.length > 0"
                            class="d-flex flex-column converter-file-list">
                            <div v-for="f in converter_corpus_raw_txt_files"
                                class="converter-file-row">
                                <a v-on:click="qv_converter_txt($event, f)"
                                    v-bind:title="f.fn"
                                    href="javascript:void(0);">
                                    {{ f.fn }}
                                </a>
                            </div>
                        </div>
                    </div>

                </div>

            </div>

        </div>
        <!-- /div for raw -->




        <div v-if="converter_corpus_task == 'medtagger'">
            <div class="box-header">
                <h4>
                    <i class="fa fa-list-ul"></i>
                    MedTagger Files
                </h4>
            </div>

            <div class="box-body" 
                style="overflow-y: auto;">
                <p>
                    You need to prepare matched .txt and .ann files.
                </p>

                <div class="d-flex flex-row">

                    <div id="mui_converter_medtagger_txt_filelist"
                        v-on:dragover="on_dragover_prevent_default"
                        v-on:drop="on_drop_converter_medtagger_txt"
                        class="converter-dropzone mr-2">
                        <h5>
                            <i class="far fa-file-alt"></i>
                            Raw .txt Text Files
                        </h5>
                        <p v-if="is_converter_loading_medtagger_txt_files">
                            Loading files ... <br>
                            Please wait for a little while. <br>
                            <i class="fas fa-spinner fa-spin"></i>
                        </p>
                        <p v-else-if="converter_corpus_medtagger_txt_files.length == 0">
                            Drag and drop the <b>.txt</b> files or the folder contains <b>.txt</b> files in this box
                        </p>
                        <p v-else>
                            Loaded <b>{{ n_converter_corpus_medtagger_txt_files }} </b> text files (.txt).
                            <span v-if="n_converter_corpus_medtagger_txt_files > max_converter_display_files">
                                As too many files are loaded, only show the first {{ max_converter_display_files }}.
                            </span>
                        </p>

                        <div v-if="!is_converter_loading_medtagger_txt_files && converter_corpus_medtagger_txt_files.length > 0"
                            class="d-flex flex-column converter-file-list">

                            <div v-for="f in converter_corpus_medtagger_txt_files"
                                class="converter-file-row">

                                <a v-on:click="qv_converter_txt($event, f)"
                                    v-bind:title="f.fn"
                                    href="javascript:void(0);">
                                    {{ f.fn }}
                                </a>

                            </div>
                        </div>
                    </div>


                    <div id="mui_converter_medtagger_ann_filelist"
                        v-on:dragover="on_dragover_prevent_default"
                        v-on:drop="on_drop_converter_medtagger_ann"
                        class="converter-dropzone mr-2">
                        <h5>
                            <i class="far fa-file-code"></i>
                            MedTagger .ann Files
                        </h5>
                        <p v-if="is_converter_loading_medtagger_ann_files">
                            Loading files ... <br>
                            Please wait for a little while. <br>
                            <i class="fas fa-spinner fa-spin"></i>
                        </p>
                        <p v-else-if="converter_corpus_medtagger_ann_files.length == 0">
                            Drag and drop the <b>.ann</b> files or the folder contains <b>.ann</b> files in this box.
                        </p>
                        <p v-else>
                            Loaded <b>{{ n_converter_corpus_medtagger_ann_files }} </b> MedTagger files (.ann).
                            <span v-if="n_converter_corpus_medtagger_ann_files > max_converter_display_files">
                                As too many files are loaded, only show the first {{ max_converter_display_files }}.
                            </span>
                        </p>

                        <div v-if="!is_converter_loading_medtagger_ann_files && converter_corpus_medtagger_ann_files.length != 0"
                            class="d-flex flex-column converter-file-list">
                            <div v-for="f in converter_corpus_medtagger_ann_files"
                                class="converter-file-row">
                                <span class="bg-blue fg-white mr-1 pl-1 pr-1"
                                    :title="f.lines.length + ' lines of records'">
                                    {{ f.lines.length }}
                                </span>
                                <a v-on:click="qv_converter_txt($event, f)"
                                    v-bind:title="f.fn"
                                    href="javascript:void(0);">
                                    {{ f.fn }}
                                </a>
                            </div>
                        </div>
                    </div>
                    

                </div>
            </div>
        </div>
        <!-- /div for medtagger -->




        <div class="converter-result-box">

            <div class="box-header">
                <h4>
                    <i class="far fa-file-code"></i>
                    Conversion Results
                </h4>
            </div>


            <div class="box-body" 
                style="overflow-y: auto; height: 100%;">
                <p>
                    Click "
                    <i class="fas fa-mortar-pestle"></i>
                    Convert Files
                    "
                    to start conversion.
                </p>

                <div class="converter-dropzone mr-2 bd-green">
                    <h5 class="fg-green"> 
                        <i class="far fa-file-code"></i>
                        Generated MedTator XML Files
                    </h5>
                    
                    <p>
                        Converted <b>{{ n_converter_results }} </b> xml files.
                        <span v-if="n_converter_results > max_converter_display_files">
                            As too many files are converted, only show the first {{ max_converter_display_files }}.
                        </span>
                    </p>
        
                    <div v-if="converter_results.length > 0"
                        class="d-flex flex-column converter-file-list">

                        <div v-for="ann in converter_results"
                            class="converter-file-row">
                            <span class="mr-1 cursor-pointer converter-result-download"
                                title="Download this file seperately"
                                v-on:click="download_converted_result(ann)">
                                <i class="fas fa-cloud-download-alt"></i>
                            </span>

                            <span class="bg-green fg-white mr-1 pl-1 pr-1"
                                :title="'Converted ' + ann.tags.length + ' tags'">
                                {{ ann.tags.length }}
                            </span>
                            
                            <a v-on:click="qv_converter_result_ann($event, ann)"
                                v-bind:title="ann._filename"
                                href="javascript:void(0);">
                                {{ ann._filename }} 
                            </a>
                        </div>
                    </div>


                </div>
            </div>
        </div>
        <!-- /div for results -->
        
    </div>
    
</div>

    <!-- the ui for ruleset / export -->
    <div v-show="section=='ruleset'" id="main_ui"
    class="main-ui container-fluid">
    <div class="w-100 d-flex flex-row" style="height: calc(100% + 10px);">
        <div id="mui_ruleset_result" class="d-flex w-100 h-100">
            <div class="box w-100 h-100">
                <div class="box-header">
                    <h4>
                        <i class="far fa-file-alt"></i>
                        Export Preview
                    </h4>
                </div>

                <div v-if="export_text != null"
                    class="box-body h-100">

                    <textarea v-model="export_text" 
                        class="w-100 h-100" 
                        style="font-family: 'Courier New', Courier, monospace;"></textarea>
                    
                </div>
            </div>
            <!-- /.box -->
        </div>
    </div>
</div>

    <!-- the ui for iaa -->
    <div v-if="section=='iaa'" id="main_ui" 
    class="main-ui container-fluid">

    <ul id="iaa_display_tab"
        v-if="dtd != null && iaa_dict != null"
        data-role="tabs" 
        data-expand="true">
        <li v-on:click="iaa_display_measure = 'f1'"
            :class="{active: iaa_display_measure == 'f1'}">
            <a href="javascript:void(0);">
                <i class="fas fa-calculator mr-1"></i>
                F1 Score
            </a>
        </li>
        <li v-if="cfg.new_ui_for_ck == 'enable'"
            v-on:click="iaa_display_measure = 'cohen_kappa'"
            :class="{active: iaa_display_measure == 'cohen_kappa'}">
            <a href="javascript:void(0);">
                <i class="fas fa-bezier-curve mr-1"></i>
                Cohen's Kappa
            </a>
        </li>
    </ul>



    <div v-if="iaa_display_measure == 'f1'"
        class="w-100 d-flex flex-row" style="height: calc(100% - 30px);">

        <div id="mui_iaa_summary" class="d-flex h-100 mr-1">
    <div v-if="dtd != null && iaa_dict != null" class="box h-100">
        <!-- <div class="box-header">
            <h4>
                <i class="fa fa-list-ul"></i>
                F1 Score Results
            </h4>
        </div> -->
        <div class="box-body">

            <div>
                <div class="iaa-row iaa-row-header d-flex flex-row">
                    <div class="iaa-bar-name-box d-flex flex-row flex-align-center flex-justify-start mr-1">
                        Tag Name
                    </div>
                    <div class="iaa-bar-box d-flex flex-row flex-align-center flex-justify-start">
                        F1
                    </div>
                </div>

                <!-- special for the overall result -->
                <div class="iaa-row d-flex flex-row"
                    v-bind:class="{'iaa-row-actived': iaa_display_tag_name == '__all__'}"
                    v-on:click="iaa_display_tag_name = '__all__'">
                    <div class="iaa-bar-name-box d-flex flex-row flex-align-center flex-justify-start mr-1">
                        OVERALL
                    </div>
                    <div class="iaa-bar-box d-flex flex-row flex-align-center flex-justify-start">
                        <div v-bind:style="'width:' + per2width(iaa_dict.all.f1) + 'px'"
                            class="iaa-bar">
                            &nbsp;
                        </div>
                        <div class="ml-1">
                            <span style="font-size: 1.2em; font-weight: bold;">
                                {{ to_fixed(iaa_dict.all.f1) }}
                            </span>
                        </div>
                    </div>
                </div>

                <!-- for each tag -->
                <div v-for="etag in dtd.etags"
                    class="iaa-row d-flex flex-row"
                    v-bind:class="{'iaa-row-actived': iaa_display_tag_name == etag.name}"
                    v-on:click="iaa_display_tag_name = etag.name">
                    <div v-bind:title="etag.name" 
                        class="iaa-bar-name-box d-flex flex-row flex-align-center flex-justify-start mr-1">
                        <i class="fa fa-tag mr-1"
                            v-bind:class="'fg-tag-' + etag.name">
                        </i>
                        <span>
                            {{ etag.name }}
                        </span>
                    </div>
                    <div class="iaa-bar-box d-flex flex-row flex-align-center flex-justify-start mr-1">
                        <div v-bind:style="'width:' + per2width(iaa_dict.tag[etag.name].f1) + 'px'"
                            class="iaa-bar">
                            &nbsp;
                        </div>
                        <div class="ml-1">
                            {{ to_fixed(iaa_dict.tag[etag.name].f1) }}
                        </div>
                    </div>
                </div>
            </div>

            <div class="mt-3">
                <p>
                    Text Matched Files: <b>{{ iaa_dict.stat.matched_hashcodes.length }}</b>
                </p>
                <p>
                    Duplicated Files: <b>{{ iaa_dict.stat.duplicates.length }}</b>
                </p>
                <p>
                    Unmatched Files: <b>{{ iaa_dict.stat.unmatched.length }}</b>
                </p>
            </div>
        </div>
    </div>
</div>

<div id="mui_iaa_anns" class="d-flex h-100 ml-1 mr-1">
    <div v-if="dtd != null && iaa_dict != null" class="box w-100 h-100">
        <div class="box-header">

            <div>
                <button class="btn-xs mr-1 dropdown-toggle"
                    style="margin-left: 0;">
                    {{ iaa_get_sort_by_label(iaa_get_sort_by()) }}
                </button>
                <ul class="ribbon-dropdown text-left" 
                    data-role="dropdown" 
                    data-duration="100">
                    <li title="Sort the file list by the A's file name A-Z"
                        v-on:click="iaa_sort_filelist_by('a.alphabet')">
                        <a href="javascript:void(0);">By A's file name (A->Z)</a>
                    </li>
                    <li title="Sort the file list by the A's file name Z-A"
                        v-on:click="iaa_sort_filelist_by('a.alphabet_r')">
                        <a href="javascript:void(0);">By A's file name (Z->A)</a>
                    </li>

                    <li title="Sort the file list by the B's file name A-Z"
                        v-on:click="iaa_sort_filelist_by('b.alphabet')">
                        <a href="javascript:void(0);">By B's file name (A->Z)</a>
                    </li>
                    <li title="Sort the file list by the B's file name Z-A"
                        v-on:click="iaa_sort_filelist_by('b.alphabet_r')">
                        <a href="javascript:void(0);">By B's file name (Z->A)</a>
                    </li>

                    <li title="Sort the file list by F1 Score 0-1"
                        v-on:click="iaa_sort_filelist_by('f1_asc')">
                        <a href="javascript:void(0);">By F1 Score (0->1)</a>
                    </li>
                    <li title="Sort the file list by F1 Score 1-0"
                        v-on:click="iaa_sort_filelist_by('f1_desc')">
                        <a href="javascript:void(0);">By F1 Score (1->0)</a>
                    </li>

                    <li class="divider"></li>

                    <li title="Sort the file list by the number of annotated tags"
                        v-on:click="iaa_sort_filelist_by('default')">
                        <a href="javascript:void(0);">By default import sequence</a>
                    </li>
                </ul>
            </div>
            <h4>
                <i class="fa fa-list"></i>
                Annotation Files
            </h4>
        </div>

        <div class="box-body">

            <div class="iaa-row iaa-row-header d-flex flex-row">
                <div class="iaa-bar-filename-box d-flex flex-row flex-align-center flex-justify-start mr-1">
                    File names
                </div>
                <div class="iaa-bar-box d-flex flex-row flex-align-center flex-justify-start">
                    <span v-if="iaa_display_tag_name == '__all__'">
                        OVERALL
                    </span>
                    <span v-else>
                        <i class="fa fa-tag mr-1"
                            v-bind:class="'fg-tag-' + iaa_display_tag_name">
                        </i>
                        <span>
                            {{ iaa_display_tag_name }}
                        </span>
                    </span>
                    &nbsp;
                    <span>
                        F1
                    </span>
                </div>
            </div>

            <div v-for="v_ann in iaa_sort_v_anns(iaa_dict)"
                class="iaa-row d-flex flex-row"
                v-bind:class="{'iaa-row-actived': iaa_display_hashcode == v_ann.ann_hashcode}"
                v-on:click="iaa_display_hashcode = v_ann.ann_hashcode">
                <div class="iaa-bar-filename-box d-flex flex-column flex-align-center flex-justify-start mr-1">
                    <div class="iaa-bar-filename w-100">
                        A: {{ iaa_dict.ann[v_ann.ann_hashcode].anns[0]._filename }}
                    </div>
                    <div class="iaa-bar-filename w-100">
                        B: {{ iaa_dict.ann[v_ann.ann_hashcode].anns[1]._filename }}
                    </div>
                    <div class="iaa-bar-filename w-100">
                        <!-- <span title="Set check"
                            v-on:click="iaa_gs_dict[v_ann.ann_hashcode].ann._has_star = !iaa_gs_dict[v_ann.ann_hashcode].ann._has_star">
                            <span v-if="iaa_gs_dict[v_ann.ann_hashcode].ann._has_star">
                                <i class="fa fa-check-circle fg-emerald"></i>
                            </span>
                            <span v-else>
                                <i class="far fa-circle"></i>
                            </span>
                        </span> -->
                        <a href="javascript:void(0);"
                            v-on:click="download_gs_file(v_ann.ann_hashcode)"
                            v-bind:title="'Download adjudicated file ' + iaa_gs_dict[v_ann.ann_hashcode].ann._filename"
                            class="btn btn-xs btn-dense btn-black">
                            <i class="far fa-arrow-alt-circle-down"></i>
                        </a>
                        
                        GS: {{ iaa_gs_dict[v_ann.ann_hashcode].ann._filename }}
                    </div>
                </div>

                <div class="d-flex flex-column">
                    <div class="iaa-bar-box d-flex flex-row flex-align-center flex-justify-start mr-1">
                        <div v-bind:style="'width:' + per2width(get_rst(iaa_dict.ann[v_ann.ann_hashcode].rst)['f1']) + 'px'"
                            class="iaa-bar">
                            &nbsp;
                        </div>
                        <div class="iaa-bar-value ml-1">
                            {{ to_fixed(get_rst(iaa_dict.ann[v_ann.ann_hashcode].rst)['f1']) }}
                        </div>
                    </div>
                    <div class="iaa-file-cm-box">
                        <span class="mr-2">
                            <span class="iaa-op-50">AB: </span>
                            {{ get_rst(iaa_dict.ann[v_ann.ann_hashcode].rst).cm.tp }}
                        </span>
                        <span class="mr-2">
                            <span class="iaa-op-50">A+: </span>
                            {{ get_rst(iaa_dict.ann[v_ann.ann_hashcode].rst).cm.fp }}
                        </span>
                        <span class="mr-2">
                            <span class="iaa-op-50">B+: </span>
                            {{ get_rst(iaa_dict.ann[v_ann.ann_hashcode].rst).cm.fn }}
                        </span>
                    </div>
                    <div class="iaa-file-gs-box">
                        <span class="mr-2">
                            <span class="iaa-op-50">
                                <span v-if="iaa_display_tag_name == '__all__'">
                                    OVERALL
                                </span>
                                <span v-else>
                                    {{ iaa_display_tag_name }}
                                </span>
                                in GS:
                            </span> 
                            {{ count_gs_tags(v_ann.ann_hashcode) }}
                        </span>
                    </div>
                </div>
            </div>

        </div>

    </div>
</div>

<div id="mui_iaa_tags" class="d-flex h-100 ml-1">
    <div v-if="dtd != null && iaa_dict != null && iaa_display_hashcode != null" class="box w-100 h-100">
        <div class="box-header">
            <h4>
                <i class="fa fa-tag"></i>
                Annotated Tags
            </h4>
        </div>

        <div v-if="iaa_display_hashcode != null"
            class="box-body d-flex flex-column">
            <div class="w-100 d-flex flex-row">

                <div class="iaa-tag-detail-header iaa-tag-detail-a"
                    :class="{'iaa-w-40': iaa_display_adj_panel, 'iaa-w-50': !iaa_display_adj_panel}">
                    <i class="fa fa-user"></i>
                    A 
                    {{ iaa_dict.ann[iaa_display_hashcode].anns[0]._filename }}
                </div>

                <div class="iaa-tag-detail-header"
                    :class="{'iaa-w-40': iaa_display_adj_panel, 'iaa-w-50': !iaa_display_adj_panel}">
                    <i class="fa fa-user"></i>
                    B
                    {{ iaa_dict.ann[iaa_display_hashcode].anns[1]._filename }}
                </div>

                <div v-if="iaa_display_adj_panel"
                    v-on:click="iaa_gs_dict[iaa_display_hashcode].ann._has_star = !iaa_gs_dict[iaa_display_hashcode].ann._has_star"
                    title="Set check"
                    class="iaa-tag-detail-header iaa-tag-detail-g iaa-tag-detail-g-header iaa-w-20">
                    <span v-if="iaa_gs_dict[iaa_display_hashcode].ann._has_star">
                        <i class="fa fa-check-circle fg-emerald"></i>
                    </span>
                    <span v-else>
                        <i class="far fa-circle"></i>
                    </span>
                    <span>
                        {{ iaa_gs_dict[iaa_display_hashcode].ann._filename }}
                    </span>
                    
                </div>
                
            </div>

            <div v-for="tag_rst, tag_name in iaa_dict.ann[iaa_display_hashcode].rst.tag"
                v-if="iaa_display_tag_name == '__all__' || iaa_display_tag_name == tag_name"
                class="w-100 mb-2">
                    
                <div class="iaa-tag-name d-flex flex-row">
                    <div class="iaa-tag-name-ab mr-1"
                        :class="{'iaa-w-80': iaa_display_adj_panel, 'iaa-w-100': !iaa_display_adj_panel}">
                        <i class="fa fa-tag mr-1"
                            v-bind:class="'fg-tag-' + tag_name">
                        </i>
                        <span class="mr-2">
                            {{ tag_name }}
                        </span>
                        <span class="mr-2">
                            AB: {{ tag_rst.cm.tp }}
                        </span>
                        <span class="mr-2">
                            A+: {{ tag_rst.cm.fp }}
                        </span>
                        <span class="mr-2">
                            B+: {{ tag_rst.cm.fn }}
                        </span>
                    </div>

                    <div v-if="iaa_display_adj_panel"
                        class="iaa-tag-name-g iaa-tag-detail-g iaa-w-20">
                        <i class="fa fa-tag mr-1"
                            v-bind:class="'fg-tag-' + tag_name">
                        </i>
                        <span class="mr-2">
                            {{ tag_name }}
                        </span>
                        <span v-if="iaa_gs_dict != null">
                            Total: {{ count_iaa_gs_tag_notnull(iaa_gs_dict[iaa_display_hashcode].rst[tag_name]) }}
                        </span>
                        <span v-else>
                            &nbsp;
                        </span>
                    </div>
                </div>

                <div v-if="iaa_display_tags_tp"
                    class="iaa-tag-rsts-tp w-100">
                    <!-- last, show the TP group -->
                    <div v-for="tags_tp, tag_idx in tag_rst.cm.tags.tp"
                        class="iaa-tag-detail w-100 d-flex flex-row">
                        <div class="iaa-tag-detail-a"
                            :class="{'iaa-w-40': iaa_display_adj_panel, 'iaa-w-50': !iaa_display_adj_panel}">
                            <iaa-tag-info
                                v-bind:hashcode="iaa_display_hashcode"
                                v-bind:cm="'tp'"
                                v-bind:from="'A'"
                                v-bind:tag="tags_tp[0]"
                                v-bind:tag_idx="tag_idx"
                                v-bind:ann="iaa_dict.ann[iaa_display_hashcode].anns[0]"
                                v-bind:dtd="dtd"
                                v-bind:iaa_display_tags_context="iaa_display_tags_context"
                                v-bind:force_update="force_module_update"
                            ></iaa-tag-info>
                        </div>
                        <div class="iaa-tag-detail-b"
                            :class="{'iaa-w-40': iaa_display_adj_panel, 'iaa-w-50': !iaa_display_adj_panel}">
                            <iaa-tag-info
                                v-bind:hashcode="iaa_display_hashcode"
                                v-bind:cm="'tp'"
                                v-bind:from="'B'"
                                v-bind:tag="tags_tp[1]"
                                v-bind:tag_idx="tag_idx"
                                v-bind:ann="iaa_dict.ann[iaa_display_hashcode].anns[1]"
                                v-bind:dtd="dtd"
                                v-bind:iaa_display_tags_context="iaa_display_tags_context"
                                v-bind:force_update="force_module_update"
                            ></iaa-tag-info>
                        </div>
                        <div v-if="iaa_display_adj_panel && iaa_gs_dict != null"
                            class="iaa-tag-detail-g iaa-w-20">
                            
                            <iaa-tag-info-gs
                                v-bind:hashcode="iaa_display_hashcode"
                                v-bind:cm="'tp'"
                                v-bind:tag_obj="iaa_gs_dict[iaa_display_hashcode].rst[tag_name].tp[tag_idx]"
                                v-bind:tag_idx="tag_idx"
                                v-bind:ann="iaa_gs_dict[iaa_display_hashcode].ann"
                                v-bind:dtd="dtd"
                                v-bind:force_update="force_module_update"
                            ></iaa-tag-info-gs>

                        </div>
                    </div>

                </div>                            

                <div class="iaa-tag-rsts-fp w-100">
                    <!-- first, show the FP group -->
                    <div v-for="tags_fp, tag_idx in tag_rst.cm.tags.fp"
                        class="iaa-tag-detail w-100 d-flex flex-row">
                        <div class="iaa-tag-detail-a"
                            :class="{'iaa-w-40': iaa_display_adj_panel, 'iaa-w-50': !iaa_display_adj_panel}">
                            <iaa-tag-info
                                v-bind:hashcode="iaa_display_hashcode"
                                v-bind:cm="'fp'"
                                v-bind:from="'A'"
                                v-bind:tag="tags_fp[0]"
                                v-bind:tag_idx="tag_idx"
                                v-bind:ann="iaa_dict.ann[iaa_display_hashcode].anns[0]"
                                v-bind:dtd="dtd"
                                v-bind:iaa_display_tags_context="iaa_display_tags_context"
                                v-bind:force_update="force_module_update"
                            ></iaa-tag-info>
                        </div>

                        <div class="iaa-tag-detail-b"
                            :class="{'iaa-w-40': iaa_display_adj_panel, 'iaa-w-50': !iaa_display_adj_panel}">
                            <iaa-tag-info
                                v-if="tags_fp[1] != null"
                                v-bind:hashcode="iaa_display_hashcode"
                                v-bind:cm="'fp'"
                                v-bind:from="'B'"
                                v-bind:tag="tags_fp[1]"
                                v-bind:tag_idx="tag_idx"
                                v-bind:ann="iaa_dict.ann[iaa_display_hashcode].anns[1]"
                                v-bind:dtd="dtd"
                                v-bind:iaa_display_tags_context="iaa_display_tags_context"
                                v-bind:force_update="force_module_update"
                            ></iaa-tag-info>
                        </div>

                        <div v-if="iaa_display_adj_panel && iaa_gs_dict != null"
                            class="iaa-tag-detail-g iaa-w-20">
                            <iaa-tag-info-gs
                                v-bind:hashcode="iaa_display_hashcode"
                                v-bind:cm="'fp'"
                                v-bind:tag_obj="iaa_gs_dict[iaa_display_hashcode].rst[tag_name].fp[tag_idx]"
                                v-bind:tag_idx="tag_idx"
                                v-bind:ann="iaa_gs_dict[iaa_display_hashcode].ann"
                                v-bind:dtd="dtd"
                                v-bind:force_update="force_module_update"
                            ></iaa-tag-info-gs>
                        </div>
                    </div>
                </div>

                <div class="iaa-tag-rsts-fn w-100">
                    <!-- second, show the FN group -->
                    <div v-for="tags_fn, tag_idx in tag_rst.cm.tags.fn"
                        class="iaa-tag-detail w-100 d-flex flex-row">
                        <div class="iaa-tag-detail-a"
                            :class="{'iaa-w-40': iaa_display_adj_panel, 'iaa-w-50': !iaa_display_adj_panel}">
                            &nbsp;
                        </div>
                        <div class="iaa-tag-detail-b"
                            :class="{'iaa-w-40': iaa_display_adj_panel, 'iaa-w-50': !iaa_display_adj_panel}">
                            <iaa-tag-info
                                v-bind:hashcode="iaa_display_hashcode"
                                v-bind:cm="'fn'"
                                v-bind:from="'B'"
                                v-bind:tag="tags_fn[1]"
                                v-bind:tag_idx="tag_idx"
                                v-bind:ann="iaa_dict.ann[iaa_display_hashcode].anns[1]"
                                v-bind:dtd="dtd"
                                v-bind:iaa_display_tags_context="iaa_display_tags_context"
                                v-bind:force_update="force_module_update"
                            ></iaa-tag-info>
                        </div>

                        <div v-if="iaa_display_adj_panel"
                            class="iaa-tag-detail-g iaa-w-20">
                            <iaa-tag-info-gs
                                v-bind:hashcode="iaa_display_hashcode"
                                v-bind:cm="'fn'"
                                v-bind:tag_obj="iaa_gs_dict[iaa_display_hashcode].rst[tag_name].fn[tag_idx]"
                                v-bind:tag_idx="tag_idx"
                                v-bind:ann="iaa_gs_dict[iaa_display_hashcode].ann"
                                v-bind:dtd="dtd"
                                v-bind:force_update="force_module_update"
                            ></iaa-tag-info-gs>
                        </div>
                    </div>
                </div>
                
            </div>
        </div>
    </div>
</div>
    </div>

    <div v-else-if="iaa_display_measure == 'cohen_kappa'"
        class="w-100 d-flex flex-row" style="height: calc(100% - 30px);">
        
        <div id="mui_iaa_cohenk_summary"
            class="d-flex h-100 mr-1">
            <div v-if="dtd != null && iaa_dict != null && iaa_dict.all.hasOwnProperty('cohen_kappa')" class="box h-100">
                <!-- <div class="box-header">
                    <h4>
                        <i class="fa fa-list-ul"></i>
                        Cohen's Kappa Coefficient
                    </h4>
                </div> -->

                <div class="box-body d-flex flex-column">
                    <div>
    Overall Cohen's Kappa: 
    <b>
        {{ to_fixed(iaa_dict.all.cohen_kappa.kappa) }} 
    </b>
    &nbsp;
    &nbsp;
    Percentage Agreement: 
    <b>
        {{ to_fixed(iaa_dict.all.cohen_kappa.Po) }}
    </b>

    <br>
    
    <i class="ml-1">TP</i>: <b>{{ iaa_dict.all.cm.tp }}</b>
    &nbsp;
    <i class="ml-1">FP</i>: <b>{{ iaa_dict.all.cm.fp }}</b>
    &nbsp;
    <i class="ml-1">FN</i>: <b>{{ iaa_dict.all.cm.fn }}</b>
    &nbsp;
    <i class="ml-1">N</i>: <b>{{ iaa_dict.all.cohen_kappa.N }}</b>
    <br>

    <i class="ml-1">Po</i>: <b>{{ to_fixed(iaa_dict.all.cohen_kappa.Po) }}</b>
    &nbsp;
    <i class="ml-1">Pe</i>: <b>{{ to_fixed(iaa_dict.all.cohen_kappa.Pe) }}</b>
    &nbsp;
    <i class="ml-1">SE<sub>k</sub></i>: <b>{{ to_fixed(iaa_dict.all.cohen_kappa.SE_k) }}</b>
    &nbsp;
    <i class="ml-1">95% CI</i>: 
    <b>
        {{ to_fixed(iaa_dict.all.cohen_kappa.lower) }}, 
        {{ to_fixed(iaa_dict.all.cohen_kappa.upper) }}
    </b>

</div>

<!-- 
<div class="mr-2">
    <p>
        Cohen's Kappa of each document
    </p>

    <div v-for="ann_rst, ann_hashcode in iaa_dict.ann"
        v-bind:class="{'iaa-row-actived': iaa_display_hashcode == ann_hashcode}"
        class="iaa-row d-flex flex-row">
        <div class="iaa-bar-name-box d-flex flex-row flex-align-center flex-justify-start mr-1">
            {{ ann_rst.anns[0]._filename }}
        </div>
        <div>
            <b>
                {{ to_fixed(ann_rst.rst.all.cohen_kappa.kappa ) }}
            </b>&nbsp;
            (
                {{ to_fixed(ann_rst.rst.all.cohen_kappa.lower) }} , 
                {{ to_fixed(ann_rst.rst.all.cohen_kappa.upper) }}
            )
        </div>
    </div>


</div> 
-->

<div class="mr-2">
    <table id="table_cohen_kappa_confusion_matrix" class="doctag-table">
        <thead>
            <tr style="background: white;">
                <th style="border: 0;"
                    colspan="2">
                    &nbsp;
                </th>
                <th v-bind:colspan="dtd.etags.length+2">
                    <b>
                        Annotator B
                    </b>
                </th>
            </tr>
            <tr>
                <th>&nbsp;</th>
                <th>&nbsp;</th>
                <th v-for="tag_def in dtd.etags"
                    v-bind:class="'fg-tag-' + tag_def.name">
                    <span class="rotate-90">
                        <i class="fa fa-tag"
                            v-bind:class="'fg-tag-' + tag_def.name">
                        </i>
                        {{ tag_def.name }}
                    </span>
                </th>
                <!-- 
                <th v-for="tag_def in dtd.rtags"
                    v-bind:class="'fg-tag-' + tag_def.name">
                    <span class="rotate-90">
                        <i class="fa fa-link"
                            v-bind:class="'fg-tag-' + tag_def.name">
                        </i>
                        {{ tag_def.name }}
                    </span>
                </th> 
                -->
    
                <th>EMPTY</th>
                <th>
                    <i>P<sub>b</sub></i>
                </th>
            </tr>
        </thead>
        <tbody>
            <tr v-for="tag_def_row, row_idx in dtd.etags">
                <td v-if="row_idx == 0"
                    style="vertical-align: middle; padding: 10px;"
                    v-bind:rowspan="dtd.etags.length+2">
                    <b>Annotator A</b>
                </td>
                <td v-bind:class="'fg-tag-' + tag_def_row.name">
                    <span class="txt-bold">
                        <i class="fa fa-tag"></i>
                        {{ tag_def_row.name }}
                    </span>
                </td>
                <td v-for="tag_def_col in dtd.etags">
                    <span v-if="tag_def_col.name == tag_def_row.name">
                        {{ iaa_dict.tag[tag_def_row.name].cm.tp }}
                    </span>
                    <span v-else>
                        &nbsp;
                    </span>
                </td>
                <td class="clr-grey">
                    {{ iaa_dict.tag[tag_def_row.name].cm.fp }}
                </td>
                <td class="txt-italic">
                    <span>
                        {{ to_fixed(iaa_dict.all.cohen_kappa.Pes.b[tag_def_row.name]) }}
                    </span>
                </td>
            </tr>
    
            <tr>
                <td class="txt-bold">EMPTY</td>
                <td v-for="tag_def_col in dtd.etags"
                    class="clr-grey">
                    <span>
                        {{ iaa_dict.tag[tag_def_col.name].cm.fn }}
                    </span>
                </td>
                <td class="clr-grey">
                    0
                </td>
                <td class="txt-italic">
                    <span>
                        {{ to_fixed(iaa_dict.all.cohen_kappa.Pes.b['_EMPTY_']) }}
                    </span>
                </td>
            </tr>
            <tr>
                <td class="txt-bold">
                    <i>P<sub>a</sub></i>
                </td>
                <td v-for="tag_def_col in dtd.etags"
                    class="txt-italic">
                    <span>
                        {{ to_fixed(iaa_dict.all.cohen_kappa.Pes.a[tag_def_col.name]) }}
                    </span>
                </td>
                <td class="txt-italic">
                    <span>
                        {{ to_fixed(iaa_dict.all.cohen_kappa.Pes.a['_EMPTY_']) }}
                    </span>
                </td>
            </tr>
        </tbody>
    </table>
    <p>
        
        
    </p>
</div>
                </div>
            </div>
        </div>
    </div>


    
</div>

    <!-- the ui for error analysis -->
    <div v-show="section=='razer'" id="main_ui" 
    class="main-ui container-fluid"
    style="height: calc(100% - 145px);">


<div class="d-flex h-100 mr-1">

    <!-- first column for summary -->
    <div class="box h-100 mr-1 razer-lane-1"
        style="overflow-x: hidden; overflow-y: auto;">

        <div class="box-header">
            <h4>
                <i class="fas fa-clipboard-check"></i>
                Error Summary
            </h4>
        </div>

        <div v-if="get_razer_rst() != null"
            class="box-body border-bottom bd-gray mb-1">
            <ul class="mt-0 mb-2">
                <li>
                    FP: 
                    <b>
                        {{ get_razer_rst().err_stat.by_iaa.n_FP }}
                    </b>
                    |
                    FN: 
                    <b>
                        {{ get_razer_rst().err_stat.by_iaa.n_FN }}
                    </b>
                    |
                    Error Rate: 
                    <b>
                        {{ to_fixed(100 * get_razer_rst().err_stat.by_iaa.error_rate) }}%
                    </b>
                </li>
                <li>
                    Accuracy: 
                    <b>
                        {{ to_fixed(100 * get_razer_rst().err_stat.by_iaa.accuracy) }}%
                    </b>
                    |
                    Precision: 
                    <b>
                        {{ to_fixed(100 * get_razer_rst().err_stat.by_iaa.precision) }}%
                    </b>
                </li>
                <li>
                    Recall: 
                    <b>
                        {{ to_fixed(100 * get_razer_rst().err_stat.by_iaa.recall) }}%
                    </b>
                    |
                    F1-Score: 
                    <b>
                        {{ to_fixed(get_razer_rst().err_stat.by_iaa.f1) }}
                    </b>
                </li>
                <li>
                    Median of errors per document:
                    <b>
                        {{ to_fixed(get_razer_rst().err_stat.by_smu.med_n_err_per_doc) }}
                    </b>
                </li>

            </ul>
        </div>

        <div class="box-header">
            <h4>
                <i class="far fa-chart-bar"></i>
                Statistics by Error Types
            </h4>
        </div>


        <div v-if="get_razer_rst() != null"
            class="box-body border-bottom bd-gray">
            <div class="d-flex flex-column mt-2 mb-2">
                <div v-for="err_types, err_cate in razer_err_def"
                    class="razer-hbar-group mb-1">
                    <h6>
                        {{ err_cate }}
                    </h6>
                    <div v-for="err_type in err_types"
                        @click="show_uids_in_razer_err_list(get_razer_stat_by_err_type(err_type, 'FP'), get_razer_stat_by_err_type(err_type, 'FN'))"
                        class="d-flex flex-row razer-hbar cursor-pointer">
                        <div class="razer-hbar-label">
                            {{ err_type }}
                        </div>
                        <div class="razer-hbar-bar-box">
                            <div class="razer-hbar-bar razer-hbar-bar-FP"
                                :style="{width: stat_value2width(get_razer_n_stat_by_err_type(err_type, 'FP'), get_razer_rst().err_stat.by_smu.max_val) + 'px'}">
                            </div>
                            <div class="razer-hbar-bar razer-hbar-bar-FN"
                                :style="{width: stat_value2width(get_razer_n_stat_by_err_type(err_type, 'FN'), get_razer_rst().err_stat.by_smu.max_val) + 'px'}">
                            </div>
                            <div class="razer-hbar-bar-num">
                                {{ to_comma(get_razer_n_stat_by_err_type(err_type)) }}
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>




        <div class="box-header">
            <h4>
                <i class="far fa-chart-bar"></i>
                Statistics by Error Label Count
            </h4>
        </div>

        <div v-if="get_razer_rst() != null"
            class="box-body">
            <!-- <div id="razer_donut_chart" style="width: 240px; height: 150px;"></div> -->
            <div class="d-flex flex-column mt-2 mb-2">
                <div v-for="freq in 6"
                    class="d-flex flex-row razer-hbar cursor-pointer"
                    title="Click to check the detailed error list"
                    @click="show_uids_in_razer_err_list(get_razer_rst().err_stat.by_smu.freq_n_err_labels[freq - 1].FP, get_razer_rst().err_stat.by_smu.freq_n_err_labels[freq - 1].FN)">
                    <div class="razer-hbar-label">
                        {{ freq - 1 }} 
                        <span v-if="freq == 2">
                            Label<span class="clr-trans">s</span>
                        </span>
                        <span v-else>
                            Labels
                        </span>
                    </div>
                    <div class="razer-hbar-bar-box">
                        <div class="razer-hbar-bar razer-hbar-bar-FP"
                            :style="{width: stat_value2width(get_razer_rst().err_stat.by_smu.freq_n_err_labels[freq - 1].FP.length, get_razer_rst().err_stat.by_iaa.n_F) + 'px'}">
                        </div>
                        <div class="razer-hbar-bar razer-hbar-bar-FN"
                            :style="{width: stat_value2width(get_razer_rst().err_stat.by_smu.freq_n_err_labels[freq - 1].FN.length, get_razer_rst().err_stat.by_iaa.n_F) + 'px'}">
                        </div>
                        <div class="razer-hbar-bar-num">
                            {{ get_razer_rst().err_stat.by_smu.freq_n_err_labels[freq - 1].FP.length + get_razer_rst().err_stat.by_smu.freq_n_err_labels[freq - 1].FN.length }}
                        </div>
                    </div>
                </div>
            </div>
        </div>

        


    </div>


    <!-- column for the stat by type  -->
    <div class="box h-100 mr-1 razer-lane-1"
        style="overflow-x: hidden; overflow-y: auto;">

        <div class="box-header">
            <h4>
                <i class="far fa-chart-bar"></i>
                Statistics by Concepts
            </h4>
        </div>

        <div v-if="get_razer_rst() != null"
            class="box-body border-bottom bd-gray">
            <div class="d-flex flex-column mt-2 mb-2">
                <div v-for="stat, etag_name in get_razer_rst().err_stat.by_dtd"
                    class="d-flex flex-row razer-hbar cursor-pointer"
                    @click="show_uids_in_razer_err_list(stat.FP, stat.FN)">
                    <div class="razer-hbar-label">
                        {{ etag_name }}
                    </div>
                    <div class="razer-hbar-bar-box">
                        <div class="razer-hbar-bar razer-hbar-bar-FP"
                            :style="{width: stat_value2width(stat.FP.length, get_razer_rst().err_stat.by_smu.max_val) + 'px'}">
                        </div>
                        <div class="razer-hbar-bar razer-hbar-bar-FN"
                            :style="{width: stat_value2width(stat.FN.length, get_razer_rst().err_stat.by_smu.max_val) + 'px'}">
                        </div>
                        <div class="razer-hbar-bar-num">
                            {{ stat.FP.length + stat.FN.length }}
                        </div>
                    </div>
                </div>
            </div>
        </div>




        <div class="box-header">
            <h4>
                <i class="fas fa-braille"></i>
                Top 10 Error Tags
            </h4>
        </div>

        <div v-if="get_razer_rst() != null"
            class="box-body border-bottom bd-gray">
            <div class="d-flex flex-column mt-2 mb-2">
                <div v-for="txt in razer_err_tag_top_10"
                    class="d-flex flex-row razer-hbar cursor-pointer"
                    @click="show_uids_in_razer_err_list(get_razer_rst().err_stat.by_txt[txt].FP, get_razer_rst().err_stat.by_txt[txt].FN)">
                    <div class="razer-hbar-label">
                        {{ txt }}
                    </div>
                    <div class="razer-hbar-bar-box">
                        <div class="razer-hbar-bar razer-hbar-bar-FP"
                            :style="{width: stat_value2width(get_razer_rst().err_stat.by_txt[txt].FP.length, get_razer_rst().err_stat.by_smu.max_val) + 'px'}">
                        </div>
                        <div class="razer-hbar-bar razer-hbar-bar-FN"
                            :style="{width: stat_value2width(get_razer_rst().err_stat.by_txt[txt].FN.length, get_razer_rst().err_stat.by_smu.max_val) + 'px'}">
                        </div>
                        <div class="razer-hbar-bar-num">
                            {{ get_razer_rst().err_stat.by_txt[txt].FP.length + get_razer_rst().err_stat.by_txt[txt].FN.length }}
                        </div>
                    </div>
                </div>
            </div>
        </div>





        <div class="box-header">
            <h4>
                <i class="fas fa-braille"></i>
                File Distribution by Error Count
            </h4>
        </div>

        <div class="box-body border-bottom bd-gray">
            <div class="d-flex flex-column mt-2 mb-2">
                <!-- <div id="razer_fig_doc_scatter"
                    style="width: 220px; height: 220px;">

                </div> -->
                <div id="razer_fig_doc_heatmap"
                    style="width: 230px; height: 260px;">

                </div>
            </div>
        </div>

    </div>


    <!-- third column for distribution -->
    <div class="box h-100 razer-lane-3"
        style="overflow-x: hidden; overflow-y: auto;">

        <div class="box-header">
            <h4>
                <i class="far fa-map"></i>
                Error Distribution
            </h4>
            <div class="">

            </div>
        </div>

        <div class="box-body"
            id="err_sankey_box">
            <div id="razer_sankey_diagram">

            </div>
        </div>




        <div class="box-header">
            <h4>
                <i class="far fa-map"></i>
                Tag Distribution
            </h4>
            <div v-if="razer_fig_tag_scatter != null"
                class="d-flex flex-row">
                <div class="d-flex flex-row">
                    <span class="ml-2" 
                        style="width: 55px;">
                        <i class="fas fa-palette"></i>
                        Color:
                    </span>
                    <select style="width: 100px;"
                        v-model="razer_fig_tag_scatter_clr"
                        @change="on_change_razer_fig_tag_scatter_color_encoding($event)">
                        <option value="by_err">By FP / FN</option>
                        <option value="by_err_cate">By Error Category</option>
                        <option value="by_err_type">By Error Type</option>
                        <option value="by_concept">By Concept</option>
                    </select>
                </div>

                <button class="btn btn-xs"
                    v-if="razer_fig_tag_scatter.selected_indices.length > 0"
                    @click="show_razer_selected_tags_in_fig_tag_scatter">
                    Show Selected <b>{{ razer_fig_tag_scatter.selected_indices.length }}</b> Tags
                </button>
            </div>
        </div>

        <div class="box-body"
            id="err_tagmap_box">
            <div id="razer_tag_scatter">

            </div>
        </div>
        
    </div>



    <!-- column for the tag list -->
    <div class="box h-100 mr-1"
        style="overflow-x: hidden; overflow-y: auto;">

        <div class="box-header">
            <h4>
                <i class="fa fa-list-ul"></i>
                Error List
            </h4>
            <div v-if="razer_err_list_uids != null">
                <span class="ml-2 mr-1">
                    <b>{{ razer_err_list_uids.length }}</b> Tags
                </span>
            </div>
        </div>

        <div v-if="get_razer_rst() != null"
            class="box-body h-100"
            id="err_list"
            style="overflow-y: auto;">
            
            <div v-if="razer_err_list_uids != null">
                
                <div v-for="uid, seq_num in razer_err_list_uids"
                    class="err-list-row d-flex flex-column">
                    <!-- a sequence number -->
                    <div class="razer-err-list-seq-num">
                        {{ seq_num + 1 }}
                    </div>

                    <!-- basic information -->
                    <div>
                        <span class="pl-1 pr-1 mr-1"
                            :class="'razer-bg-' + get_razer_err(uid)._judgement">
                            {{ get_razer_err(uid)._judgement }}
                        </span>
                        <span class="pl-1 pr-1 mr-1">
                            {{ get_razer_err(uid).tag }}
                        </span>
                        <span class="pl-1 pr-1 mr-2">
                            <b>
                                {{ get_razer_err(uid).text }}
                            </b>
                        </span>
                        <span v-if="razer_flag_show_taglist_context"
                            class="pl-1 pr-1 mr-1 clr-grey">
                            {{ get_razer_err(uid).spans }}
                        </span>
                    </div>

                    <!-- the context sentence -->
                    <div v-if="razer_flag_show_taglist_context">
                        <span class="err-list-row-sentence"
                        v-html="get_html_sentag_by_err(get_razer_err(uid))"></span>
                        <a href="javascript:void(0);"
                            @click="show_razer_tag_full_text($event, uid)">
                            full text &gt;
                        </a>
                    </div>

                    <!-- error labels -->
                    <div v-if="razer_flag_show_taglist_labels"
                        class="err-list-row-types d-flex">
                        <button @click="show_razer_pan_err_def_for_uid($event, uid)"
                            class="btn btn-xs btn-primary btn-add-err-type"
                            title="Add a new error type label for this tag">
                            <i class="fas fa-plus"></i>
                        </button>

                        <div v-if="get_razer_err(uid).hasOwnProperty('errors')"
                            class="d-flex flex-align-center">
                            <span v-for="e, e_idx in get_razer_err(uid)['errors']"
                                :title="e.category + ' - ' + e.type"
                                class="err-label mr-1">
                                <span title="Remove this error label from this tag"
                                    class="pan-close"
                                    @click="remove_razer_err_label(uid, e_idx)">
                                    <i class="fa fa-times"></i>
                                </span>
                                {{ e.type }}
                            </span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

    </div>



</div>



<!-- for labeling -->
<div id="razer_pan_err_def"
    v-show="is_shown_razer_pan_err_def"
    :style="{right: razer_pan_err_def_right + 'px', top: razer_pan_err_def_top + 'px'}">
    <div v-on:click="close_razer_pan_err_def"
        title="Close this panel"
        class="pan-close cursor-pointer">
        <i class="far fa-times-circle"></i>
    </div>

    <div class="d-flex flex-row">
        
        <div v-for="err_types, err_cate, err_cate_idx in razer_err_def"
            v-if="err_cate != 'UNK'"
            class="d-flex flex-column err-cate-section">
            <div class="white-space-nowrap">
                <span class="err-cate-idx mr-1">
                    {{ err_cate_idx + 1 }}
                </span>
                <span>
                    <b>{{ err_cate }}</b>
                </span>
            </div>

            <div v-for="err_type, err_type_idx in err_types"
                @click="add_razer_err_label(err_cate, err_type, razer_active_err_uid)"
                class="err-type-row cursor-pointer white-space-nowrap">
                <span class="err-type-idx mr-1">
                    {{ err_type_idx + 1 }}
                </span>
                <span class="err-type-label">
                    {{ err_type }}
                </span>
            </div>
            
        </div>
    </div>

</div>


<!-- for ML error identification -->
<div class="dialog" 
    data-role="dialog"
    id="dlg_razer_robot_iet">
    <div class="dialog-title">
        <i class="fas fa-robot"></i>
        Use Error Analysis (EA) Web Service
    </div>
    <div class="dialog-content">
        <p>
            You can use an EA web service to identify the error types automatically. ATTENTION: the tags and their contextual information will be sent to the following URL, please ensure the network security and data privacy.
        </p>
        <p>
            <label for="">EA Web Service URL: </label>
            <input type="text" 
                placeholder="http://"
                v-model="razer_ea_ws_url">
        </p>
        <p>
            <button class="button primary"
                @click="start_razer_eaws">
                Start Identification
            </button>
        </p>
    </div>
    <div class="dialog-actions">
        <button class="button js-dialog-close">
            <i class="fa fa-times"></i>
            Close this dialog
        </button>
    </div>
</div>




<!-- for embedding -->
<div class="dialog" data-role="dialog" id="dlg_razer_embedding_srv">
    <div class="dialog-title">
        <i class="fas fa-robot"></i>
        Use Text Embedding (TE) Web Service
    </div>
    <div class="dialog-content">
        <p>
            You can use an TE web service to project the text to 2-D panel for visualization. ATTENTION: the tags will be sent to the following URL, please ensure the network security and data privacy.
        </p>
        <p>
            <label for="">TE Web Service URL: </label>
            <input type="text" 
                placeholder="http://"
                v-model="razer_te_ws_url">
        </p>
        <p>
            <button class="button primary"
                @click="start_razer_tews">
                Start Embedding
            </button>
        </p>
    </div>
    <div class="dialog-actions">
        <button class="button js-dialog-close">
            <i class="fa fa-times"></i>
            Close this dialog
        </button>
    </div>
</div>




    
</div>
    
    <!-- the ui for statistics -->
    <div v-if="section=='statistics'" id="main_ui" 
    class="main-ui container-fluid">
    <!-- the tag list of selected file and concept -->
    <div v-show="display_stat_doc_sum_selected != null && has_doc_sum_selected_tags()"
    id="stat_doc_tag_detailbox"
    class="d-flex flex-column ml-2 stat-doc-sum-tags-box">

    <!-- the tag list for heatmap -->
    <div v-if="display_stat_doc_sum_selected != null && has_doc_sum_selected_tags()"
        class="stat-doc-sum-tags-header">
        <i class="fa fa-tags"></i>
        {{ display_stat_doc_sum_selected.file_name }} - 
        <span v-bind:class="'fg-tag-' + display_stat_doc_sum_selected.tag_name">
            <i class="fa fa-tag"
                v-bind:class="'fg-tag-' + display_stat_doc_sum_selected.tag_name">
            </i>
            {{ display_stat_doc_sum_selected.tag_name }}
        </span>
        <span>
            {{ stat_doc_sum_selected_tags.length }} tags
        </span>

        <button class="button mini ml-2"
            title="Close this panel"
            v-on:click="on_close_stat_ann_tag_box">
            <i class="fas fa-times"></i>
        </button>
    </div>

    <div class="stat-doc-sum-tags-body">
        <div v-for="tag in stat_doc_sum_selected_tags"
            class="d-flex flex-row flex-wrap flex-align-end mb-2">
            <div class="iaa-tag-detail-info-text-ab mr-2">
                <!-- <span class="mr-1"
                    v-bind:class="'mark-tag-' + tag.tag">
                    
                </span> -->
                {{ tag.id }}
            </div>

            <div class="mr-1 ml-1 d-flex flex-column">
                <div class="iaa-tag-attr-name">
                    {{ get_tag_spans_text(tag) }}:
                </div> 
    
                <div>
                    <b>{{ tag.text }}</b>
                </div>
            </div>

            <div v-for="(attr, attr_idx) in dtd.tag_dict[tag.tag].attrs"
                v-if="!['id','spans','text','tag'].contains(attr.name)"
                class="iaa-tag-attr mr-1 ml-1 d-flex flex-column">
    
                <div class="iaa-tag-attr-name">
                    {{ attr.name }}:
                </div> 
    
                <div>
                    {{ tag[attr.name] }}&nbsp;
                </div>
                
            </div>
        </div>
    </div>
</div>


<div class="w-100 d-flex flex-row" style="height: calc(100% + 10px);">

<!-- stat summary -->
<div id="mui_stat_summary" class="d-flex h-100">
    <div class="box w-100">
        <div class="box-header">
            <h4>
                <i class="fa fa-list-ul"></i>
                Corpus Summary
            </h4>
        </div>

        <div v-if="dtd != null && anns.length != 0"
            class="box-body"
            style="overflow-y: auto;">

            <div v-for="stat_item in stat_summary"
                class="stat-item-row box-body-item d-flex flex-row flex-justify-between">

                <!-- the stat label -->
                <div v-if="stat_item[2] == null"
                    class="stat-item-label stat-item-label-lg">
                    <span v-html="stat_item[0]"
                        :title="stat_item[0]">
                    </span>: 
                </div>
                <div v-else
                    class="stat-item-label">
                    <span v-html="stat_item[0]"
                        :title="stat_item[0]">
                    </span>: 
                </div>

                <!-- the stat result -->
                <div v-if="stat_item[2] == null"
                    :title="stat_item[0] + ': ' + stat_item[1]"
                    class="stat-item-value-sm mr-2 text-align">
                    <span >
                        {{ stat_item[1] }}
                    </span>
                </div>
                <div v-else-if="stat_item[2].stat_type == 'tag_count'"
                    :title="stat_item[0] + ': ' + stat_item[1]"
                    class="stat-item-value mr-2 d-flex flex-row flex-align-center flex-justify-end">
                    <div class="mr-1">
                        {{ stat_item[1] }}
                    </div>
                    <div class="iaa-bar"
                        v-bind:class="'mark-tag-' + stat_item[2].tag"
                        v-bind:style="{width: stat_value2width(stat_item[1], stat_docs_by_tags.stat.max_by_tag) + 'px', }">
                    </div>
                </div>
            </div>
            
        </div>
    </div>
    <!-- /.box -->
</div>

<!-- stat details -->
<div id="mui_stat_details" class="d-flex ml-2">

<div class="w-100 d-flex flex-row flex-wrap h-100"
        style="overflow-y: auto;">
    <div class="box w-100 mb-2">
        <div class="box-header">
            <h4>
                <i class="fas fa-table"></i>
                Annotation Overview
            </h4>
        </div>
        <div v-if="dtd != null && anns.length > 0"
            class="box-body">
            <table class="doctag-table" style="float: left;">
                <thead>
                    <tr>
                        <th>File Name</th>
                        <th>Total</th>
                        <th v-for="tag_def in dtd.etags"
                            v-bind:class="'fg-tag-' + tag_def.name">
                            <span class="rotate-90">
                                <i class="fa fa-tag"
                                    v-bind:class="'fg-tag-' + tag_def.name">
                                </i>
                                {{ tag_def.name }}
                            </span>
                        </th>
                        <th v-for="tag_def in dtd.rtags"
                            v-bind:class="'fg-tag-' + tag_def.name">
                            <span class="rotate-90">
                                <i class="fa fa-link"
                                    v-bind:class="'fg-tag-' + tag_def.name">
                                </i>
                                {{ tag_def.name }}
                            </span>
                        </th>
                    </tr>
                </thead>
                <tbody>
                    <tr v-for="stat, stat_idx in stat_docs_by_tags.rs">
                        <td v-if="stat_idx == 0"
                            class="td-summary">
                            {{ stat.file_name }}
                        </td>
                        <td v-else
                            class="td-filename"
                            title="Check this file in the Annotation tab"
                            v-on:click="show_ann_file(stat.file_name)">
                            {{ stat.file_name }}
                        </td>
                        <td>
                            {{ stat._total_tags }}
                        </td>
                        <td v-for="tag_def in dtd.etags">
                            <span v-if="stat_idx == 0"
                                class="td-count"
                                v-bind:class="'td-count-' + stat[tag_def.name]">
                                {{ stat[tag_def.name] }}
                            </span>
                            <span v-else
                                class="td-count cursor-pointer"
                                title="Click to check these tags"
                                v-bind:style="'background-color:'+ stat_value2bgcolor(stat[tag_def.name], stat_docs_by_tags.stat.max_by_ann_tag) + '; color:' + stat_value2ftcolor(stat[tag_def.name], stat_docs_by_tags.stat.max_by_ann_tag) + ';'"
                                v-bind:class="'td-count-' + stat[tag_def.name]"
                                v-on:click="on_click_stat_ann_tag_box($event, stat.file_name, tag_def.name)">
                                {{ stat[tag_def.name] }}
                            </span>
                        </td>
                        <td v-for="tag_def in dtd.rtags">
                            <span v-if="stat_idx == 0"
                                class="td-count"
                                v-bind:class="'td-count-' + stat[tag_def.name]">
                                {{ stat[tag_def.name] }}
                            </span>
                            <span v-else
                                class="td-count cursor-pointer"
                                title="Click to check these tags"
                                v-bind:style="'background-color:'+ stat_value2bgcolor(stat[tag_def.name], stat_docs_by_tags.stat.max_by_ann_tag) + '; color:' + stat_value2ftcolor(stat[tag_def.name], stat_docs_by_tags.stat.max_by_ann_tag) + ';'"
                                v-bind:class="'td-count-' + stat[tag_def.name]"
                                v-on:click="on_click_stat_ann_tag_box($event, stat.file_name, tag_def.name)">
                                {{ stat[tag_def.name] }}
                            </span>
                        </td>
                    </tr>
                </tbody>
            </table>

            
        </div>
    </div>


    <div class="box w-100">
        <div class="box-header">
            <h4>
                <i class="fa fa-list-ul"></i>
                Token Summary
            </h4>
        </div>
        <div v-if="dtd != null && anns.length > 0"
            class="box-body" style="overflow-y: auto;">
            <div class="d-flex flex-column w-100 h-100">

                <div v-for="(tag_def, tag_def_idx) in dtd.etags"
                    class="ruleset-tag-item d-flex flex-row mb-1 pt-1 pb-1">
                    <div class="ruleset-tag-name pl-2 d-flex flex-row flex-justify-between"
                        v-bind:class="'border-tag-' + tag_def.name">
                        <div class="ruleset-tag-name-str"
                            v-bind:title="tag_def.name">
                            <i class="fa fa-tag"
                                v-bind:class="'fg-tag-' + tag_def.name">
                            </i>
                            {{ tag_def.name }}
                        </div>
                        <div v-if="hint_dict.hasOwnProperty(tag_def.name)"
                            v-bind:title="'[' + tag_def.name + '] has ' + hint_dict[tag_def.name].texts.length + ' unique tokens'"
                            class="mr-2 stat-tag-count">
                            <span v-if="stat_filter_min_tokens == 0">
                                {{ hint_dict[tag_def.name].texts.length }}
                            </span>
                            <span v-else>
                                {{ count_texts_by_stat_fileter(tag_def) }}
                                /
                                {{ hint_dict[tag_def.name].texts.length }}
                            </span>
                        </div>
                        <div v-else>
                            -
                        </div>
                    </div>

                    <div v-if="hint_dict.hasOwnProperty(tag_def.name)"
                        class="ruleset-tag-info d-flex flex-row flex-wrap">

                        <!-- for the NC etags -->
                        <div v-if="hint_dict[tag_def.name].nc_dict.count > 0"
                            class="ruleset-tag-text mr-2 mb-2 d-flex flex-column">

                            <div v-on:click="hint_dict[tag_def.name].nc_dict._is_shown = !hint_dict[tag_def.name].nc_dict._is_shown">
                                <span class="ruleset-tag-text-count"
                                    v-bind:title="'Annotated ' + hint_dict[tag_def.name].nc_dict.count + ' times'">
                                    <i v-if="hint_dict[tag_def.name].nc_dict._is_shown"
                                        class="fa fa-caret-down"></i>
                                    <i v-else
                                        class="fa fa-caret-right"></i>
                                    {{ hint_dict[tag_def.name].nc_dict.count }}
                                </span>
                                <span class="ruleset-tag-text-str">
                                    <i class="far fa-file"></i>
                                    DOC-LEVEL
                                </span>
                            </div>

                            <div v-show="hint_dict[tag_def.name].nc_dict._is_shown"
                                class="ruleset-tag-text-filelist">
                                <div v-for="(fn_v, fn) in hint_dict[tag_def.name].nc_dict.ann_fn_dict"
                                    v-on:click="show_ann_file(fn)"
                                    class="ruleset-tag-text-filelist-item">
                                    <span class="ruleset-tag-text-filelist-item-count">
                                        {{ fn_v }}
                                    </span>
                                    <i class="fa fa-angle-right ml-1 mr-1"></i>
                                    <span>
                                        {{ fn }}
                                    </span>
                                </div>
                            </div>
                        </div>

                        <!-- for general etags -->
                        <div v-for="v_text_info in sort_text_dict_in_hint_dict(hint_dict[tag_def.name].text_dict)"
                            v-if="stat_filter_min_tokens == 0 || hint_dict[tag_def.name].text_dict[v_text_info.text].count <= stat_filter_min_tokens"
                            class="ruleset-tag-text mr-1 mb-1 d-flex flex-column">
                            <div v-on:click="hint_dict[tag_def.name].text_dict[v_text_info.text]._is_shown = !hint_dict[tag_def.name].text_dict[v_text_info.text]._is_shown"
                                class="cursor-pointer"
                                title="Click to check which document contains this tag">
                                <span class="ruleset-tag-text-count"
                                    v-bind:title="'Annotated ['+v_text_info.text+'] ' + hint_dict[tag_def.name].text_dict[v_text_info.text].count + ' time(s)'"
                                    :style="{ color: stat_value2ftcolor(hint_dict[tag_def.name].text_dict[v_text_info.text].count, stat_docs_by_tags.stat.max_by_tag), backgroundColor: stat_value2bgcolor(hint_dict[tag_def.name].text_dict[v_text_info.text].count, stat_docs_by_tags.stat.max_by_tag) }">
                                    <i v-if="hint_dict[tag_def.name].text_dict[v_text_info.text]._is_shown"
                                        v-show="stat_filter_token_text"
                                        class="fa fa-caret-down"></i>
                                    <i v-else
                                        v-show="stat_filter_token_text"
                                        class="fa fa-caret-right"></i>
                                    {{ hint_dict[tag_def.name].text_dict[v_text_info.text].count }}
                                </span>
                                <span v-show="stat_filter_token_text"
                                    class="ruleset-tag-text-str">
                                    {{ v_text_info.text }}
                                </span>
                            </div>
                            <div v-show="stat_filter_token_text && hint_dict[tag_def.name].text_dict[v_text_info.text]._is_shown"
                                class="ruleset-tag-text-filelist">
                                <div v-for="(fn_v, fn) in hint_dict[tag_def.name].text_dict[v_text_info.text].ann_fn_dict"
                                    v-on:click="show_ann_file(fn)"
                                    v-bind:title="'Click to check this tag in ' + fn"
                                    class="ruleset-tag-text-filelist-item cursor-pointer">
                                    <span class="ruleset-tag-text-filelist-item-count"
                                    :style="{ color: stat_value2ftcolor(fn_v, stat_docs_by_tags.stat.max_by_tag), backgroundColor: stat_value2bgcolor(fn_v, stat_docs_by_tags.stat.max_by_tag) }">
                                        {{ fn_v }}
                                    </span>
                                    <i class="fa fa-angle-right ml-1 mr-1"></i>
                                    <span>
                                        {{ fn }}
                                    </span>
                                </div>
                            </div>
                        </div>

                    </div>

                </div>

            </div>
        </div>
    </div>
</div>
</div>
<!-- /#mui_stat_details -->

</div>

</div>
<!-- /#main_ui -->
    
    <!-- the ui for toolkit -->
    <div v-show="section=='toolkit'" id="main_ui"
    class="main-ui container-fluid">
    <div class="w-100 d-flex flex-row p-1" 
        style="height: calc(100% + 10px);">

        <!-- Tool #1: MedTaggerVis -->
        <div v-if="toolkit_section == 'medtaggervis'"
    class="d-flex w-100 h-100">

    <div class="box h-100 border-rightx bd-gray mr-1 p-1"
        style="width: 250px;">
        <div class="box-header">
            <h4>
                <i class="fa fa-list-ul"></i>
                Raw .txt Files
            </h4>
        </div>

        <div class="box-body h-100"
            v-on:dragover="on_dragover_prevent_default"
            v-on:drop="tk_medtaggervis_on_drop_txt_files">
            <p v-if="tk_medtaggervis_is_loading_txt_files">
                Loading files ... <br>
                Please wait for a little while. <br>
                <i class="fas fa-spinner fa-spin"></i>
            </p>
            <p v-else-if="tk_medtaggervis_txt_files.length == 0">
                Drag and drop the <b>.txt</b> files or the folder in the following box
            </p>
            <p v-else>
                Loaded <b>{{ tk_medtaggervis_txt_files.length }} </b> text files (.txt).
            </p>
            
            <div v-if="tk_medtaggervis_txt_files.length == 0"
                class="dropfile-box w-100 d-flex flex-align-center flex-justify-center"
                style="height: calc(100% - 40px);">
                <span style="font-size: 1.2em;">
                    <b>.txt</b>
                    files / folder
                </span>
            </div>
            <div v-else class="w-100 h-100">
                <simple-item-list
                    name_attr="fn"
                    v-bind:readonly="true"
                    v-bind:items="tk_medtaggervis_txt_files"
                    v-bind:force_module_update="tk_medtaggervis_force_module_update"
                    v-bind:callback_on_click_item="tk_medtaggervis_on_click_txt_file">
                </simple-item-list>
            </div>
        </div>
    </div>
    <!-- /.box -->
    

    <div class="box h-100 border-rightx bd-gray mr-1 p-1"
        style="width: 250px;">
        <div class="box-header">
            <h4>
                <i class="fa fa-list-ul"></i>
                Output .ann Files
            </h4>
        </div>

        <div class="box-body h-100"
            v-on:dragover="on_dragover_prevent_default"
            v-on:drop="tk_medtaggervis_on_drop_ann_files">
            <p v-if="tk_medtaggervis_is_loading_ann_files">
                Loading files ... <br>
                Please wait for a little while. <br>
                <i class="fas fa-spinner fa-spin"></i>
            </p>
            <p v-else-if="tk_medtaggervis_ann_files.length == 0">
                Drag and drop the <b>.ann</b> files or the folder in the following box
            </p>
            <p v-else>
                Loaded <b>{{ tk_medtaggervis_ann_files.length }} </b> annotation files.
            </p>
            
            <div v-if="tk_medtaggervis_ann_files.length == 0"
                class="dropfile-box w-100 d-flex flex-align-center flex-justify-center"
                style="height: calc(100% - 40px);">
                <span style="font-size: 1.2em;">
                    <b>.ann</b>
                    files / folder
                </span>
            </div>
            <div v-else class="w-100 h-100">
                <simple-item-list
                    name_attr="fn"
                    v-bind:readonly="false"
                    v-bind:items="tk_medtaggervis_ann_files"
                    v-bind:force_module_update="tk_medtaggervis_force_module_update"
                    v-bind:callback_on_click_item="tk_medtaggervis_on_click_ann_file">
                </simple-item-list>
            </div>
        </div>
    </div>
    <!-- /.box -->

    <div class="box h-100 p-1"
        style="width: calc(100% - 500px);">
        <div class="box-header">
            <h4>
                <i class="fas fa-poll-h"></i>
                Visualization of Document and Tags
            </h4>
        </div>

        <div class="box-body w-100 h-100"
            style="overflow-x: hidden; overflow-y: auto;">
            <div id="tk_medtaggervis_brat_fig"
                style="width: calc(100% - 10px);">
            </div>
        </div>
    </div>
    <!-- /.box -->

</div>


        <!-- Tool #2: IOB2Editor -->
        <div v-if="toolkit_section == 'iob2editor'"
    class="d-flex w-100 h-100">

    <div class="box h-100 border-rightx bd-gray mr-1 p-1"
        style="width: 250px;">
        <div class="box-header">
            <h4>
                <i class="fa fa-list-ul"></i>
                IOB2/BIO Files
            </h4>
        </div>

        <div class="box-body h-100"
            v-on:dragover="on_dragover_prevent_default"
            v-on:drop="tk_iob2editor_on_drop_iob_files">
            <p v-if="tk_iob2editor_is_loading_iob_files">
                Loading files ... <br>
                Please wait for a little while. <br>
                <i class="fas fa-spinner fa-spin"></i>
            </p>
            <p v-else-if="tk_iob2editor_iob_files.length == 0">
                Drag and drop the IOB2/BIO files or the folder in the following box
            </p>
            <p v-else>
                Loaded <b>{{ tk_iob2editor_iob_files.length }} </b> files.
            </p>
            
            <div v-if="tk_iob2editor_iob_files.length == 0"
                class="dropfile-box w-100 d-flex flex-align-center flex-justify-center"
                style="height: calc(100% - 40px);">
                <span style="font-size: 1.2em;">
                    <b>IOB2/BIO</b>
                    files / folder
                </span>
            </div>
            <div v-else class="w-100 h-100">
                <simple-item-list
                    name_attr="fn"
                    v-bind:readonly="true"
                    v-bind:items="tk_iob2editor_iob_files"
                    v-bind:force_module_update="tk_iob2editor_force_module_update"
                    v-bind:callback_on_click_item="tk_iob2editor_on_click_iob_file">
                </simple-item-list>
            </div>
        </div>
    </div>
    <!-- /.box -->
    

    <div class="box h-100 p-1"
        style="width: calc(100% - 500px);">
        <div class="box-header">
            <h4>
                <i class="far fa-newspaper"></i>
                IOB2/BIO File Editor
            </h4>
        </div>

        <div class="box-body w-100 h-100"
            style="overflow-x: hidden; overflow-y: auto;">
            
        </div>
    </div>
    <!-- /.box -->

</div>
    </div>
</div>
    

    <!-- the context menu -->
    <div v-if="dtd != null"
        style="display: none;"
        id="ctxmenu_sel">
        <li class="ui-widget-header"
            v-on:click="close_ctxmenu">Entity Tags:</li>
        <li class="ctxmenu-item"
            v-for="etag, tag_idx in dtd.etags"
            v-on:click="add_etag_by_ctxmenu(etag)">
            <div v-bind:id="'ctxmenu-item-' + etag.name">
                <i v-bind:class="'fa fa-tag fg-tag-' + etag.name"></i>
                <span v-if="etag.hasOwnProperty('shortcut')"
                    class="badge-shortcut mr-1">
                    {{ etag.shortcut }}
                </span>
                <span>
                    {{ etag.name }}
                </span>
            </div>
        </li>
    </div>
    <div v-else
        id="ctxmenu_sel">

    </div>

    <!-- the context menu for non-consuming tags -->
    <div v-if="dtd != null && get_nc_etags().length > 0"
        style="display: none;"
        id="ctxmenu_nce">
        <li class="ui-widget-header"
            style="padding-right: 5px;"
            v-on:click="close_ctxmenu">Document-Level Tag</li>
        <li class="ctxmenu-item"
            v-for="etag, tag_idx in get_nc_etags()"
            v-on:click="add_nc_etag_by_ctxmenu(etag)">
            <div v-bind:id="'ctxmenu-item-' + etag.name">
                <i v-bind:class="'fa fa-tag fg-tag-' + etag.name"></i>
                <span v-if="etag.hasOwnProperty('shortcut')"
                    class="badge-shortcut mr-1">
                    {{ etag.shortcut }}
                </span>
                <span>
                    {{ etag.name }}
                </span>
            </div>
        </li>
    </div>
    <div v-else
        id="ctxmenu_nce">

    </div>

    <!-- the tag click menu -->
    <div v-if="dtd != null && get_clicked_tag()!=null"
        style="display: none;"
        id="popmenu_tag">
        <li class="ui-widget-header"
            v-on:click="close_popmenu">
            <i class="fa fa-tag"></i>
            <span>
                {{ get_clicked_tag()['tag'] }}
            </span>
            <span>
                <b>{{ clicked_tag_id }}</b>
            </span>
        </li>

        <div v-if="is_linking">
            <li v-for="att, att_idx in linking_atts"
                v-on:click="popmenu_set_linking(att_idx)"
                class="ctxmenu-item">
                <div>
                    <i class="fa fa-link"
                        v-bind:class="'fg-tag-' + linking_tag_def.name">
                    </i>
                    <b>{{ linking_tag_def.name }}</b>
                    -
                    <i>{{ att.name }}</i>
                </div>
            </li>

            <li class="ctxmenu-divider"></li>
            <li class="ctxmenu-item"
                v-on:click="cancel_linking()">
                <div>
                    <i class="far fa-times-circle"></i>
                    Cancel current linking
                </div>
            </li>
        </div>

        <div v-else>
            <li class="ctxmenu-item"
                v-for="rtag, rtag_idx in dtd.rtags"
                v-on:click="popmenu_start_linking(rtag)">
                <div>
                    <i class="fa fa-link"
                        v-bind:class="'fg-tag-' + rtag.name">
                    </i>
                    <b>{{ rtag.name }}</b>
                    -
                    <i>{{ get_idref_attr_by_seq(rtag).name }}</i>
                </div>
            </li>
        </div>

        <li class="ctxmenu-divider"></li>
        <li class="ctxmenu-item"
            v-on:click="popmenu_del_tag()">
            <div>
                <i class="far fa-trash-alt"></i>
                Delete this tag
            </div>
        </li>
    </div>
    <div v-else
        id="popmenu_tag">

    </div>

    <div id="hoverbox_etag"
        v-show="hovered_tag != null">

        <div v-if="hovered_tag != null">
            <div>
                <span v-if="hovered_tag.hasOwnProperty('_annotator')"
                    v-bind:class="'iaa-annotator-' + hovered_tag._annotator">
                    <i class="fa fa-user"></i>
                    {{ hovered_tag._annotator }}
                </span>
                
                <i class="fa fa-tag" v-bind:class="'fg-tag-' + hovered_tag.tag"></i>
                {{ hovered_tag.tag }}.{{ hovered_tag.id }} {{ hovered_tag.spans }} 
            </div>
            
            <div v-html="get_tag_desc_html(hovered_tag)">
            </div>
        </div>
    </div>

    <div v-show="show_text_quick_viewer"
        v-bind:style="{top: tqv_pos_y + 'px', left: tqv_pos_x + 'px'}"
        v-on:drag="on_drag_tqv"
        class="tq-viewer-box">
        <div class="tq-viewer-header">
            <span class="mr-2 cursor-pointer"
                title="Close quick viewer"
                v-on:click="hide_tqv">
                <i class="fas fa-times"></i>
            </span>
            <i class="fas fa-paragraph"></i>
            <span class="ml-1">
                {{ tqv_header }}
            </span>
        </div>
        <!-- <div class="tq-viewer-oper">

        </div> -->
        <textarea class="tq-viewer-content" 
            readonly
            v-bind:value="tqv_content"></textarea>
        <div class="tq-viewer-footer">
            <span class="mr-1">
                {{ tqv_footer }}
            </span>
        </div>
    </div>

    <!-- Schema Editor -->
    <div id="schema_editor"
    data-cls-window="schema-editor pop-window"
    class="p-2" 
    data-draggable="true"
    data-btn-min="false"
    data-btn-max="false"
    data-btn-close="false"
    data-shadow="true"
    data-height="600px"
    data-top="10px"
    data-left="55px"
    data-title="&nbsp;&nbsp;<i class='fa fa-edit'></i> Schema Editor"
    data-cls-caption="bg-light fg-black"
    data-role="window" >

    <div>
        <div id="schema_editor_menu"
            class="window-menu pb-2 mb-2 d-flex flex-row">

            <div v-if="se_dtd != null"
                class="mr-1">
                <span class="se-input-field-legend">
                    SCHEMA NAME
                </span>
                <input type="text" 
                    style="width: 150px; height: 30px;"
                    class=""
                    v-on:keypress="on_keypress_se_dtd_input($event)"
                    v-model="se_dtd.name">
            </div>
            <div v-else
                class="mr-1">

            </div>
            
            <ul class="h-menu horizontal">
                <li class="mr-1">
                    <button class="button se-button"
                        title="Create a new annotation schema"
                        v-on:click="create_new_se_dtd">
                        <i class="far fa-file"></i>
                        New
                    </button>
                </li>

                <li class="mr-1">
                    <button class="button se-button"
                        title="Open local annotation schema"
                        v-on:click="open_se_dtd">
                        <i class="far fa-folder-open"></i>
                        Open
                    </button>
                </li>

                <li class="mr-1 se-menu-sep-line border-right bd-gray">&nbsp;</li>

                <li>
                    <select style="width: 120px; height: 30px; line-height: 30px;"
                        v-model="se_dtd_tpl_id">
                        <optgroup label="Sample 1: Simple Tasks">
                            <option value="MINIMAL_TASK">1.1 Minimal Task</option>
                            <option value="ENTITY_RELATION_TASK">1.2 Two Entities and One Relation</option>
                            <option value="IAA_TASK">1.3 Nine Entities and One Relation</option>
                            <option value="DOCUMENT_LEVEL_TASK">1.4 Eleven Entities for Document-Level Annotation</option>
                        </optgroup>
                    
                        <!-- <optgroup label="Sample 2: Large Tasks">
                            <option value="s-2-1">2.1 COVID-19 Symptoms (8E)</option>
                            <option value="s-2-2">2.2 COVID-19 Vaccine Adverse Events (9E1R)</option>
                            <option value="s-2-3">2.3 Symptoms of long COVID (10E)</option>
                        </optgroup> -->
                    </select>
                </li>

                <li class="mr-1">
                    <button class="button se-button"
                        title="Load the selected sample schema"
                        v-on:click="load_se_dtd_sample">
                        <i class="far fa-folder-open"></i>
                        Load
                    </button>
                </li>

                <li class="mr-1 se-menu-sep-line border-right bd-gray">&nbsp;</li>
                
                <li v-if="se_dtd != null" 
                    class="mr-1">
                    <button class="button se-button"
                        title="Use this schema for annotation"
                        v-on:click="use_se_dtd_for_annotation(se_dtd)">
                        <span class="mif-rocket icon"></span>
                        Use
                    </button>
                </li>

                <li v-if="se_dtd != null" 
                    class="split-button mr-1"
                    style="height: 30px;">
                    <button class="button se-button"
                        title="Download current schema file as a YAML format file"
                        v-on:click="download_se_dtd(se_dtd)">
                        <span class="mif-download icon"></span>
                        Download
                    </button>
                    <button class="split dropdown-toggle se-button" style="width: 0; min-width: 0;"></button>
                    <ul class="d-menu" data-role="dropdown">
                        <li v-on:click="download_se_dtd_as_yaml(se_dtd)">
                            <a class="se-button" href="javascript:void(0);">
                                <i class="fas fa-file-download"></i>
                                Download as YAML
                            </a>
                        </li>
                        <li v-on:click="download_se_dtd_as_json(se_dtd)">
                            <a class="se-button" href="javascript:void(0);">
                                <i class="fas fa-file-download"></i>
                                Download as JSON
                            </a>
                        </li>
                        <li v-on:click="download_se_dtd_as_dtd(se_dtd)">
                            <a class="se-button" href="javascript:void(0);">
                                <i class="fas fa-file-download"></i>
                                Download as DTD
                            </a>
                        </li>
                    </ul>
                </li>

                <li class="mr-1">
                    <button class="button se-button"
                        title="Show how to use schema editor"
                        v-on:click="show_se_help">
                        <i class="far fa-question-circle"></i>
                        Help
                    </button>
                </li>
                
                <li class="mr-1 se-menu-sep-line border-right bd-gray">&nbsp;</li>
                
                <li class="mr-1"
                    title="Close schema editor"
                    v-on:click="close_schema_editor">
                    <a href="javascript:void(0);">
                        <span class="mif-cross icon"></span>
                        <span class="caption">Close</span>
                    </a>
                </li>

            </ul>
        </div>

        <div v-if="se_dtd != null"
            class="w-100">
            <div class="d-flex flex-row">
                

            </div>

            <div class="d-flex flex-column">
                <div v-for="tags, idx in [se_dtd.etags, se_dtd.rtags]"
                    class="d-flex flex-column mb-4">
                    <h5 class="mt-0 mb-2 pt-2 pb-2 bg-light">
                        <span v-if="idx == 0">
                            <i class="fa fa-tags"></i>
                            ENTITY TAGS - 
                        </span>
                        <span v-else>
                            <i class="fa fa-link"></i>
                            RELATION TAGS -
                        </span>
                        <span class="txt-sm">
                            {{ tags.length }} tag(s)
                        </span>
                        |
                        <a class="se-btn-link mr-2"
                            v-on:click="add_se_dtd_tag(se_dtd, idx)">
                            <i class="fa fa-plus"></i>
                            Tag
                        </a>
                    </h5>
                    <div v-for="tag_def, tag_idx in tags"
                        class="se-tag-row d-flex flex-row pt-3 pb-2 border-bottom bd-gray">
                        <div class="se-tag-name mr-4 d-flex flex-column flex-align-end">
                            <div class="mb-1 p-1 d-flex flex-row">
                                <span class="se-input-field-legend">
                                    TAG NAME
                                </span>
                                <input type="text"
                                    class="se-input-tag-name mr-1"
                                    v-on:keypress="on_keypress_se_dtd_input($event)"
                                    v-model="tag_def.name">
                                
                                <a class="se-btn-link se-tag-attr-del"
                                    title="Delete this tag"
                                    v-on:click="remove_se_dtd_tag(se_dtd, tag_def, idx, tag_idx)">
                                    <i class="fa fa-minus"></i>
                                </a>
                            </div>
                            
                            <div class="d-flex flex-row pr-1">
                                <div>
                                    <div v-if="idx==0" class="mr-1">
                                        <span class="se-input-field-legend">
                                            ANN.TYPE
                                        </span>
                                        <select v-model="tag_def.is_non_consuming"
                                            title="The tag can be assigned to a whole document for document-level annotation task. Otherwise just span-based annotation."
                                            class="se-select-att-type">
                                            <option :value="true">
                                                DOCUMENT + SPAN
                                            </option>
                                            <option :value="false">
                                                SPAN
                                            </option>
                                        </select>
                                    </div>
                                </div>

                                <div>
                                    <a class="se-btn-link"
                                        v-on:click="add_se_dtd_tag_attr(se_dtd, tag_def)"
                                        v-bind:title="'Add new attribute to this [' + tag_def.name + ']'">
                                        <i class="fa fa-plus"></i>
                                        Attr
                                    </a>
                                </div>
                            </div>

                        </div>
                        <div class="d-flex flex-row flex-wrap">

                            <div v-for="att, att_idx in tag_def.attrs"
                                v-show="att.vtype != 'dfix'"
                                class="se-tag-attr-cell mr-2 mb-2 p-1">
                                <div class="mb-2 d-flex flex-row">
                                    <span class="se-input-field-legend">
                                        ATTRIBUTE
                                    </span>
                                    <input type="text"
                                        class="se-input-att-name"
                                        v-on:keypress="on_keypress_se_dtd_input($event)"
                                        v-model="att.name">

                                    <a class="se-btn-link se-tag-attr-del"
                                        title="Remove this attribute"
                                        v-on:click="remove_se_dtd_tag_attr(se_dtd, tag_def, att, idx, tag_idx, att_idx)">
                                        <i class="fa fa-minus"></i>
                                    </a>
                                </div>

                                <div class="d-flex flex-row">
                                    <div class="mr-1">
                                        <span class="se-input-field-legend">
                                            TYPE
                                        </span>
                                        <select v-model="att.vtype"
                                            class="se-select-att-type">
                                            <option value="text">
                                                TEXT
                                            </option>
                                            <option value="list">
                                                LIST
                                            </option>
                                            <option v-if="idx==1" value="idref">
                                                LINK
                                            </option>
                                        </select>
                                    </div>

                                    <div v-if="att.vtype == 'text'">
                                        <span class="se-input-field-legend">
                                            DEFAULT
                                        </span>
                                        <input type="text"
                                            title="The default value for"
                                            class="se-input-att-value"
                                            v-model="att.default_value">
                                    </div>
                                    <div v-else-if="att.vtype == 'list'"
                                        class="d-flex flex-row">
                                        <div class="mr-1">
                                            <span class="se-input-field-legend">
                                                DEFAULT
                                            </span>
                                            <select v-model="att.default_value"
                                                title="The default item for this attribute"
                                                class="se-select-att-value">
                                                <option v-for="att_opt_val in att.values"
                                                    v-bind:value="att_opt_val">
                                                    {{ att_opt_val }}
                                                </option>
                                            </select>
                                        </div>
                                        <div>
                                            <span class="se-input-field-legend">
                                                ITEMS ({{ att.values.length }})
                                            </span>
                                            <input type="text"
                                                class="se-input-att-list-values"
                                                readonly
                                                title="Click to edit the item list"
                                                v-on:click="show_att_list_editor(att)"
                                                v-bind:value="att.values.join('|')">
                                        </div>
                                    </div>
                                </div>
                            </div>

                        </div>
                    </div>
                </div>

            </div>
        </div>
        <div v-else>
            <p>
                You can click the "New" button to create an empty annotation schema.
                <br>
                Or click the "Open" button to open an existing schema file to edit.
            </p>
            <p>
                Once the schema design is finished, you can download it as a DTD format file for backup, or use it directly in annotation.
                <br>
                The specification of the annotation schema file can be found in <a href="https://github.com/OHNLP/MedTator/wiki/Annotation-Schema">MedTator Wiki</a>.
            </p>
            <p>
                For more schema samples, you can check <a target="_blank" href="https://github.com/OHNLP/MedTator/tree/main/sample">MedTator sample schemas on GitHub repo</a>.
            </p>

        </div>
    </div>
    
</div>

    <!-- Annotation Viewer based on brat -->
    <div id="annviewer_bratvis"
    data-cls-window="annviewer-bratvis pop-window"
    class="p-2" 
    data-draggable="true"
    data-btn-min="false"
    data-btn-max="false"
    data-btn-close="false"
    data-shadow="true"
    data-height="600px"
    data-top="10px"
    data-left="55px"
    data-title="&nbsp;&nbsp;<i class='fas fa-igloo'></i> Annotation Viewer (Powered by <a target='_blank' href='https://brat.nlplab.org/'>brat</a>)"
    data-cls-caption="bg-light fg-black"
    data-role="window">

    <div id="annviewer_bratvis_menu"
        class="window-menu pb-2 mb-2 d-flex flex-row">
        
        <ul class="h-menu horizontal">

            <li class="mr-1">
                <button class="button se-button"
                    title="Refresh the figure"
                    v-on:click="show_avbrat()">
                    <i class="fas fa-sync-alt"></i>
                    Refresh Figure
                </button>
            </li>

            <li class="mr-1 se-menu-sep-line border-right bd-gray">&nbsp;</li>

            <!-- <li class="mr-1">
                <button class="button se-button"
                    title="Create a new annotation schema"
                    v-on:click="export_avbrat_figure()">
                    <i class="far fa-file-image"></i>
                    Export Figure as PNG
                </button>
            </li> -->

            <li class="mr-1">
                <button class="button se-button"
                    title="Show how to use annotation viewer"
                    v-on:click="show_avbrat_help">
                    <i class="far fa-question-circle"></i>
                    Help
                </button>
            </li>
            
            <li class="mr-1 se-menu-sep-line border-right bd-gray">&nbsp;</li>
            
            <li class="mr-1"
                title="Close annotation viewer"
                v-on:click="close_avbrat">
                <a href="javascript:void(0);">
                    <span class="mif-cross icon"></span>
                    <span class="caption">Close</span>
                </a>
            </li>

        </ul>
    </div>

    <div class="w-100">
        <p v-if="avbrat_is_rendering">
            <i class="fas fa-spinner fa-spin"></i>
            Visualizing the annotations ...
        </p>

        <div id="fig_bratvis">

        </div>
    </div>
        
</div>

</div>

<script>
function get_browser() {
    var ua = navigator.userAgent,tem,M=ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || []; 
    if(/trident/i.test(M[1])){
        tem=/\brv[ :]+(\d+)/g.exec(ua) || []; 
        return {name:'IE',version:(tem[1]||'')};
        }   
    if(M[1]==='Chrome'){
        tem=ua.match(/\bOPR|Edge\/(\d+)/)
        if(tem!=null)   {return {name:'Opera', version:tem[1]};}
        }   
    M=M[2]? [M[1], M[2]]: [navigator.appName, navigator.appVersion, '-?'];
    if((tem=ua.match(/version\/(\d+)/i))!=null) {M.splice(1,1,tem[1]);}
    return {
      name: M[0],
      version: M[1]
    };
}
var _browser = get_browser();

var isIE = /*@cc_on!@*/false || !!document.documentMode;
var isCHROME = _browser.name == 'Chrome';
var isSAFARI = _browser.name == 'Safari';
var isFIREFOX = _browser.name == 'Firefox';
// var isCB_BRAVE = (navigator.brave && await navigator.brave.isBrave() || false);
var isCB_BRAVE = typeof(navigator.brave) != 'undefined';
if (isCB_BRAVE) {
    _browser.name = 'Brave';
}
// for HTTPS check
var isHTTPS = window.location.protocol == 'https:';
var isLOCALFILE = window.location.protocol == 'file:';
var isLOCALHOST = !window.location.host.replace(/(localhost|127\.0\.0\.1)(:\d+)?/i, "");

// the file system access api
var isFSA_API_OK = typeof(window.showOpenFilePicker) == 'function';

console.log("* Browser:", _browser);
console.log('* isHTTPS: ' + isHTTPS);
console.log('* isLOCALFILE: ' + isLOCALFILE);
console.log('* isLOCALHOST: ' + isLOCALHOST);
console.log('* isIE: ' + isIE);
console.log('* isCHROME: ' + isCHROME);
console.log('* isSAFARI: ' + isSAFARI);
console.log('* isFIREFOX: ' + isFIREFOX);
console.log('* isCB_BRAVE: ' + isCB_BRAVE);
console.log('* isFSA_API_OK: ' + isFSA_API_OK);

var _NOT_SUPPORT_MSG = 'The visualization and annotation features require advanced web techniques, which are <b>NOT</b> supported by the web browser you are using.<br>'+
'Try using latest <a target="_blank" href="https://www.google.com/chrome/">Google Chrome</a> or other <a target="_blank" href="https://download-chromium.appspot.com/">Chromium</a> based browsers (e.g., <a target="_blank" href="https://www.microsoft.com/en-us/edge">Microsoft Edge</a>, <a target="_blank" href="https://vivaldi.com/">Vivaldi</a>) to get full supports.';

var _LMT_SUPPORT_MSG = 'The <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API">File System Access APIs</a> require latest HTML5 techniques, which are <b>NOT</b> supported by the web browser [' + _browser.name + '] you are using. <br>' +
'Try using the latest <a target="_blank" href="https://www.google.com/chrome/">Google Chrome</a> or other <a target="_blank" href="https://download-chromium.appspot.com/">Chromium</a> based browsers (e.g., <a target="_blank" href="https://www.microsoft.com/en-us/edge">Microsoft Edge</a>, <a target="_blank" href="https://vivaldi.com/">Vivaldi</a>) to get full supports.<br> '+
'Except for the file saving limitation, you can use all other functions.<br>' +
'<a style="font-size:1.5em;" href="javascript:void(0);" onclick="jarvis.ssclose()">Continue to use <i class="fa fa-arrow-alt-circle-right"></i></a>';

var _DISABLED_API_MSG = 'The <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API">File System Access APIs</a> are <b>NOT</b> enabled by your current web browser [' + _browser.name + '] you are using. <br>' +
'Try using the latest <a target="_blank" href="https://www.google.com/chrome/">Google Chrome</a> or enabling the File System Access API. <br> '+
'We provide a tutorial about how to enable the API in some browsers in <a href="https://github.com/OHNLP/MedTator/wiki/FQA#enable-file-system-access-api">the MedTator Wiki</a>.<br>' +
'<a style="font-size:1.5em;" href="javascript:void(0);" onclick="jarvis.ssclose()">Continue to use <i class="fa fa-arrow-alt-circle-right"></i></a>';

var _SEC_LMT_MSG = 'The <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API">File System Access APIs</a> are available only in secure contexts (HTTPs) or localhost server for accessing your local files. <br>' +
'Try adding SSL to your web server or hosting MedTator on a web server with SSL certification. <br> '+
'We provide a tutorial about how to solve this issue in <a href="https://github.com/OHNLP/MedTator/wiki/FQA#https">the MedTator Wiki</a>.<br>' +
'<a style="font-size:1.5em;" href="javascript:void(0);" onclick="jarvis.ssclose()">Continue to use <i class="fa fa-arrow-alt-circle-right"></i></a>';

</script>
<!-- metro ui -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/metro/4.3.5/js/metro.min.js"></script>
<!-- jQuery first, then Popper.js, then Bootstrap JS -->
<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>
<!-- jQuery AjaxQueue -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-ajaxQueue/0.1.1/jquery.ajaxQueue.min.js"></script>
<!-- jQuery UI -->
<script src="https://code.jquery.com/ui/1.12.0/jquery-ui.min.js"></script>
<!-- Vue.js -->
<script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script>
<!-- jszip -->
<script src="https://stuk.github.io/jszip/dist/jszip.js"></script>
<!-- filesaver -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.0/FileSaver.min.js"></script>
<!-- dayjs -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/dayjs/1.8.36/dayjs.min.js"></script>
<!-- code mirror -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.0/codemirror.min.js"></script>
<!-- code mirror addon -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.0/addon/selection/active-line.min.js"></script>
<!-- code mirror addon for line jump -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.0/addon/dialog/dialog.min.js"></script>
<!-- code mirror addon for dialog display -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.0/addon/dialog/dialog.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.0/addon/search/search.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.0/addon/search/searchcursor.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.0/addon/search/matchesonscrollbar.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.0/addon/scroll/annotatescrollbar.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.0/addon/search/jump-to-line.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.0/addon/dialog/dialog.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.0/addon/search/matchesonscrollbar.min.css">
<!-- numjs -->
<!-- <script src="https://cdn.jsdelivr.net/gh/nicolaspanel/numjs@0.15.1/dist/numjs.min.js"></script> -->
<!-- compromise -->
<!-- <script src="https://unpkg.com/compromise"></script> -->
<!-- chart.js -->
<!-- <script src="https://cdn.jsdelivr.net/npm/chart.js"></script> -->
<!-- math.js for calcuation -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.0.1/math.min.js"></script>
<!-- PapaParse -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.1/papaparse.min.js"></script>
<!-- Shepherd -->
<script src="https://cdn.jsdelivr.net/npm/shepherd.js@8.3.1/dist/js/shepherd.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/shepherd.js@8.3.1/dist/css/shepherd.css">
<!-- wink-nlp customized bundle -->
<script src="./static/lib/wink-nlp/bundle-1.8.0.min.js"></script>
<!-- dataset spliter -->
<script src="./static/lib/ds-spliter/ds-spliter-1.0.0.min.js"></script>
<!-- format xml -->
<script src="https://cdn.jsdelivr.net/npm/xml-formatter@2.4.0/dist/browser/xml-formatter.js"></script>
<!-- export xlsx -->
<script src="https://unpkg.com/xlsx@0.17.4/dist/shim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.mini.min.js"></script>
<!-- xlsx style -->
<script src="https://cdn.jsdelivr.net/npm/xlsx-js-style@1.0.0/dist/xlsx.bundle.js"></script>
<!-- d3 for data visualization -->
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<!-- d3-sankey for data visualization -->
<script src="https://cdn.jsdelivr.net/npm/d3-sankey@0.12.3/dist/d3-sankey.min.js"></script>
<!-- echarts for data visualization -->
<script src="https://cdn.jsdelivr.net/npm/echarts@5.3.3/dist/echarts.min.js"></script>
<!-- dump/parse YAML library -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"></script>
<!-- head.js for brat -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/headjs/1.0.3/head.load.min.js"></script>
<!-- style for brat visualization -->
<link rel="stylesheet" href="./static/lib/brat/css/style-vis.css">
<!-- save svg as png for downloading figure -->
<!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/save-svg-as-png/1.4.17/saveSvgAsPng.min.js"></script> -->


<script>
// The file helper 
///////////////////////////////////////////////////////////
// General purpose fs functions
///////////////////////////////////////////////////////////

async function fs_open_files(pickerOpts) {
    const fhs = await window.showOpenFilePicker(pickerOpts);
    return fhs;
}

async function fs_get_file_system_handles_by_fhs(fhs, filter) {
    if (typeof(filter) == 'undefined') {
        filter = function(fn) {
            return true;
        }
    }
    // the final fshs
    var fshs = [];

    for (let i = 0; i < fhs.length; i++) {
        const fh = fhs[i];
        
        if (fh.kind == 'file') {
            if (!filter(fh.name)) {
                continue;
            }
            fshs.push(fh);

        } else if (fh.kind == 'directory') {
            for await (const sub_fsh of fh.values()) {
                if (sub_fsh.kind != 'file') {
                    continue;
                }
        
                // exclude hidden file
                if (sub_fsh.name.startsWith('.')) {
                    continue;
                }

                // exclude other files
                if (!filter(sub_fsh.name)) {
                    continue;
                }

                // ok, put this sub_fsh
                fshs.push(sub_fsh);
            }
        }
    }
    console.log('* got ' + fshs.length + ' file_system_handles');

    return fshs;
}

async function fs_get_file_texts_by_fhs(fhs, filter) {
    if (typeof(filter) == 'undefined') {
        filter = function(fn) {
            return true;
        }
    }
    // the items is the event.dataTransfer.items
    const fshs = await fs_get_file_system_handles_by_fhs(fhs, filter);

    var files = [];

    for await (const file of fshs.map(fh=>fs_read_file_system_handle(fh))) {
        files.push(file);
    }
    // console.log(files);
    
    console.log('* has read ' + files.length + ' files');
    return files;
}

async function fs_get_file_system_handles_by_items(items, filter) {
    if (typeof(filter) == 'undefined') {
        filter = function(fn) {
            return true;
        }
    }
    // the items is the event.dataTransfer.items
    var fshs = [];

    // items is not an Array list, so have to loop it
    var p_fshs = [];
    for (let i=0; i<items.length; i++) {
        // get this item as a FileSystemHandle Object
        // the getAsFileSystemHandle returns a Promise
        const p_fsh = items[i].getAsFileSystemHandle();
        p_fshs.push(p_fsh);
    }
    console.log('* got ' + p_fshs.length + ' promises of file_system_handles');

    // in this way, we can get all of the items
    // including files and directories
    for await (const fsh of p_fshs) {
        if (fsh.kind == 'file') {
            if (!filter(fsh.name)) {
                continue;
            }
            fshs.push(fsh);

        } else if (fsh.kind == 'directory') {
            for await (const sub_fsh of fsh.values()) {
                if (sub_fsh.kind != 'file') {
                    continue;
                }
        
                // exclude hidden file
                if (sub_fsh.name.startsWith('.')) {
                    continue;
                }

                // exclude other files
                if (!filter(sub_fsh.name)) {
                    continue;
                }

                // ok, put this sub_fsh
                fshs.push(sub_fsh);
            }
        }
    }
    console.log('* got ' + fshs.length + ' file_system_handles');
    
    return fshs;
}

async function fs_get_file_texts_by_items(items, filter) {
    if (typeof(filter) == 'undefined') {
        filter = function(fn) {
            return true;
        }
    }
    // the items is the event.dataTransfer.items
    const fshs = await fs_get_file_system_handles_by_items(items, filter);

    var files = [];

    for await (const file of fshs.map(fh=>fs_read_file_system_handle(fh))) {
        files.push(file);
    }
    // console.log(files);
    
    console.log('* has read ' + files.length + ' files');
    return files;
}

async function fs_read_file_system_handle(fh) {
    // get the file obj
    const file = await fh.getFile();

    // console.log('* read fsh', file);
    
    // get the text content
    const text = await file.text();

    // return the content and fh
    return {
        fh: fh,
        fn: fh.name,
        has_saved: true,
        timestamp: file.lastModified,
        text: text
    };
}

async function fs_write_file_system_handle(fh, content) {
    const writable = await fh.createWritable();
    
    // write the contents
    await writable.write(content);

    // close the file
    await writable.close();

    return fh;
}

/**
 * Save the given customized file
 * 
 * @param {Object} file the customized file object with text
 * @returns updated file object
 */
async function fs_save_file(file) {

    // write to fh!
    await fs_write_file_system_handle(file.fh, file.text);

    // done!
    file.has_saved = true

    return file;
}


///////////////////////////////////////////////////////////
// Customized functions of read/write for annotation
///////////////////////////////////////////////////////////

async function fs_read_dtd_file_handle(fh) {
    const file = await fh.getFile();
    const text = await file.text();

    // get the format
    var format = 'dtd';

    if (fh.name.toLowerCase().endsWith('.dtd')) {
        format = 'dtd';
    } else if (fh.name.toLowerCase().endsWith('.json')) {
        format = 'json';
    } else if (fh.name.toLowerCase().endsWith('.yaml')) {
        format = 'yaml'
    } else if (fh.name.toLowerCase().endsWith('.yml')) {
        format = 'yaml'
    } else {
        // ??? what can it be?
    }

    // create dtd
    var dtd = dtd_parser.parse(text, format);

    return dtd;
}

async function fs_get_new_ann_file_handle(fn) {
    const options = {
    suggestedName: fn,
      types: [
        {
          description: 'Text Files',
          accept: {
            'text/xml': ['.xml'],
          },
        },
      ],
    };
    const handle = await window.showSaveFilePicker(options);
    return handle;
}

async function fs_save_new_ann_file(ann, dtd) {
    // create a new fh by the suggested ann filename
    const fh = await fs_get_new_ann_file_handle(ann._filename);

    // update the filename according to fh
    ann._fh = fh;
    ann._filename = fh.name;

    // create the xml content for writing to file
    var xmlDoc = ann_parser.ann2xml(ann, dtd);
    const content = ann_parser.xml2str(xmlDoc, false);

    // write to fh!
    await fs_write_file_system_handle(ann._fh, content);

    // done!
    ann._has_saved = true

    return ann;
}

async function fs_save_ann_file(ann, dtd) {
    // create the xml content for writing to file
    var xmlDoc = ann_parser.ann2xml(ann, dtd);
    const content = ann_parser.xml2str(xmlDoc, false);

    // write to fh!
    await fs_write_file_system_handle(ann._fh, content);

    // done!
    ann._has_saved = true

    return ann;
}



///////////////////////////////////////////////////////////
// I think these functions won't be used
///////////////////////////////////////////////////////////

async function fs_read_dir_handle(fh, filter) {
    if (typeof(filter) == 'undefined') {
        filter = function(fn) {
            return true;
        }
    }
    var files = [];
    for await (const entry of fh.values()) {
        // Each entry is an instance of FileSystemFileHandle 
        // FileSystemFileHandle {kind: 'file', name: 'doc_04.txt'} 
        // console.log(entry);
        if (entry.kind != 'file') {
            console.log('* skip sub folder', entry.name);
            continue;
        }

        // exclude hidden file
        if (entry.name.startsWith('.')) {
            continue;
        }

        // exclude other files
        if (!filter(entry.name)) {
            continue;
        }

        const fobj = await fs_read_file_system_handle(entry);
        files.push(fobj)
    }
    console.log('* found ', files.length, 'files in', fh.name);
    // console.log('* files:', files);
    return files;
}

async function fs_read_ann_dir_handle(fh, dtd) {
    for await (const entry of fh.values()) {
        // Each entry is an instance of FileSystemFileHandle 
        // FileSystemFileHandle {kind: 'file', name: 'doc_04.txt'} 
        // console.log(entry);
        if (entry.kind != 'file') {
            console.log('* skip sub folder', entry.name);
            continue;
        }

        // skip hidden files
        if (entry.name.startsWith('.')) {
            continue;
        }

        // call the app_hotpot to parse and decide this fh
        app_hotpot.parse_ann_file_fh(
            entry, 
            dtd
        );
        app_hotpot.test_count += 1;
        // console.log('* app_hotpot.test_count:', app_hotpot.test_count, entry.name);
    }
}

async function fs_read_txt_file_handle(fh, dtd) {
    if (typeof(dtd) == 'undefined') {
        dtd = {name: ''};
    }
    // if (typeof(enabled_sentences) == 'undefined') {
    //     enabled_sentences = false;
    // }
    const file = await fh.getFile();
    const text = await file.text();

    // create ann
    var ann = ann_parser.txt2ann(text, dtd);

    // bind the fh
    ann._fh = fh;

    // bind the filename seperately
    ann._filename = fh.name;

    // bind a status
    ann._has_saved = true;

    // bind the sentences variable
    ann._sentences = [];
    ann._sentences_text = '';
    // if (enabled_sentences) {
    //     var result = nlp_toolkit.sent_tokenize(ann.text);
    //     ann._sentences = result.sentences;
    //     ann._sentences_text = result.sentences_text;
    // } else {
    //     ann._sentences = null;
    //     ann._sentences_text = null;
    // }

    return ann;
}

async function fs_read_ann_file_handle(fh, dtd) {
    // if (typeof(enabled_sentences) == 'undefined') {
    //     enabled_sentences = true;
    // }
    const file = await fh.getFile();
    const text = await file.text();

    // create ann
    var ann = ann_parser.xml2ann(text, dtd);

    // bind the fh
    ann._fh = fh;

    // bind the filename seperately
    ann._filename = fh.name;

    // bind a status
    ann._has_saved = true;

    // bind the sentences
    ann._sentences = null;
    ann._sentences_text = null;
    // if (enabled_sentences) {
    //     var result = nlp_toolkit.sent_tokenize(ann.text);
    //     ann._sentences = result.sentences;
    //     ann._sentences_text = result.sentences_text;
    // } else {
    //     ann._sentences = null;
    //     ann._sentences_text = null;
    // }

    return ann;
}

// The DTD parser
/**
 * Annotation schema file parser
 */
var dtd_parser = {
    regex: {
        entity: /\<\!ENTITY\ name\ "([a-zA-Z\-0-9\_]+)"\>/gmi,
        element: /^\<\!ELEMENT\s+([a-zA-Z\-0-9\_]+)\s.+/gmi,
        attr: /^\<\!ATTLIST\s+([a-zA-Z\-0-9\_]+)\s+([a-zA-Z0-9\_]+)\s+(\S+)\s/gmi,
        attr_values: /\(([a-zA-Z0-9\_\ \|\-]+)\)/gmi,
        attr_require: /#([A-Z]+)+(\b["a-zA-Z0-9\-\_\ ]+|\>)/gm,
        attr_prefix: /prefix="([a-zA-Z0-9\_]+)"/gm,
        // attr_cdata_default_value: /(?<=").*?(?=")/gm
        attr_cdata_default_value: /\s+\"(.*)\"/g
    },

    NON_CONSUMING_SPANS: '-1~-1',

    /**
     * Stringify a dtd object into text
     * @param {Object} dtd DTD schema
     */
    stringify: function(dtd, format) {
        if (typeof(format) == 'undefined') {
            format = 'dtd';
        }

        if (format == 'dtd') {
            return this.stringify_dtd(dtd);
        } else if (format == 'json') {
            return this.stringify_json(dtd);
        } else if (format == 'yaml') {
            return this.stringify_yaml(dtd);
        } else {
            return this.stringify_dtd(dtd);
        }
    },

    stringify_dtd: function(dtd) {
        // for the given dtd, convert to strings
        var txt = [];

        // output the dtd name
        txt.push(
            '<!ENTITY name "'+dtd.name+'">'
        );

        // just an empty line for break
        txt.push('');

        // check 
        for (let _t = 0; _t < 2; _t++) {
            var tags = {
                0: dtd.etags,
                1: dtd.rtags
            }[_t];

            for (let i = 0; i < tags.length; i++) {
                const tag = tags[i];

                // for counting the number of IDREF attrs
                var n_lk_att = 0;
                
                // a comment for users
                if (_t == 0) {
                    txt.push('<!-- entity concept [' + tag.name + '] -->');
    
                    // the tag name
                    txt.push('<!ELEMENT ' + tag.name + ' ( #PCDATA ) >')
        
                    // the non-comsuming attr
                    if (tag.is_non_consuming) {
                        txt.push('<!ATTLIST ' + tag.name + ' spans #IMPLIED >')
                    }
                } else {
                    txt.push('<!-- relation concept [' + tag.name + '] -->');
    
                    // the tag name
                    txt.push('<!ELEMENT ' + tag.name + ' EMPTY >')
                }
    
                // check each attr
                for (let j = 0; j < tag.attrs.length; j++) {
                    const att = tag.attrs[j];
                    
                    var att_req = '#IMPLIED'
                    if (att.require == 'REQUIRED') {
                        att_req = '#REQUIRED'
                    }

                    if (att.vtype == 'text') {
                        txt.push('<!ATTLIST ' + tag.name + ' ' + att.name + ' ' + att_req + ' "' + att.default_value + '" >');
                    } 
                    else if (att.vtype == 'list') {
                        var att_vals = att.values.join('|');
                        txt.push('<!ATTLIST ' + tag.name + ' ' + att.name + ' ( '+att_vals+' ) ' + att_req + ' "' + att.default_value + '" >');
                    } 
                    else if (att.vtype == 'idref') {
                        var argN = 'arg' + n_lk_att;
                        txt.push('<!ATTLIST ' + tag.name + ' ' + argN + ' IDREF prefix="' + att.name + '" ' + att_req + ' >');

                        // increase the argN number
                        n_lk_att += 1;
                    }
                }
    
                // just an empty line for break
                txt.push('');
            }
        }

        return txt.join('\n');
    },

    minimize_dtd_json: function(dtd) {
        var j = JSON.parse(JSON.stringify(dtd));

        // remove some attrs
        delete j['id_prefix_dict'];
        delete j['tag_dict'];
        delete j['text'];

        // make sure the meta is saved

        // remove some attrs in etags
        for (let i = 0; i < j.etags.length; i++) {
            delete j.etags[i]['attr_dict'];
            delete j.etags[i]['shortcut'];
            delete j.etags[i]['style'];
            delete j.etags[i]['type'];
            delete j.etags[i]['id_prefix'];

            if (j.etags[i]['is_non_consuming']) {
                // which means this is a document-level tag
            } else {
                delete j.etags[i]['is_non_consuming'];
            }

            // remove some attrs in attrs
            for (let k = 0; k < j.etags[i].attrs.length; k++) {
                delete j.etags[i].attrs[k]['element'];
                delete j.etags[i].attrs[k]['type'];
                
                if (j.etags[i].attrs[k].hasOwnProperty('require') && 
                    (j.etags[i].attrs[k]['require'] == '' ||
                     j.etags[i].attrs[k]['require'] == 'IMPLIED')) {
                    // when this attr value is optional, delete
                    delete j.etags[i].attrs[k]['require'];
                }

                // delete the values for text attr
                if (j.etags[i].attrs[k]['vtype'] == 'text') {
                    delete j.etags[i].attrs[k]['values'];
                }
            }
        }

        // delete etags if empty
        if (j.etags.length == 0) {
            delete j['etags'];
        }

        // remove some attrs in rtags
        for (let i = 0; i < j.rtags.length; i++) {
            delete j.rtags[i]['attr_dict'];
            delete j.rtags[i]['shortcut'];
            delete j.rtags[i]['style'];
            delete j.rtags[i]['type'];
            delete j.rtags[i]['id_prefix'];
            delete j.rtags[i]['is_non_consuming']

            // remove some attrs in attrs
            for (let k = 0; k < j.rtags[i].attrs.length; k++) {
                delete j.rtags[i].attrs[k]['element'];
                delete j.rtags[i].attrs[k]['type'];
                
                if (j.rtags[i].attrs[k].hasOwnProperty('require') && 
                    (j.rtags[i].attrs[k]['require'] == '' ||
                     j.rtags[i].attrs[k]['require'] == 'IMPLIED')) {
                    // when this attr value is optional, delete
                    delete j.rtags[i].attrs[k]['require'];
                }

                // delete the values for text attr
                if (j.rtags[i].attrs[k]['vtype'] == 'text') {
                    delete j.rtags[i].attrs[k]['values'];
                }

                // delete the values for idref
                if (j.rtags[i].attrs[k]['vtype'] == 'idref') {
                    // for 
                    delete j.rtags[i].attrs[k]['values'];
                    delete j.rtags[i].attrs[k]['default_value']
                }
            }
        }

        // delete rtags if empty
        if (j.rtags.length == 0) {
            delete j['rtags'];
        }
        
        return j;
    },

    stringify_json: function(dtd) {
        // make a copy 
        var j = this.minimize_dtd_json(dtd);

        // convert to string
        var j_str = JSON.stringify(j, null, 4);
        return j_str;
    },

    stringify_yaml: function(dtd) {
        // make a copy 
        var j = this.minimize_dtd_json(dtd);

        // convert to yaml string
        var y_str = jsyaml.dump(j);

        // add a title
        y_str = "# Annotation Schema: " + dtd.name + "\n" + 
            "# For more information schema design, you can check MedTator Wiki:\n" +
            "# https://github.com/OHNLP/MedTator/wiki/Annotation-Schema \n" +
            y_str;

        return y_str;
    },

    extend_base_dtd: function(base_dtd) {
        var dtd = JSON.parse(JSON.stringify(base_dtd));

        // first, update the attr_dict for each tag
        for (let _t = 0; _t < 2; _t++) {
            var el = {
                0: 'etags',
                1: 'rtags'
            }[_t];

            for (let i = 0; i < dtd[el].length; i++) {
                // init the attr dict
                dtd[el][i].attr_dict = {};
                
                // fill the attr dict
                for (let j = 0; j < dtd[el][i].attrs.length; j++) {
                    var att = dtd[el][i].attrs[j];
                    dtd[el][i].attr_dict[att.name] = att;
                }
            }
        }

        // then, need to decide the `id_prefix_dict` and update the tag_dict
        dtd.id_prefix_dict = {};
        dtd.tag_dict = {};
        for (let _t = 0; _t < 2; _t++) {
            var el = {
                0: 'etags',
                1: 'rtags'
            }[_t];

            for (let i = 0; i < dtd[el].length; i++) {
                // init the id_prefix using the first letter
                dtd[el][i].id_prefix = dtd[el][i].name.substring(0, 1).toLocaleUpperCase();
                
                // search if it is available now
                while (true) {
                    if (dtd.id_prefix_dict.hasOwnProperty(dtd[el][i].id_prefix)) {
                        dtd[el][i].id_prefix = this.get_next_id_prefix(dtd[el][i]);
                    } else {
                        break;
                    }
                }
                
                // yes found at last
                dtd.id_prefix_dict[dtd[el][i].id_prefix] = dtd[el][i];

                // and update the tag_dict
                dtd.tag_dict[dtd[el][i].name] = dtd[el][i];
            }
        }

        // last, add the text
        dtd.text = this.stringify(dtd);

        return dtd;
    },

    /**
     * Parse the given text into the schema object
     * 
     * @param {string} text the annotation schema content
     * @param {string} format the format of schema, dtd/json/yaml
     * @returns the dtd object
     */
    parse: function(text, format) {
        if (typeof(format)=='undefined') {
            format = 'dtd';
        }

        if (format == 'dtd') {
            return this.parse_dtd(text);

        } else if (format == 'json') {
            return this.parse_json(text);

        } else if (format == 'yaml') {
            return this.parse_yaml(text);

        } else {
            // what???
            return null;
        }

    },

    /**
     * Parse the given JSON format string
     * 
     * @param {string} text a JSON string that contains schema
     * @returns the dtd object
     */
    parse_json: function(text) {
        // get the basic 
        var tmp = null;
        try {
            tmp = JSON.parse(text);
        } catch (error) {
            console.log('* invalid JSON content');
            return null;
        }

        // parse the dtd
        var dtd = this._parse_tmp_dtd(tmp);
        // bind the text just as backup?
        // it won't be used
        dtd.text = text;

        // that's it?
        return dtd;
    },

    parse_yaml: function(text) {
        // get the basic 
        var tmp = null;
        try {
            tmp = jsyaml.load(text);

        } catch (error) {
            console.log('* invalid YAML content');
            return null;
        }

        // parse the dtd
        var dtd = this._parse_tmp_dtd(tmp);
        // bind the text just as backup?
        // it won't be used
        dtd.text = text;

        // that's it?
        return dtd;
    },

    _parse_tmp_dtd: function(tmp) {
        // validate the basic elements
        if (!tmp.hasOwnProperty('name')) {
            console.log('* missing name in the given schema');
            return null;
        }

        // OK! let's start!
        // create an empty dtd
        var dtd = this.mk_base_dtd('');

        // set the dtd name
        dtd.name = tmp.name;

        // the schema should contain entity
        if (!tmp.hasOwnProperty('etags')) {
            tmp['etags'] = [];
        }

        // the schema should contain relation but this is optional
        if (!tmp.hasOwnProperty('rtags')) {
            tmp['rtags'] = [];
        }
        
        // loop each entity
        for (let i = 0; i < tmp.etags.length; i++) {
            // get the obj
            var tmp_tag = tmp.etags[i];

            if (!tmp_tag.hasOwnProperty('name')) {
                console.log('* skipped unparsable tag', tmp_tag);
                continue;
            }

            // make an empty tag
            var tag = this.mk_base_tag(tmp_tag.name, 'etag');

            // parse the attrs
            if (!tmp_tag.hasOwnProperty('attrs')) {
                // just set empty attrs
                tmp_tag['attrs'] = [];
            }

            // get all attrs
            for (let i = 0; i < tmp_tag['attrs'].length; i++) {
                var tmp_attr = tmp_tag['attrs'][i];
                
                // create an attr obj by using the tmp_attr
                var attr = this.mk_attr_by_tmp_attr(tmp_tag, tmp_attr);
                
                if (attr == null) {
                    console.log('* skipped unparsable attr', tmp_attr);
                    continue;
                }

                // add this attr to tag
                tag.attrs.push(attr);
                
                // update the tag dict
                tag.attr_dict[attr.name] = attr;
            }
            
            // build by passing values
            if (tmp_tag.hasOwnProperty('is_non_consuming')) {
                // default entity tag is span-based
                tag.is_non_consuming = tmp_tag.is_non_consuming;
            }

            // the last thing for a tag
            if (tmp_tag.hasOwnProperty('id_prefix')) {
                // just set as null, will generate it later
                tag.id_prefix = tmp_tag.id_prefix;
            } else {
                tag.id_prefix = this.get_valid_id_prefix(
                    tag.name,
                    dtd
                );
            }
            // no matter what id prefix is selected,
            dtd.id_prefix_dict[tag.id_prefix] = tag;

            // and update the tag_dict
            dtd.tag_dict[tag.name] = tag;

            // add this tag
            dtd.etags.push(tag);
        }

        // loop relation tags
        for (let i = 0; i < tmp.rtags.length; i++) {
            // get the obj
            var tmp_tag = tmp.rtags[i];

            if (!tmp_tag.hasOwnProperty('name')) {
                console.log('* skipped unparsable tag', tmp_tag);
                continue;
            }
            // make an empty tag
            var tag = this.mk_base_tag(tmp_tag.name, 'rtag');

            // parse the attrs
            if (!tmp_tag.hasOwnProperty('attrs')) {
                // just set empty attrs
                tmp_tag['attrs'] = [];
            }

            // get all attrs
            for (let i = 0; i < tmp_tag['attrs'].length; i++) {
                var tmp_attr = tmp_tag['attrs'][i];
                
                // create an attr obj by using the tmp_attr
                var attr = this.mk_attr_by_tmp_attr(tmp_tag, tmp_attr);
                
                if (attr == null) {
                    console.log('* skipped unparsable attr', tmp_attr);
                    continue;
                }

                // add this attr to tag
                tag.attrs.push(attr);
                
                // update the tag dict
                tag.attr_dict[attr.name] = attr;
            }

            // the last thing for a tag
            if (tmp_tag.hasOwnProperty('id_prefix')) {
                // just set as null, will generate it later
                tag.id_prefix = tmp_tag.id_prefix;
            } else {
                tag.id_prefix = this.get_valid_id_prefix(
                    tag.name,
                    dtd
                );
            }
            // no matter what id prefix is selected,
            dtd.id_prefix_dict[tag.id_prefix] = tag;

            // and update the tag_dict
            dtd.tag_dict[tag.name] = tag;

            // add to dtd
            dtd.rtags.push(tag);
        }

        // a speciall rule for meta,
        // just copy everything
        if (tmp.hasOwnProperty('meta')) {
            dtd.meta = JSON.parse(JSON.stringify(tmp.meta));
        }

        return dtd;
    },

    parse_dtd: function(text) {
        var lines = text.split('\n');

        var dtd = {
            // schema name
            name: '',

            // the list of entity tags
            etags: [],

            // the list of relation tags
            rtags: [],

            // a dictionary for quick access tags by id_prefix_dict
            id_prefix_dict: {},

            // a dictionary for quick access tags by tag name
            tag_dict: {},

            // the raw dtd text
            text: text
        };

        for (let l = 0; l < lines.length; l++) {
            const line = lines[l];
            
            // check this line
            var ret = this.parse_line(line);

            if (ret == null) {
                // nothing happens
                console.log('* null dtd line: ', line);
                continue;

            } else if (ret.type == 'entity') {
                dtd.name = ret.name;

            } else if (ret.type == 'etag') {
                // check the id by a looping
                while (true) {
                    if (dtd.id_prefix_dict.hasOwnProperty(ret.id_prefix)) {
                        ret.id_prefix = this.get_next_id_prefix(ret);
                    } else {
                        break;
                    }
                }
                dtd.id_prefix_dict[ret.id_prefix] = ret;
                dtd.tag_dict[ret.name] = ret;

            } else if (ret.type == 'rtag') {
                // check the id
                while (true) {
                    if (dtd.id_prefix_dict.hasOwnProperty(ret.id_prefix)) {
                        ret.id_prefix = this.get_next_id_prefix(ret);
                    } else {
                        break;
                    }
                }
                dtd.id_prefix_dict[ret.id_prefix] = ret;
                dtd.tag_dict[ret.name] = ret;

            } else if (ret.type == 'attr') {
                // put this attr to an element
                dtd.tag_dict[ret.element].attrs.push(
                    ret
                );

            } else {
                // what???
            }
        }
        
        // post processing for all tags
        for (const name in dtd.tag_dict) {
            if (Object.hasOwnProperty.call(dtd.tag_dict, name)) {
                if (dtd.tag_dict[name].type == 'etag') { 
                    // check the attr to make sure no missing
                    for (let i = 0; i < dtd.tag_dict[name].attrs.length; i++) {
                        if (dtd.tag_dict[name].attrs[i].vtype == 'dfix') {
                            // which means this is a non-consuming tag
                            dtd.tag_dict[name].is_non_consuming = true;
                        }
                    } 

                }  else {

                    // for link tag, need to check how many attrs are found
                    var cnt_idrefs = 0;
                    for (let i = 0; i < dtd.tag_dict[name].attrs.length; i++) {
                        if (dtd.tag_dict[name].attrs[i].vtype == 'idref') {
                            cnt_idrefs += 1;
                        }
                    }

                    // if there is not idref, just create two:
                    if (cnt_idrefs == 0) {
                        // create from and to
                        var attr_from = this.mk_base_attr(name, 'from', 'idref');
                        var attr_to = this.mk_base_attr(name, 'to', 'idref');
                        dtd.tag_dict[name].attrs = [attr_from, attr_to].concat(
                            dtd.tag_dict[name].attrs
                        );
                        console.log('* added from+to to the attr of ' + name);
                    }
                }
                
            }
        }

        // split the tags
        for (const name in dtd.tag_dict) {
            if (Object.hasOwnProperty.call(dtd.tag_dict, name)) {
                // now, create a attr_dict for each tag
                dtd.tag_dict[name].attr_dict = this.make_attr_dict(
                    dtd.tag_dict[name]
                );

                // last, put this tag to list
                var element = dtd.tag_dict[name];
                if (element.type == 'etag') {
                    dtd.etags.push(element);
                } else {
                    dtd.rtags.push(element);
                }
            }
        }

        return dtd;
    },

    parse_line: function(line) {
        var obj = null;
        var ret = null;

        // try entity
        ret = this.get_entity(line);
        if (ret != null) { return ret; }

        // try element
        ret = this.get_element(line);
        if (ret != null) { return ret; }

        // try attr
        ret = this.get_attr(line);

        return ret;
    },

    get_entity: function(text) {
        let m;
        var ret = null;
        let regex = this.regex.entity;

        while ((m = regex.exec(text)) !== null) {
            // This is necessary to avoid infinite loops with zero-width matches
            if (m.index === regex.lastIndex) {
                regex.lastIndex++;
            }
            
            // The result can be accessed through the `m`-variable.
            m.forEach((match, groupIndex) => {
                // console.log(`Found entity match, group ${groupIndex}: ${match}`);
                ret = {
                    name: match,
                    type: 'entity'
                };
            });
        }

        return ret;
    },

    get_element: function(line) {
        let m;
        var ret = null;
        let regex = this.regex.element;

        while ((m = regex.exec(line)) !== null) {
            // This is necessary to avoid infinite loops with zero-width matches
            if (m.index === regex.lastIndex) {
                regex.lastIndex++;
            }
            var element = {
                name: '',
                type: 'etag',
                id_prefix: '',
                is_non_consuming: false,
                attrs: []
            };

            // The result can be accessed through the `m`-variable.
            m.forEach((match, groupIndex) => {
                // console.log(`Found element match, group ${groupIndex}: ${match}`);
                // group 0 is the leading line
                if (groupIndex == 1) {
                    element.name = match;
                    element.id_prefix = match.substring(0, 1);
                } 
            });
        
            // check the element type
            if (line.lastIndexOf('EMPTY')>=0) {
                element.type = 'rtag';
            }

            ret = element;
        }

        return ret;

    },

    get_attr: function(line) {
        let m;
        var ret = null;
        let regex = this.regex.attr;

        while ((m = regex.exec(line)) !== null) {
            // This is necessary to avoid infinite loops with zero-width matches
            if (m.index === regex.lastIndex) {
                regex.lastIndex++;
            }
            var attr = this.mk_base_attr('', '', '');
            // The result can be accessed through the `m`-variable.
            m.forEach((match, groupIndex) => {
                // console.log(`Found attr match, group ${groupIndex}: ${match}`);
                // group 0 is the leading text
                if (groupIndex == 1) {
                    // which is the element name
                    attr.element = match;

                } else if (groupIndex == 2) {
                    // which means it is the attr of this element
                    attr.name = match;

                    // special rule for some attrs
                    if (match == 'spans') {
                        // for attr `spans`, need to update the elememt
                        attr.vtype = 'dfix';
                        attr.default_value = this.NON_CONSUMING_SPANS;
                    }

                } else if (groupIndex == 3) {
                    if (match == 'CDATA') {
                        // ok, it's just a text content
                        attr.vtype = 'text';
                        
                        // then get the default value
                        attr.default_value = this.get_attr_cdata_default_value(line);

                    } else if (match == '(') {
                        // this is a list
                        attr.vtype = 'list';

                        // get the values
                        attr.values = this.get_attr_values(line);

                    } else if (match == 'IDREF') {
                        // it's an attr for link tag
                        attr.vtype = 'idref';

                        if (this.is_argN(attr.name)) {
                            // ok
                        } else {
                            // IDREF's default name must argX
                            // but ... why?
                            console.error('* error name for this "', line, '", attr name should be argX format');
                        }

                        // then, check if there is prefix
                        var prefix = this.get_attr_prefix(line);
                        if (prefix == null) {
                            // which means this attr doesn't have a prefix
                            // for renaming the extraction
                        } else {
                            // use the prefix to replace this name
                            attr.name = prefix;
                        }
                    }
                } else {
                    // what?
                }
            });

            // before end, check the require info
            var require = this.get_attr_require(line);
                        
            if (require.length == 0) {
                // which means this attr has nothing

            } else if (require.length == 1) {
                // which means just has the require name it self
                attr.require = require[0];

            } else if (require.length == 2) {
                // which means it has the default value!
                attr.require = require[0];
                attr.default_value = require[1];
            }

            ret = attr;
        }

        return ret;
    },

    get_attr_values: function(line) {
        let m;
        var ret = [];
        let regex = this.regex.attr_values;

        while ((m = regex.exec(line)) !== null) {
            // This is necessary to avoid infinite loops with zero-width matches
            if (m.index === regex.lastIndex) {
                regex.lastIndex++;
            }
            var values = [];
            // The result can be accessed through the `m`-variable.
            m.forEach((match, groupIndex) => {
                // console.log(`Found attr values match, group ${groupIndex}: ${match}`);
                // group 0 is the leading text
                if (groupIndex == 1) {
                    // which is the element name
                    var ps = match.split('|');
                    for (let i = 0; i < ps.length; i++) {
                        const p = ps[i];
                        var _p = p.trim();
                        values.push(_p);
                    }
                } 
            });

            ret = values;
        }

        return ret;
    },

    get_attr_require: function(line) {
        let m;
        var ret = [];
        let regex = this.regex.attr_require;

        while ((m = regex.exec(line)) !== null) {
            // This is necessary to avoid infinite loops with zero-width matches
            if (m.index === regex.lastIndex) {
                regex.lastIndex++;
            }

            // the final values?
            var values = [];

            // The result can be accessed through the `m`-variable.
            m.forEach((match, groupIndex) => {
                // console.log(`Found attr require match, group ${groupIndex}: ${match}`);
                // group 0 is the leading text
                if (groupIndex == 1) {
                    // which is the require name
                    // IMPLIED or REQUIRED
                    values.push(match)
                } else if (groupIndex == 2) {
                    // get default value 
                    var t = match.replaceAll('"', '');
                    t = t.replaceAll('>', '');
                    t = t.trim();

                    // not matter what is left, save it
                    values.push(t);
                }
            });

            ret = values;
        }

        
        return ret;
    },

    get_attr_prefix: function(line) {
        let m;
        var ret = null;
        let regex = this.regex.attr_prefix;

        while ((m = regex.exec(line)) !== null) {
            // This is necessary to avoid infinite loops with zero-width matches
            if (m.index === regex.lastIndex) {
                regex.lastIndex++;
            }

            // the final values?
            var p = null;

            // The result can be accessed through the `m`-variable.
            m.forEach((match, groupIndex) => {
                if (groupIndex == 1) {
                    // which is the prefix text
                    p = match;
                }
            });

            ret = p;
        }
        
        return ret;
    },    

    get_attr_cdata_default_value: function(line) {
        let m;
        var ret = null;
        let regex = this.regex.attr_cdata_default_value;

        while ((m = regex.exec(line)) !== null) {
            // This is necessary to avoid infinite loops with zero-width matches
            if (m.index === regex.lastIndex) {
                regex.lastIndex++;
            }

            // the final values?
            var p = null;

            // The result can be accessed through the `m`-variable.
            m.forEach((match, groupIndex) => {
                if (groupIndex == 1) {
                    // which is the prefix text
                    p = match;
                }
            });

            ret = p;
        }
        
        return ret;
    },    

    make_attr_dict: function(tag) {
        let attr_dict = {};

        for (let i = 0; i < tag.attrs.length; i++) {
            attr_dict[tag.attrs[i].name] = tag.attrs[i];
        }

        return attr_dict;
    },

    get_next_id_prefix: function(element) {
        var ret = element.name.substring(
            0,
            element.id_prefix.length + 1
        );

        return ret;
    },

    get_valid_id_prefix: function(tag_name, dtd) {
        // starts with the first letter of the tag_name
        var id_prefix = tag_name.substring(0, 1);

        while (true) {
            if (dtd.id_prefix_dict.hasOwnProperty(id_prefix)) {
                id_prefix = tag_name.substring(
                    0,
                    id_prefix.length + 1
                );
            } else {
                break;
            }
        }

        return id_prefix;
    },

    ///////////////////////////////////////////////////////
    // Utils
    ///////////////////////////////////////////////////////
    get_id_prefix: function(tag_name, dtd) {
        if (dtd.tag_dict.hasOwnProperty(tag_name)) {
            return dtd.tag_dict[tag_name].id_prefix;
        }
        return '';
    },

    is_argN: function(name) {
        if (name.startsWith('arg')) {
            if (/^\d+$/.test(name.substring(3))) {
                return true;
            }
        }
        return false;
    },

    mk_base_attr: function(element, name, vtype) {
        return {
            name: name,
            vtype: vtype,
            require: '',
            values: [],
            default_value: '',

            // element is the tag name
            element: element,
            type: 'attr',
        };
    },

    mk_attr_by_tmp_attr: function(tag, tmp_attr) {
        // name is needed for an attr
        if (!tmp_attr.hasOwnProperty('name')) {
            return null;
        }

        // vtype is needed for an attr
        if (!tmp_attr.hasOwnProperty('vtype')) {
            return null;
        }

        // make an empty attr
        var attr = this.mk_base_attr(
            tag.name,
            tmp_attr.name,
            tmp_attr.vtype
        );

        // set the default value
        if (tmp_attr.hasOwnProperty('require')) {
            attr['require'] = tmp_attr['require'];
        }

        // set the values
        if (tmp_attr.hasOwnProperty('values')) {
            attr['values'] = tmp_attr['values'];
        }

        // set the default value
        if (tmp_attr.hasOwnProperty('default_value')) {
            attr['default_value'] = tmp_attr['default_value'];
        }

        return attr;
    },

    mk_base_tag: function(tag_name, tag_type) {
        return {
            // basic information for a tag
            name: tag_name,
            type: tag_type,
            is_non_consuming: false,
            attrs: [],

            // the followings are decided when extending
            attr_dict: {},
            id_prefix: {},

            // the followings are decided when importing
            shortcut: null,
            style: {
                color: '#333333'
            }
        };
    },

    mk_base_dtd: function(dtd_name) {
        return {
            name: dtd_name,
            etags: [],
            rtags: [],

            // the followings are left null for extending later
            id_prefix_dict: {},
            tag_dict: {},
            text: null
        }
    }
};

// The Ann parser
/**
 * Annotation file parser
 * 
 * The ann used in this tool is an object following this format:
 * {
 *  _fh: FileSystemHandle,
 *  _has_saved: true/false,
 *  text: '',
 *  dtd_name: '',
 *  tags: [{
 *    id: '',
 *    tag: '',
 *    spans: '', // this may not be available
 *    text: '',  // this may not be available
 * 
 *  }]
 * }
 * 
 * the `_fh` is added outside of parser.
 * the `_has_saved` is added outside
 */
var ann_parser = {
    NON_CONSUMING_SPANS: '-1~-1',


    ///////////////////////////////////////////////////////
    // Annotation serialization/deserialization functions
    ///////////////////////////////////////////////////////
    txt2ann: function(txt, dtd) {
        var ann = {
            text: txt,
            dtd_name: dtd.name,
            tags: [],
            meta: {},  // the meta data of this annotation
            
            // other info
            _fh: null,
            _filename: null,
            _has_saved: true,
            _sentences: [],
            _sentences_text: ''
        };

        return ann;
    },

    xml2ann: function(xml_text, dtd) {
        // create a new DOM parser
        var parser = new DOMParser();

        // parse the given text
        var xmlDoc = parser.parseFromString(xml_text, "text/xml");

        // create an empty ann
        var ann = {
            text: '',
            dtd_name: '',
            tags: [],
            meta: {},  // the meta data of this annotation
            
            // other info
            _fh: null,
            _filename: null,
            _has_saved: true,
            _sentences: [],
            _sentences_text: ''
        };

        // first, get the dtd name
        var dtd_name = xmlDoc.children[0].tagName;
        ann.dtd_name = dtd_name;

        if (dtd.name != ann.dtd_name) {
            throw {
                name: 'Not match given DTD',
                message: 'The task name in XML (' + ann.dtd_name + ') does NOT match the given DTD (' + dtd.name + ')'
            };
        }

        // then get the text content
        var textContent = xmlDoc.getElementsByTagName('TEXT')[0].textContent;
        ann.text = textContent;

        // then check all of the tags
        if (xmlDoc.getElementsByTagName('TAGS').length == 0) {
            // it's possible that there is no tags at all
            // then we could skip
        } else {
            var elems = xmlDoc.getElementsByTagName('TAGS')[0].children;

            for (let i = 0; i < elems.length; i++) {
                var elem = elems[i];

                // get the attributes
                var tag_name = elem.tagName;

                // first, need to if this tag_name is supported in current dtd
                if (dtd.tag_dict.hasOwnProperty(tag_name)) {
                    // OK, there it is
                } else {
                    // no such tag??
                    console.log("* not found", tag_name, 'in current dtd');
                    continue;
                }

                // create a new empty tag
                var tag = {
                    tag: tag_name
                };

                // get all attr names
                var attrs = elem.getAttributeNames();

                // get all attr values
                for (let j = 0; j < attrs.length; j++) {
                    var attr = attrs[j];
                    var value = elem.getAttribute(attr);

                    // there are exceptions
                    if (attr.toLocaleLowerCase() == 'text') {
                        // special rule for the text attr
                        // due to the bad convertion
                        tag['text'] = value;

                    } else if (attr.toLocaleLowerCase() == 'spans') {
                        // special rule for the text attr
                        // due to the bad convertion
                        // tag['spans'] = value;

                        // fix the wrong values
                        var locs = this.spans2locs(value);
                        var spans = this.locs2spans(locs);

                        if (value != spans) {
                            console.log('* fixed wrong format spans ' + value + ' -> ' + spans);
                        }
                        tag['spans'] = spans;

                    } else if (attr.endsWith('ID')) {
                        // omg, this may be a link tag
                        // let's check if there is a xxxText attr
                        var attr_prefix_name = attr.substring(0, attr.length-2);
                        var attrText_name = attr_prefix_name + 'Text';
                        if (attrs.indexOf(attrText_name)>=0) {
                            // ok, I'm sure this is a idref att
                            // the value is the etag id
                            // let's save it and goto next
                            tag[attr_prefix_name] = value;
                            continue;

                        } else {
                            // what??? ok, this is just a normal but weird attr
                            // just save it later

                        }
                    } else if (attr.endsWith('Text')) {
                        // I guess we could skip this one
                        continue;

                    } else if (attr.startsWith('_')) {
                        // which means this a special attribute
                        // for example, _annotator
                        var attr_lower = attr.toLocaleLowerCase();
                        tag[attr] = value;

                    } else {
                        // other special rule? maybe
                        // put this value into tag
                        tag[attr] = value;
                    }
                }

                // one more step, need to check whether this tag belongs to dtd
                // if not, skip the next step
                if (dtd.tag_dict.hasOwnProperty(tag_name)) {
                    // one more step, sometimes the attr in XML doesn't contain
                    // what defined in the dtd, so we need to give a value
                    for (let k = 0; k < dtd.tag_dict[tag_name].attrs.length; k++) {
                        const att = dtd.tag_dict[tag_name].attrs[k];
                        if (tag.hasOwnProperty(att.name)) {
                            // ok, that's what it should be
                        } else {
                            // also ok, that's what it actually is sometimes
                            tag[att.name] = att.default_value;                            
                            console.log('* fixed missing '+tag.id+' attr['+att.name+']');
                        }
                    }

                    // check the text attr for entity tags
                    if (dtd.tag_dict[tag_name].type == 'etag') {
                        if (tag.hasOwnProperty('text')) {

                        } else {
                            if (tag.spans == '-1~-1') {
                                tag.text = '';
                            } else {
                                tag.text = this.get_text_by_spans(tag.spans, ann.text);
                            }
                        }
                    }
                } else {
                    console.log('* undefined [' + tag_name + '] in dtd');
                }
                // console.log('* add tag', tag);

                // then, put this new tag to the ann tags list
                ann.tags.push(tag);
            }
        }

        // then check all of the meta data
        if (xmlDoc.getElementsByTagName('META').length == 0) {
            // it's very very possible that no meta data
            // then just skip
        } else {
            // Wow! that's great!
            // We found some meta data for this annotation!
            // just save everything to `ann.meta`?

            // check all
            var elems = xmlDoc.getElementsByTagName('META')[0].children;
            for (let i = 0; i < elems.length; i++) {
                var elem = elems[i];

                // get the attributes
                var tag_name = elem.tagName;

                // decide the format
                if (ann.meta.hasOwnProperty(tag_name)) {
                    // nothing to do
                } else {
                    // we assume each tag may have multiple tags
                    ann.meta[tag_name] = [];
                }

                // get all attr names
                var attrs = elem.getAttributeNames();

                // create a temp obj
                var obj = {};

                // put all attrs 
                for (let j = 0; j < attrs.length; j++) {
                    var attr = attrs[j];
                    var value = elem.getAttribute(attr);

                    // put value
                    obj[attr] = value;
                }

                // save this obj
                ann.meta[tag_name].push(obj);
            }
        }

        return ann;
    },

    ann2xml: function(ann, dtd) {
        // create the root document
        var xmlDoc = document.implementation.createDocument(
            null, ann.dtd_name
        );
        var root = xmlDoc.getElementsByTagName(ann.dtd_name)[0];
        // var root = xmlDoc.getRootNode();

        // create the CDATA section for TEXT
        var node_TEXT = xmlDoc.createElement('TEXT');
        node_TEXT.appendChild(
            xmlDoc.createCDATASection(ann.text)
        );
        root.appendChild(node_TEXT);

        // create the tags
        var node_TAGS = xmlDoc.createElement('TAGS');
        for (let i = 0; i < ann.tags.length; i++) {
            const tag = ann.tags[i];

            // create a node for this tag
            var node_tag = xmlDoc.createElement(tag.tag);

            // create all attributes
            for (const attr in tag) {
                // skip special tags
                if (attr.startsWith('_')) {
                    // internal attributes
                    // _annotator
                    // _
                    // continue;
                    node_tag.setAttribute(attr, tag[attr]);
                    continue;
                }

                if (attr == 'tag') {
                    // skip the tag name itself
                    continue;
                }

                if (tag[attr] == null) {
                    // skip those null values in xml
                    continue;
                }

                if (attr == 'id') {
                    // quick save this attr
                    node_tag.setAttribute(attr, tag[attr]);
                    continue;
                }

                if (dtd.tag_dict[tag.tag].type == 'etag') {
                    node_tag.setAttribute(attr, tag[attr]);
                    continue;

                } else if (dtd.tag_dict[tag.tag].type == 'rtag') {
                    // for link tag, spans and text are not required
                    if (attr == 'spans') { continue; }
                    if (attr == 'text') { continue; }

                    // due to schema version issue, 
                    // the attribute may not exist in current schema
                    if (!dtd.tag_dict[tag.tag].attr_dict.hasOwnProperty(attr)) {
                        continue;
                    }
                
                    // for those link tag, need to check 
                    if (dtd.tag_dict[tag.tag].attr_dict[attr].vtype == 'idref') {
                        // so, this attr is a id ref,
                        // the value is a tag_id of an etag
                        // to be compatible with MAE format,
                        // we need to set 2 attributes if the value is not null
                        if (tag[attr] == null || tag[attr] == '') {
                            // if the value is empty, just skip this
                            continue;
                        }
                        // first, the xxxID
                        // second, the xxxText
                        // so, let's get the text first
                        var etag = this.get_tag_by_tag_id(tag[attr], ann);
                        if (etag == null) {
                            // ??? how could it be?
                            // well...skip this one
                            console.log('* not found etag [', attr, '] in ', tag);
                            continue;
                        }

                        // great! the etag is not null
                        node_tag.setAttribute(attr + 'ID', tag[attr]);
                        node_tag.setAttribute(attr + 'Text', etag.text);

                    } else {
                        // bind this node_attr to the node_tag
                        node_tag.setAttribute(attr, tag[attr]);
                    }
                }
            }

            // append this node to TAGS
            node_TAGS.appendChild(node_tag);
        }
        root.appendChild(node_TAGS);

        if (!ann.hasOwnProperty('meta')) {
            // this is old format, there is no meta
            return xmlDoc;
        }

        // create the meta
        var node_META = xmlDoc.createElement('META');
        for (const key in ann.meta) {
            if (Object.hasOwnProperty.call(ann.meta, key)) {
                const objs = ann.meta[key];
                
                // objs is a list of items of this key

                for (let i = 0; i < objs.length; i++) {
                    const obj = objs[i];

                    // create a node for this tag
                    var node_tag = xmlDoc.createElement(key);
                    
                    // save this obj
                    for (const attr in obj) {
                        node_tag.setAttribute(attr, obj[attr]);
                    }

                    // save this node
                    node_META.appendChild(node_tag);
                }
            }
        }
        root.appendChild(node_META);
        
        return xmlDoc;
    },

    xml2str_v1: function(xmlDoc, pretty) {
        const serializer = new XMLSerializer();
        var xmlStr = serializer.serializeToString(xmlDoc);

        // fix missing 
        if (xmlStr.startsWith('<?xml')) {
            // nothing, it' OK
        } else {
            xmlStr = '<?xml version="1.0" encoding="UTF-8" ?>\n' + xmlStr;
        }

        if (typeof(pretty)=='undefined') {
            pretty = true;
        }

        if (pretty) {
            // var pretty_xmlStr = vkbeautify.xml(xmlStr, 0);
            // return pretty_xmlStr;
            var format = require('xml-formatter');
            formattedXml = format(xmlStr, {
                indentation: ''
            });
        }

        return xmlStr;
    },

    xml2str: function(xml_doc) {
        const serializer = new XMLSerializer();
        var xml_str_TEXT = serializer.serializeToString(xml_doc.getElementsByTagName('TEXT')[0]);
        var xml_str_TAGS = serializer.serializeToString(xml_doc.getElementsByTagName('TAGS')[0]);
        var xml_str_META = serializer.serializeToString(xml_doc.getElementsByTagName('META')[0]);

        // format the XML to make it looks better for human
        var format = require('xml-formatter');
        var xml_str_TAGS_formatted = format(xml_str_TAGS, {
            indentation: ''
        });
        var xml_str_META_formatted = format(xml_str_META, {
            indentation: ''
        });

        var root_name = xml_doc.children[0].nodeName;

        var xml_str = [
            '<?xml version="1.0" encoding="UTF-8" ?>',
            '<' + root_name + '>',
            xml_str_TEXT,
            xml_str_TAGS_formatted,
            xml_str_META_formatted,
            '</' + root_name + '>'
        ].join('\n');

        return xml_str;
    },

    pretty_xml_str: function(xml_str) {
        var formatted = '';
        var reg = /(>)(<)(\/*)/g;
        xml = xml.replace(reg, '$1\r\n$2$3');
        var pad = 0;
        jQuery.each(xml.split('\r\n'), function(index, node) {
            var indent = 0;
            if (node.match( /.+<\/\w[^>]*>$/ )) {
                indent = 0;
            } else if (node.match( /^<\/\w/ )) {
                if (pad != 0) {
                    pad -= 1;
                }
            } else if (node.match( /^<\w[^>]*[^\/]>.*$/ )) {
                indent = 1;
            } else {
                indent = 0;
            }

            var padding = '';
            for (var i = 0; i < pad; i++) {
                padding += '  ';
            }

            formatted += padding + node + '\r\n';
            pad += indent;
        });

        return formatted;
    },


    ///////////////////////////////////////////////////////
    // Hint Dictionary related functions
    ///////////////////////////////////////////////////////

    /**
     * Convert a list of anns to hints as tag name dict
     * @param {object} dtd annotation dtd object
     * @param {list} anns a list of annotation objects
     */
    anns2hint_dict: function(dtd, anns) {
        var hint_dict = {};

        for (let i = 0; i < anns.length; i++) {
            const ann = anns[i];
            for (let j = 0; j < ann.tags.length; j++) {
                this.add_tag_to_hint_dict(
                    ann, 
                    ann.tags[j], 
                    hint_dict
                );
            }
        }

        return hint_dict;
    },

    /**
     * Add an annotation to hint
     * 
     * @param {Object} ann annotation object
     * @param {Object} hint_dict hint
     * @returns hint_dict
     */
    add_ann_to_hint_dict: function(ann, hint_dict) {
        for (let i = 0; i < ann.tags.length; i++) {
            this.add_tag_to_hint_dict(
                ann,
                ann.tags[i],
                hint_dict
            );
        }
        return hint_dict;
    },

    /**
     * Add one tag to hint_dict
     * 
     * @param {Object} ann annotation object
     * @param {Object} tag annotated tag
     * @param {Object} hint_dict hints
     * @returns 
     */
    add_tag_to_hint_dict: function(ann, tag, hint_dict) {
        // create this tag if not exists
        if (!hint_dict.hasOwnProperty(tag.tag)) {
            hint_dict[tag.tag] = {
                // text only
                text_dict: {}, 

                // non-consuming dict
                nc_dict: {
                    count: 0,
                    ann_fn_dict: {},
                    _is_shown: false,
                }, 

                // just a list of texts
                texts: []
            }
        }
        // empty text should be removed
        if (!tag.hasOwnProperty('text')) {
            // which means it's a link tag
            // we can do nothing to a link tag now
            return;
        }

        // now get the text and trim it
        var text = tag.text;
        text = text.trim();

        // for empty text, need to further check
        if (text == '') {
            // need to check if is a NC etag
            if (tag.spans == this.NON_CONSUMING_SPANS) {
                // add this nc etag
                if (hint_dict[tag.tag].nc_dict.ann_fn_dict.hasOwnProperty(ann._filename)) {
                    // oh, this is NOT a new file
                    // just increase the count for this concept and file
                    hint_dict[tag.tag].nc_dict.count += 1;
                    hint_dict[tag.tag].nc_dict.ann_fn_dict[ann._filename] += 1
        
                } else {
                    // ok, this is a new file
                    // count +1
                    hint_dict[tag.tag].nc_dict.count += 1;
        
                    // save this ann file name
                    hint_dict[tag.tag].nc_dict.ann_fn_dict[ann._filename] = 1;
                }

                // ok, we have add this file information to the hint dict
                return hint_dict;

            } else {
                // ok, it's just a wrong hint I guess
                return hint_dict;
            }
        }

        // add this text
        if (hint_dict[tag.tag].text_dict.hasOwnProperty(text)) {
            // oh, this is NOT a new text
            // just increase the count
            hint_dict[tag.tag].text_dict[text].count += 1;
            if (hint_dict[tag.tag].text_dict[text].ann_fn_dict.hasOwnProperty(ann._filename)) {
                hint_dict[tag.tag].text_dict[text].ann_fn_dict[ann._filename] += 1;
            } else {
                hint_dict[tag.tag].text_dict[text].ann_fn_dict[ann._filename] = 1;
            }

        } else {
            // ok, this is a new text
            // count +1
            hint_dict[tag.tag].text_dict[text] = {
                count: 1,
                ann_fn_dict: {},
                _is_shown: false
            };

            // save this tag
            hint_dict[tag.tag].texts.push(text);

            // save this ann file name
            hint_dict[tag.tag].text_dict[text].ann_fn_dict[ann._filename] = 1;
        }

        return hint_dict;
    },

    /**
     * Search feasible hints to ranges for highlighting in codemirror
     * Those conflict / overlaped hints would be skiped
     * 
     * @param {object} hints The hints object contains all hint texts
     * @param {object} ann The annotation object which contains text and tags
     * @param {list} focus_tags The focused tags for searching
     */
    search_hints_in_ann: function(hint_dict, ann, focus_tags) {
        if (typeof(focus_tags) == 'undefined') {
            focus_tags = null;
        }
        var is_overlapped = function(a, b) {
            if (a[0] >= b[0] && a[0] < b[1]) {
                return true;
            }
            if (a[1] > b[0] && a[1] <= b[1]) {
                return true;
            }
            // the missing for contains
            if (a[0] <= b[0] && a[1] >= b[1]) {
                return true;
            }
            return false;
        }

        var is_overlapped_in_list = function(loc_x, loc_list) {
            for (let i = 0; i < loc_list.length; i++) {
                const loc = loc_list[i];
                if (is_overlapped(loc_x, loc)) {
                    return true;
                }
            }
            return false;
        }

        // for saving the locations of all marks 
        var loc_list = [];

        // for saving those hints need to be marked
        var hint_list = [];

        // for saving existing hint strs and mapping to tags
        var str_dict = {};

        // first, put existed ann tags in to mark dict
        for (let i = 0; i < ann.tags.length; i++) {
            const tag = ann.tags[i];
            if (!tag.hasOwnProperty('spans')) {
                // which means it's a link tag
                continue;
            }
            // var spans = tag.spans.split(',');
            // for (let j = 0; j < spans.length; j++) {
            //     const span = spans[j];
            //     var loc = this.span2loc(span);
            //     loc_list.push(loc);
            // }
            var _locs = this.spans2locs(tag.spans);
            loc_list = loc_list.concat(_locs);
        }
        console.log('* created loc_list', loc_list);
        
        // check each tag in the hint
        for (const tag_name in hint_dict) {
            if (Object.hasOwnProperty.call(hint_dict, tag_name)) {
                // focus on specifed tag hint
                if (focus_tags == null) {
                    // ok, search all
                } else if (focus_tags.indexOf(tag_name)>=0) {
                    // ok, this tag need to search
                } else {
                    // wow, no need to search this tag
                    continue;
                }

                // check each str in this hint tag
                for (let i = 0; i < hint_dict[tag_name].texts.length; i++) {
                    const str = hint_dict[tag_name].texts[i];
                    // if this str exists, just skip
                    if (str_dict.hasOwnProperty(str)) { 
                        if (str_dict[str].tags.hasOwnProperty(tag_name)) {

                        } else {
                            str_dict[str].tags[tag_name] = 1;
                        }
                        continue; 
                    }

                    // put this str to global dict first
                    str_dict[str] = {
                        tags: {}
                    };
                    str_dict[str].tags[tag_name] = 1;

                    // then find the locs of this str in
                    var locs = this.get_locs(str, ann.text);

                    for (let j = 0; j < locs.length; j++) {
                        const loc = locs[j];
                        
                        // we need to check whether this loc exsits
                        if (is_overlapped_in_list(loc, loc_list)) {
                            // ok, skip this
                        } else {
                            // append this loc to the list
                            loc_list.push(loc);

                            // and add this loc as a new mark
                            hint_list.push({
                                id: 'hint-' + tag_name + '-' + i + '-' + j,
                                tag: tag_name,
                                text: str,
                                spans: this.loc2span(loc)
                            })
                        }
                    }
                }
            }
        }

        return hint_list;
    },

    get_stat_tokens_by_hint_dict: function(hint_dict) {
        var stat = {
            rs: []
        };

        for (const tag_name in hint_dict) {
            if (Object.hasOwnProperty.call(hint_dict, tag_name)) {
                const hint_info = hint_dict[tag_name];
                
                for (const text in hint_info.text_dict) {
                    if (Object.hasOwnProperty.call(hint_info.text_dict, text)) {
                        const text_info = hint_info.text_dict[text];

                        // how many anns/docs contain this text for this tag_name
                        var n_anns = Object.keys(text_info.ann_fn_dict).length;

                        // total count of this text for this tag_name in all anns/docs
                        var n_count = text_info.count;

                        // save this information
                        stat.rs.push({
                            text: text,
                            tag_name: tag_name,
                            n_count: n_count,
                            n_anns: n_anns
                        });
                    }
                }
            }
        }

        return stat;
    },

    ///////////////////////////////////////////////////////
    // Utils
    ///////////////////////////////////////////////////////

    get_subtags_of_substr_in_ann: function(span, ann, dtd, flag_update_tag_offset) {
        if (typeof(flag_update_tag_offset) == 'undefined') {
            flag_update_tag_offset = true;
        }
        // convert the span to loc
        var loc_substr = this.span2loc(span);
        // the return object
        var subtags = [];
        // for search by tag id
        var subtag_dict = {};

        // first, get all etags
        for (let i = 0; i < ann.tags.length; i++) {
            // make a copy of this tag
            let tag = ann.tags[i];

            // get the tag defination
            let tag_def = dtd.tag_dict[tag.tag];
            if (tag_def.type != 'etag') {
                // skip relation in the first round
                continue;
            }

            // detect overlap
            // convert string spans to locs
            var locs = this.spans2locs(tag.spans);
            
            // a flag for not 
            var flag_is_sub = true;
            for (let j = 0; j < locs.length; j++) {
                const loc_tag = locs[j];
                
                flag_is_sub = flag_is_sub && nlp_toolkit.is_sub(
                    loc_substr,
                    loc_tag
                );
            }

            if (!flag_is_sub) {
                // oh, this tag is out of the area of this substring
                continue;
            }

            // we need to update the information
            // so make a copy
            tag = JSON.parse(JSON.stringify(ann.tags[i]));

            if (flag_update_tag_offset) {
                var new_locs = nlp_toolkit.update_tag_locs_offset(
                    locs, 
                    // remove the offset of the current span
                    loc_substr[0]
                );
                tag.spans = this.locs2spans(new_locs);
            }

            // then, this tag is within the substring
            // save it
            subtags.push(tag);
            // for further use
            subtag_dict[tag.id] = tag;
        }

        // second, get all rtags
        for (let i = 0; i < ann.tags.length; i++) {
            const tag = ann.tags[i];

            // get the tag defination
            let tag_def = dtd.tag_dict[tag.tag];
            if (tag_def.type != 'rtag') {
                // skip entity in the second round
                continue;
            }

            // find the entities in this relationship
            // we need to ensure the number of entities
            var n_ents = 0;
            for (const attr_name in tag) {
                if (!tag_def.attr_dict.hasOwnProperty(attr_name)) {
                    // which means this attr_name is just id or tag or other
                    continue;
                }
                // find the attr def
                let attr_def = tag_def.attr_dict[attr_name];
                // let's see what's this attr?
                if (attr_def.vtype != 'idref') {
                    // this is just a text or other type
                    continue;
                }
                
                // now check if this entity is in substring
                if (!subtag_dict.hasOwnProperty(tag[attr_name])) {
                    // oh, this entity is not in the substring
                    // need to skip this 
                    continue;
                }

                // ok, the entity of this attr should work!
                n_ents += 1;
            }

            // we need at least two entities within this substr
            // otherwise we cannot visualize the link
            if (n_ents < 2) {
                // if less than 2, just skip this tag
                continue;
            }

            // ok, for those with at least two entites within
            // save it
            subtags.push(tag);
        }

        return subtags;
    },
    
    /**
     * Get the locations of a substring in text
     * 
     * @param {string} str a potential substring
     * @param {string} text full-text
     * @returns locations
     */
    get_locs: function(str, text) {
        // convert str to lower for ignore case?
        try {
            var regex = new RegExp('\\b' + str + '\\b', 'gmi');
            var m;
            var locs = [];
            while ((m = regex.exec(text)) !== null) {
                // This is necessary to avoid infinite loops with zero-width matches
                if (m.index === regex.lastIndex) {
                    regex.lastIndex++;
                }
                
                // The result can be accessed through the `m`-variable.
                m.forEach((match, groupIndex) => {
                    locs.push([ m.index, regex.lastIndex]);
                });
            }

            return locs;
        } catch (error) {
            console.log("* couldn't create regex by", str);
            return [];
        }
    },

    /**
     * Get the text of the specific spans in text
     * 
     * @param {string} spans string-format spans (e.g., 4~5,9~12)
     * @param {string} full_text full text
     * @returns the specific substring
     */
    get_text_by_spans: function(spans, full_text) {
        var locs = this.spans2locs(spans);
        var text = [];
        for (let i = 0; i < locs.length; i++) {
            const loc = locs[i];
            const _t = full_text.substring(
                loc[0],
                loc[1]
            );
            text.push(_t);
        }

        return text.join('...');
    },

    spans2locs: function(raw_spans) {
        // fix for the special convert
        raw_spans = raw_spans.replaceAll(';', ',');

        // split by comma
        var span_arr = raw_spans.split(',');
        var locs = [];
        for (let i = 0; i < span_arr.length; i++) {
            const span = span_arr[i];
            var loc = this.span2loc(span);

            if (loc == null) {

            } else {
                locs.push(loc);
            }
        }

        return locs;
    },

    span2loc: function(span) {
        var ps = span.split('~');
        var span_pos_0 = parseInt(ps[0]);
        var span_pos_1 = parseInt(ps[1]);

        if (isNaN(span_pos_0)) {
            return null;
        }
        if (isNaN(span_pos_1)) {
            return null;
        }
        return [
            span_pos_0,
            span_pos_1
        ];
    },

    loc2span: function(loc) {
        return loc[0] + '~' + loc[1];
    },

    locs2spans: function(locs) {
        var spans = [];
        for (let i = 0; i < locs.length; i++) {
            const loc = locs[i];
            var span = this.loc2span(loc);
            spans.push(span);
        }
        spans = spans.join(',');
        return spans;
    },

    hash: function(str, seed) {
        if (typeof(seed) == 'undefined') {
            seed = 0;
        }
        let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;
        for (let i = 0, ch; i < str.length; i++) {
            ch = str.charCodeAt(i);
            h1 = Math.imul(h1 ^ ch, 2654435761);
            h2 = Math.imul(h2 ^ ch, 1597334677);
        }
        h1 = Math.imul(h1 ^ (h1>>>16), 2246822507) ^ Math.imul(h2 ^ (h2>>>13), 3266489909);
        h2 = Math.imul(h2 ^ (h2>>>16), 2246822507) ^ Math.imul(h1 ^ (h1>>>13), 3266489909);
        return 4294967296 * (2097151 & h2) + (h1>>>0);
    },

    get_next_tag_id: function(ann, tag_def) {
        var n = 0;
        for (let i = 0; i < ann.tags.length; i++) {
            if (ann.tags[i].tag == tag_def.name) {
                // get the id number of this tag
                var _id = parseInt(ann.tags[i].id.replace(tag_def.id_prefix, ''));
                if (_id >= n) {
                    n = _id + 1;
                }
            }
        }
        return tag_def.id_prefix + n;
    },

    get_tag_by_tag_id: function(tag_id, ann) {
        for (let i = 0; i < ann.tags.length; i++) {
            if (ann.tags[i].id == tag_id) {
                return ann.tags[i];
            }                
        }
        return null;
    },

    get_linked_rtags: function(tag_id, ann) {
        var tags = [];
        for (let i = 0; i < ann.tags.length; i++) {
            const tag = ann.tags[i];
            
            // check if this is itself
            if (tag.id == tag_id) {
                // skip this tag_id itself
                continue;
            }

            for (const attr in tag) {
                if (Object.hasOwnProperty.call(tag, attr)) {
                    if (attr == 'id'   || 
                        attr == 'tag'  ||
                        attr == 'text' ||
                        attr == 'spans'
                    ) {
                        // skip those special attrs
                        continue;
                    }
                    const val = tag[attr];
                    if (val == tag_id) {
                        // ok, this a link ... I guess 
                        tags.push(tag);

                        // then, we don't need to check other attr
                        // just go to next tag
                        break;
                    }
                }
            }
        }
        return tags;
    },


};

// The statistics helper
/**
 * A helper object for the statistics related functions
 */
var stat_helper = {
    /**
     * Get statistics of given anns on dtd
     * 
     * The return item should contain 3 sub-items:
     * [
     *     label
     *     value,
     *     extend_data
     * ]
     * 
     * The extend_data is an object
     * @param {list} anns anns
     * @param {Object} dtd dtd
     * @returns a list of stat results
     */
    get_stat_items: function(anns, dtd) {
        var items = [
            // the basic statistics
            ['# of documents', anns.length, null],
            ['# of tags in schema', dtd.etags.length, null],
            ['# of annotations', this.count_all_tags(anns), null],

            // the frequents
            [
                '# of annotations per tag', 
                this.calc_avg_tags_per_def(anns, dtd),
                null
            ],
            [
                '# of annotations per doc', 
                this.calc_avg_tags_per_doc(anns),
                null
            ],
            [
                '# of sentences',
                this.count_all_sentences(anns),
                null
            ],
            [
                '# of sentences per doc',
                this.calc_avg_sentences_per_doc(anns),
                null
            ],
            
        ];

        // the number by tags
        var cnt = this.count_tags_by_concepts(anns, dtd);
        for (const tag_name in cnt) {
            if (Object.hasOwnProperty.call(cnt, tag_name)) {
                const val = cnt[tag_name];

                // create a html 
                items.push([
                    '# of ' + tag_name,
                    val,
                    {
                        stat_type: 'tag_count',
                        tag: tag_name
                    }
                ]);
            }
        }

        return items;
    },

    /**
     * Get the statistics summary in JSON format
     * @param {list} raw_summary the raw summary list
     */
    get_stat_summary_json: function(raw_summary) {
        var json = [];

        for (let i = 0; i < raw_summary.length; i++) {
            const s = raw_summary[i];
            json.push({
                'measure': s[0],
                'result': s[1]
            });
        }

        return json;
    },

    /**
     * Get the worksheet of the summary
     * @param {list} raw_summary the raw summary list
     * @returns a XLSX worksheet object 
     */
    get_stat_summary_excelws: function(raw_summary) {
        var js = this.get_stat_summary_json(raw_summary);

        var ws = XLSX.utils.json_to_sheet(js);

        return ws;
    },

    get_stat_docs_by_tags_json: function(anns, dtd) {
        var js = {
            stat: {
                max_by_ann_tag: 0,
                max_by_ann: 0,
                max_by_tag: 0
            },
            rs: [{
                'file_name': 'Summary',
                '_total_tags': 0
            }]
        };

        for (let i = 0; i < anns.length; i++) {
            // each ann is a document
            const ann = anns[i];

            // create a new json object
            var j = {
                'file_name': ann._filename,
                '_total_tags': 0
            };
            
            // to make sure the order of tags, use two loops
            // first, init all the etags
            for (let k = 0; k < dtd.etags.length; k++) {
                const tag = dtd.etags[k];
                // init this tag count
                j[tag.name] = 0;

                // init the first row if not 
                if (!js.rs[0].hasOwnProperty(tag.name)) {
                    js.rs[0][tag.name] = 0;
                }
            }

            // then, init all rtags
            for (let k = 0; k < dtd.rtags.length; k++) {
                const tag = dtd.rtags[k];
                // init this tag count
                j[tag.name] = 0;

                // init the first row if not 
                if (!js.rs[0].hasOwnProperty(tag.name)) {
                    js.rs[0][tag.name] = 0;
                }
            }

            // now, we can count how many tags in this doc
            for (let k = 0; k < ann.tags.length; k++) {
                const tag = ann.tags[k];
                // update the count for this tag
                j[tag.tag] += 1;

                // add a count for max result
                if (j[tag.tag] > js.stat.max_by_ann_tag) {
                    js.stat.max_by_ann_tag = j[tag.tag]
                }

                // update the total of this file
                j['_total_tags'] += 1;

                // update the summary of this concept
                js.rs[0][tag.tag] += 1;

                // add a count for max result
                if (js.rs[0][tag.tag] > js.stat.max_by_tag) {
                    js.stat.max_by_tag = js.rs[0][tag.tag]
                }

                // update the summary of all
                js.rs[0]['_total_tags'] += 1;
            }

            // update the max_by_ann
            if (ann.tags.length > js.stat.max_by_ann) {
                js.stat.max_by_ann = ann.tags.length;
            }

            // ok, done! let's put this j to js list
            js.rs.push(j);
        }

        return js;
    },

    get_stat_docs_by_tags_excelws: function(ann, dtd) {
        var stat = this.get_stat_docs_by_tags_json(ann, dtd);
        var js = stat.rs;

        var ws = XLSX.utils.json_to_sheet(js);

        // now add color to the number cells
        // first, get the max number
        // because the number is counted
        var n_max = this.__get_max_val(js);
        // set a min threshold for this max value
        if (n_max < 10) {
            n_max = 10;
        }
        var func_val2color = function(val) {
            return d3.rgb(
                d3.interpolateReds(val / n_max)
            ).formatHex();
        }
        var func_val2fontc = function(val) {
            if (val / n_max > 0.7) {
                return '#ffffff';
            } else {
                return '#000000';
            }
        }

        // now, check each cell
        for (const coord in ws) {
            if (Object.hasOwnProperty.call(ws, coord)) {
                const obj = ws[coord];
                // skip the system attr
                if (obj.hasOwnProperty('v')) {
                    if (typeof(obj.v) == 'number') {
                        // skip the sum
                        if (coord.startsWith('B')) {
                            continue;
                        }

                        // which means this is a count number
                        // create a color
                        var fg_color = func_val2color(obj.v);
                        var font_color = '#000000';
                        if (obj.v == 0) {
                            fg_color = '#ffffff';
                            font_color = '#cccccc';
                        } else {
                            font_color = func_val2fontc(obj.v);
                        }

                        // set this color
                        ws[coord].s = {
                            fill: {
                                fgColor: {
                                    rgb: fg_color.substring(1)
                                }
                            },
                            font: {
                                color: {
                                    rgb: font_color.substring(1)
                                }
                            }
                        }
                    } else if (typeof(obj.v) == 'string') {
                        // we want to set color for the header
                        if (dtd.tag_dict.hasOwnProperty(obj.v)) {
                            // ok, this is a tag name
                            ws[coord].s = {
                                fill: {
                                    fgColor: {
                                        rgb: dtd.tag_dict[obj.v].style.color.substring(1)
                                    }
                                },
                                font: {
                                    sz: 14
                                }
                            }
                        }
                    } else {
                        // ok, other cell?
                    }
                }
            }
        }

        return ws;
    },


    /**
     * Count the total number of all annotated tags
     * @param {list} anns the anns from vpp
     * @returns the total number annotated tags
     */
    count_all_tags: function(anns) {
        var n = 0;
        for (let i = 0; i < anns.length; i++) {
            for (let j = 0; j < anns[i].tags.length; j++) {
                n += 1;
            }
        }
        return n;
    },

    /**
     * Count the total number of split sentences
     * @param {list} anns the anns from vpp
     * @returns the total number of sentences
     */
    count_all_sentences: function(anns) {
        var n = 0;
        for (let i = 0; i < anns.length; i++) {
            const ann = anns[i];
            if (ann.hasOwnProperty('_sentences')) {
                n += ann._sentences.length;
            }
        }
        return n;
    },

    count_tags_by_concepts: function(anns, dtd) {
        var cnt = {};

        for (const tag_name in dtd.tag_dict) {
            if (Object.hasOwnProperty.call(dtd.tag_dict, tag_name)) {
                const tag_def = dtd.tag_dict[tag_name];
                cnt[tag_def.name] = 0;
            }
        }
        for (let i = 0; i < anns.length; i++) {
            const ann = anns[i];
            for (let j = 0; j < ann.tags.length; j++) {
                const tag = ann.tags[j];
                cnt[tag.tag] += 1;
            }
        }

        return cnt;
    },

    calc_avg_sentences_per_doc: function(anns) {
        if (anns == null || anns.length == 0) {
            return '-';
        }
        var t = this.count_all_sentences(anns);
        return (t/anns.length).toFixed(2);
    },

    calc_avg_tags_per_doc: function(anns) {
        if (anns == null || anns.length == 0) {
            return '-';
        }
        var t = this.count_all_tags(anns);
        return (t/anns.length).toFixed(2);
    },

    calc_avg_tags_per_def: function(anns, dtd) {
        if (anns == null || anns.length == 0) {
            return '-';
        }
        if (dtd == null || dtd.etags.length == 0) {
            return '-';
        }
        return (anns.length / dtd.etags.length).toFixed(2);
    },

    /**
     * stat_helper internal use only
     * @param {list} json the json for the stat report
     * @returns the max value
     */
    __get_max_val: function(json) {
        var max_val = 0;
        // skip the summary, so skip the first row in json
        for (let i = 1; i < json.length; i++) {
            const obj = json[i];
            for (const key in obj) {
                if (key == '_total_tags') {
                    // skip the total column
                    continue;
                }
                if (Object.hasOwnProperty.call(obj, key)) {
                    const val = obj[key];
                    if (val > max_val) {
                        max_val = val;
                    }
                }
            }
        }

        return max_val;
    },

    get_top_n: function(vals, n) {
        // init the top n
        var topn = new Array(n).fill([0, -1]);

        // next, check it
        for (let i = 0; i < vals.length; i++) {
            const val = vals[i];

            // this part can be optimized to O(log(N))
            // but it's OK for now
            for (let j = 0; j < topn.length; j++) {
                const x = topn[j];
                if (val > x[0]) {
                    topn[j] = [val, i];
                    break;
                }
            }
        }

        return topn;
    }
};

// The BioC parser
/**
 * BioC format annotation file parser
 */
var bioc_parser = {

    NON_CONSUMING_SPANS: '-1~-1',

    anns2xml: function(anns, dtd) {
        // create the root document
        var xmlDoc = document.implementation.createDocument(
            null, 'collection'
        );
        var root = xmlDoc.getElementsByTagName('collection')[0];

        // create an empty source tag
        var elem_source = xmlDoc.createElement('source');
        root.appendChild(elem_source);

        // create a date tag
        var elem_date = xmlDoc.createElement('date');
        elem_date.innerHTML = "" + new Date();
        root.appendChild(elem_date);

        // create an empty key tag
        var elem_key = xmlDoc.createElement('key');
        root.appendChild(elem_key);

        // create document for each ann
        for (let i = 0; i < anns.length; i++) {
            const ann = anns[i];

            // create a document tag for this ann
            var elem_doc = xmlDoc.createElement('document');

            // add filename as id to this document
            var elem_id = xmlDoc.createElement('id');
            elem_id.innerHTML = ann._filename;
            elem_doc.appendChild(elem_id);

            // there is only one passage for this doc
            var elem_passage = xmlDoc.createElement('passage');

            // add the offset 0 to this passage
            var elem_poffset = xmlDoc.createElement('offset');
            elem_poffset.innerHTML = '0';
            elem_passage.appendChild(elem_poffset);

            // add the text to this passage
            var elem_ptext = xmlDoc.createElement('text');
            elem_ptext.appendChild(
                xmlDoc.createCDATASection(ann.text)
            );
            elem_passage.appendChild(elem_ptext);

            // add all entity tags to this passage
            for (let j = 0; j < ann.tags.length; j++) {
                const tag = ann.tags[j];
                
                // get the tag def from dtd
                var tag_def = dtd.tag_dict[tag.tag];

                if (tag_def.type == 'etag') {
                    // ok, it is a entity tag
                    // due to the fact of non-continous annoation,
                    // we need to check the spans first
                    var locs = ann_parser.spans2locs(tag.spans);

                    // for most of time, there is only one loc
                    // but sometimes, there are more
                    for (let k = 0; k < locs.length; k++) {
                        const loc = locs[k];

                        // get the attribute for the location element
                        var att_len = loc[1] - loc[0];
                        var att_ofs = loc[0];

                        // each entity tag is an annotation element 
                        var elem_ann = xmlDoc.createElement('annotation');
                        // set the ann elem id 
                        if (locs.length == 1) {
                            // if this is only one loc, just use the id
                            elem_ann.setAttribute('id', tag.id);
                        } else {
                            // otherwise, add suffix
                            elem_ann.setAttribute('id', tag.id + '_' + k);
                        }

                        // create location elements for this ann
                        var elem_location = xmlDoc.createElement('location');
                        elem_location.setAttribute('length', att_len);
                        elem_location.setAttribute('offset', att_ofs);
                        elem_ann.appendChild(elem_location);

                        // set the text content for this annotation
                        var elem_atext = xmlDoc.createElement('text');
                        var atext = ann.text.substring(loc[0], loc[1]);
                        elem_atext.appendChild(
                            xmlDoc.createCDATASection(atext)
                        );
                        elem_ann.appendChild(elem_atext);

                        // ok, let's put other elements in this annotation
                        for (const key in tag) {
                            if (Object.hasOwnProperty.call(tag, key)) {
                                const val = tag[key];
                                if (['id','spans','text','tag'].contains(key)) {
                                    // these keys can be skipped
                                    continue;
                                }
                                
                                // for other key, need to create a infon element
                                var elem_infon = xmlDoc.createElement('infon');
                                elem_infon.setAttribute('key', key);
                                // elem_infon.innerHTML = val;
                                elem_infon.appendChild(
                                    xmlDoc.createTextNode(val)
                                );

                                // ok, add this infon to this annotation
                                elem_ann.appendChild(elem_infon);
                            }
                        }
                        // finally, add this ann to the passage
                        elem_passage.appendChild(elem_ann);
                    }

                } else if (tag_def.type == 'rtag') {
                    // ok, it is a link tag

                    // each link tag is an relation element 
                    var elem_rel = xmlDoc.createElement('relation');
                    // set the id
                    elem_rel.setAttribute('id', tag.id);

                    // let's check each value
                    // ok, let's put other elements in this relation
                    for (const key in tag) {
                        if (Object.hasOwnProperty.call(tag, key)) {
                            const val = tag[key];
                            if (['id','spans','text','tag'].contains(key)) {
                                // these keys can be skipped
                                continue;
                            }
                            
                            // for other key, need to check attr type first
                            var att_def = tag_def.attr_dict[key];

                            if (att_def.vtype == 'idref') {
                                // for idref type, need to create node
                                var elem_node = xmlDoc.createElement('node');
                                // set the refid
                                elem_node.setAttribute('refid', val);
                                // set the role as the attr name
                                elem_node.setAttribute('role', att_def.name);

                                // add this node
                                elem_rel.appendChild(elem_node);

                            } else {
                                // for other types, just create a infon
                                var elem_infon = xmlDoc.createElement('infon');
                                elem_infon.setAttribute('key', key);
                                // elem_infon.innerHTML = val;
                                elem_infon.appendChild(
                                    xmlDoc.createTextNode(val)
                                );

                                // ok, add this infon to this annotation
                                elem_rel.appendChild(elem_infon);
                            }
                        }
                    }

                    // ok, save this relation
                    // finally, add this relation to the passage
                    elem_passage.appendChild(elem_rel);

                } else {
                    // what???

                }
            }

            // add this passage to the doc
            elem_doc.appendChild(elem_passage);

            // add this doc to the collection
            root.appendChild(elem_doc);
        }

        return xmlDoc;
    },

    xml2str: function(xmlDoc) {
        const serializer = new XMLSerializer();
        var xmlStr = serializer.serializeToString(xmlDoc);

        // fix missing 
        if (xmlStr.startsWith('<?xml')) {
            // nothing, it' OK
        } else {
            xmlStr = '<?xml version="1.0" encoding="UTF-8" ?>\n<!DOCTYPE collection SYSTEM "BioC.dtd">\n' + xmlStr;
        }
        return xmlStr;
    },

    /**
     * Download the BioC format dataset
     * 
     * @param {list} anns the list of ann object
     * @param {object} dtd the dtd schema
     * @param {string} fn the download file name
     */
     download_dataset_bioc: function(anns, dtd, fn) {
        // get the xml doc
        var xmlDoc = this.anns2xml(anns, dtd);

        // get the string for xml
        var xmlStr = this.xml2str(xmlDoc);

        // download
        var blob = new Blob([xmlStr], {type: "text/xml;charset=utf-8"});
        // saveAs(blob, fn);

        return xmlStr;
     }
};

// The Rulepack toolkit
/**
 * Easy Rule Pack Toolkit
 */
var erp_toolkit = {
    rp: {
        prefix: {
            rsregexp: 'resources_regexp_re'
        }
    },

    ///////////////////////////////////////////////////////
    // Rule Pack Functions
    ///////////////////////////////////////////////////////
    create_new_rulepack: function () {
        return {
            name: '',
            matchrules: [ ],
            rsregexps: [ ],
            contexts: [ ],
            fns: {
                used_resources: 'used_resources.txt',
                resources_rules_matchrules: 'resources_rules_matchrules.txt'
            }
        };
    },

    create_new_matchrule: function () {
        return {
            rule_name: 'cm_fever',
            regexp: '\\b(?i)(?:%reFEVER)\\b',
            location: 'NA',
            enabled: true,
            ignore_case: true,
            norm: 'FEVER'
        };
    },

    create_new_rsregexp: function () {
        return {
            name: 'FEVER',
            text: 'fever\nfebris\nfebrile'
        };
    },

    create_new_context: function() {
        var num = 0;
        if (this.vpp != null) {
            if (this.vpp.rulepack != null) {
                if (typeof(this.vpp.rulepack) != 'undefined') {
                    if (typeof(this.vpp.rulepack.contexts) != 'undefined') {
                        num = this.vpp.rulepack.contexts.length;
                    }
                }
            }
        }
        return {
            name: 'contextRule' + num,
            text: erp_toolkit.MEDTAGGER_CONTEXT_RULE
            // text: 'regex:(^|\s)\?(?=\s?\w+)~|~pre~|~poss~|~1\ndoes not demonstrate~|~pre~|~neg~|~1\ndid not demonstrate~|~pre~|~neg~|~1\ndo not demonstrate~|~pre~|~neg~|~1'
        };
    },

    rulepack2zip: function(rulepack) {
        var zip = new JSZip();

        // create the file list of regexp
        var txt_fns = '';
        for (var i = 0; i < rulepack.rsregexps.length; i++) {
            var rsregexp = rulepack.rsregexps[i];
            var ffn = 'regexp/' + this.rp.prefix.rsregexp + rsregexp.name + '.txt';
            var txt = rsregexp.text;
            txt_fns += './' + ffn + '\n';
            // add to zip
            zip.file(ffn, txt);
            console.log('* add ' + ffn);
        }
        
        // create the context rules
        for (var i = 0; i < rulepack.contexts.length; i++) {
            var context = rulepack.contexts[i];
            var ffn = 'context/' + context.name + '.txt';
            var txt = context.text;
            txt_fns += './' + ffn + '\n';
            // add to zip
            zip.file(ffn, txt);
            console.log('* add ' + ffn);
        }

        // create the rule file
        var rules = '// ' + rulepack.name + '\n';
        for (let i = 0; i < rulepack.matchrules.length; i++) {
            const matchrule = rulepack.matchrules[i];
            rules += 'RULENAME="' + matchrule.rule_name + '",';
            rules += 'REGEXP="' + matchrule.regexp + '",';
            rules += 'LOCATION="' + matchrule.location + '",';
            rules += 'NORM="' + matchrule.norm + '"\n';
        }
        var rule_fn = 'rules/' + rulepack.fns.resources_rules_matchrules;
        txt_fns += './' + rule_fn + '\n';

        zip.file(rule_fn, rules);
        console.log('* add ' + rule_fn);

        // create the used_resources.txt
        txt_fns += './' + rulepack.fns.used_resources + '\n';
        zip.file(rulepack.fns.used_resources, txt_fns);

        return zip;
    },
    
    ///////////////////////////////////////////////////////
    // Easy Pack Functions
    ///////////////////////////////////////////////////////
    create_new_easypack: function(rule_pack_name) {
        if (typeof(rule_pack_name)=='undefined') {
            rule_pack_name = 'rule_pack_name';
        }
        return {
            name: rule_pack_name,
            contexts: [ this.create_new_context() ],
            ergroups: [ ]
        }
    },

    create_new_ergroup: function(norm, text) {
        // set the default norm
        if (typeof(norm) == 'undefined') {
            norm = 'NAME_' + this.mkid(6);
        } else {
            norm = norm.toLocaleUpperCase();
        }

        // set the default text
        if (typeof(text) == 'undefined') {
            text = '';
        }

        return {
            _is_shown: false,
            norm: norm,
            rule_type: 'cm',
            location: 'NA',
            text: text
        };
    },

    anns2text_dict: function(anns) {
        var text_dict = {};

        for (let i = 0; i < anns.length; i++) {
            const ann = anns[i];
            for (let j = 0; j < ann.tags.length; j++) {
                const tag = ann.tags[j];
                // create the tag_def if not exists
                if (!text_dict.hasOwnProperty(tag.tag)) {
                    // the text_dict is for searching
                    // the texts is for storing
                    text_dict[tag.tag] = {
                        textd: {},
                        texts: []
                    };
                }

                // empty text should be removed

                // but first check the text itself
                if (!tag.hasOwnProperty('text')) {
                    // what?
                    continue;
                }

                var text = tag.text;
                text = text.trim();
                if (text == '') {
                    continue;
                }

                if (text_dict[tag.tag].textd.hasOwnProperty(text)) {
                    // oh, this is NOT a new text
                    // just increase the count
                    text_dict[tag.tag].textd[text] += 1;

                } else {
                    // ok, this is a new text
                    // count +1
                    text_dict[tag.tag].textd[text] = 1;

                    // save this tag
                    text_dict[tag.tag].texts.push(text);
                }
            }
        }

        return text_dict;
    },

    anns2easypack: function(anns, dtd) {
        // first, create an empty easypack
        var easypack = this.create_new_easypack(dtd.name);

        // then create ergroup_dict
        var ergroup_dict = {};

        // using the dtd to init the ergroup_dict
        for (let i = 0; i < dtd.etags.length; i++) {
            const tag = dtd.etags[i];
            
            // create a new ergroup from this tag
            var ergroup = this.create_new_ergroup(tag.name, '');

            // put this ergroup to the dict for furture use
            ergroup_dict[tag.name] = ergroup;
        }

        // then, using the anns to fill the text of each ergroup
        var text_dict = this.anns2text_dict(anns);

        // using this text_dict to fill the ergroup_dict
        for (const tag_name in text_dict) {
            if (Object.hasOwnProperty.call(text_dict, tag_name)) {
                // check each text in each tag_name
                for (let k = 0; k < text_dict[tag_name].texts.length; k++) {
                    const text = text_dict[tag_name].texts[k];

                    // just append this text as a new line
                    ergroup_dict[tag_name].text += text + '\n';
                }
            }
        }

        // last, put the ergroup_dict to easypack.ergroups
        for (const tag_name in ergroup_dict) {
            if (Object.hasOwnProperty.call(ergroup_dict, tag_name)) {
                easypack.ergroups.push(ergroup_dict[tag_name]);
            }
        }

        return easypack;
    },

    easypack2rulepack: function(easypack) {
        // create an empty rule pack for converting
        var rulepack = this.create_new_rulepack();
    
        // now update the simple parts according to the easypack
        rulepack.name = easypack.name;
        rulepack.contexts = easypack.contexts;

        // now update the complex parts according to the easypack
        for (let i = 0; i < easypack.ergroups.length; i++) {
            const ergroup = easypack.ergroups[i];
            var regexp_name = this.norm2regexp_name(ergroup.norm);
            var cm_name = regexp_name.toLowerCase();
            
            // create a matchrule
            var matchrule = this.create_new_matchrule();

            // update the matchrule
            // norm is just the norm
            matchrule.norm = ergroup.norm;
            // location is just the location
            matchrule.location = ergroup.location;
            // rule_name is the comb of rule_type and cm_name
            matchrule.rule_name = ergroup.rule_type + '_' + cm_name;
            // regexp is the comb of regexp_name according to the rule_type
            if (ergroup.rule_type == 'cm') {
                matchrule.regexp = '\\b(?i)(?:%re'+regexp_name+')\\b';

            } else if (ergroup.rule_type == 'rem') {
                matchrule.regexp = '\\b(?i)%re'+regexp_name+'\\b';

            } else {
                matchrule.regexp = '\\b(?i)(?:%re'+regexp_name+')\\b';
            }

            // create a rsregexp(?i)
            var rsregexp = this.create_new_rsregexp();

            // update the rsregexp
            rsregexp.name = regexp_name;
            rsregexp.text = ergroup.text;

            // save the new matchrule and rsregexp
            rulepack.matchrules.push(matchrule);
            rulepack.rsregexps.push(rsregexp);
        }

        return rulepack;
    },
    
    ///////////////////////////////////////////////////////
    // Other Functions
    ///////////////////////////////////////////////////////
    mkid: function(length) {
        var result           = '';
        var characters       = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        var charactersLength = characters.length;
        for ( var i = 0; i < length; i++ ) {
            result += characters.charAt(
                Math.floor(Math.random() * charactersLength)
            );
        }
       return result;
    },

    /**
     * Convert the norm to a valid regexp name
     * 
     * @param {string} norm 
     */
    norm2regexp_name: function(norm) {
        return norm.replace(/_/g, "");
    },

    download_zip: function(zip, fn) {
        zip.generateAsync({ type: "blob" }).then((function(fn){
            return function (content) {
                // saveAs(content, fn);
            }
        })(fn));
    },

    download_anns_as_zip: function(anns, dtd, fn) {
        // first, convert anns to easypack
        var easypack = this.anns2easypack(anns, dtd);

        // second, convert easypack to rulepack
        var rulepack = this.easypack2rulepack(easypack);

        // then convert this easypack to zip
        var zip = this.rulepack2zip(rulepack)

        // last, save this zip
        this.download_zip(zip, fn);

        return rulepack;
    },

    MEDTAGGER_CONTEXT_RULE: `// Format regex:?match_string~|~trigger_type~|~context_type~|~rule_priority(~|~window_size_override)?
// JW added start
regex:\?( ?\w+)?~|~pre~|~poss~|~1
does not demonstrate~|~pre~|~neg~|~1
did not demonstrate~|~pre~|~neg~|~1
do not demonstrate~|~pre~|~neg~|~1
regex:\bdo not see (\S+\s+){1,3}that suggests?\b~|~pre~|~neg~|~2
complications include~|~pre~|~hypo~|~1
complications include,~|~pre~|~hypo~|~1
given some brief thought to~|~pre~|~poss~|~1
never been high enough to cause~|~pre~|~poss~|~1
regex:\bno (\S+\s+){1,3} (to|that) suggests?\b~|~pre~|~neg~|~2
// AW added start
which demonstrates~|~termin~|~poss~|~1
interested in~|~pre~|~poss~|~1
etiology indeterminate~|~pseudo~|~poss~|~1
patient and family~|~pseudo~|~exp~|~1
patient and his husband~|~pseudo~|~exp~|~1
patient and her husband~|~pseudo~|~exp~|~1
patient and his wife~|~pseudo~|~exp~|~1
patient and her wife~|~pseudo~|~exp~|~1
patient and his family~|~pseudo~|~exp~|~1
patient and her family~|~pseudo~|~exp~|~1
patient and husband~|~pseudo~|~exp~|~1
patient and wife~|~pseudo~|~exp~|~1
family in the room~|~pseudo~|~exp~|~1
regex:(query|alternative)(?=\s(\S+\s+){1,3}(versus|vs))~|~pre~|~poss~|~1
does not suggest~|~pre~|~neg~|~2
do not suggest~|~pre~|~neg~|~2
did not suggest~|~pre~|~neg~|~2
not suggest~|~pseudo~|~poss~|~1
investigated for~|~pre~|~poss~|~1
investigating for~|~pre~|~poss~|~1
investigate for~|~pre~|~poss~|~1
regex:\bnot? (\S+\s+){1,5}due\b~|~pseudo~|~neg~|~1
no overt~|~pre~|~poss~|~2
likely due to~|~post~|~poss~|~1
resolution of~|~pre~|~neg~|~1
no progression of the~|~pseudo~|~neg~|~1
because~|~termin~|~neg~|~1
consideration given history~|~post~|~hypo~|~1
considered given history~|~post~|~hypo~|~1
consideration given history~|~pre~|~hist~|~1
considered given history~|~pre~|~hist~|~1
patient had~|~termin~|~neg~|~1
patient had~|~pre~|~hist~|~1
was diagnosed~|~termin~|~neg~|~1
was diagnosed~|~pre~|~hist~|~1
regex:;\b~|~termin~|~neg~|~1
from~|~termin~|~poss~|~1
from~|~termin~|~neg~|~1
maybe~|~pre~|~poss~|~1
no date~|~pseudo~|~neg~|~1
no date:~|~pseudo~|~neg~|~1
not limited~|~pseudo~|~neg~|~1
regex:\bfamily history\s*$~|~post~|~exp~|~2
regex:\bfamily history\s*$~|~post~|~hist~|~2
didn't have~|~pre~|~neg~|~1
don't have~|~pre~|~neg~|~1
never used~|~pre~|~neg~|~1
no question~|~pseudo~|~neg~|~1
her2 negative~|~pseudo~|~neg~|~1
who also had~|~pseudo~|~hypoexp~|~1
symptomatology~|~post~|~poss~|~1
pmhx~|~pre~|~hist~|~1
fmhx~|~pre~|~hist~|~1
fmhx~|~pre~|~exp~|~1
family history~|~pre~|~exp~|~1
family history~|~pre~|~hist~|~1
family member~|~pre~|~exp~|~1
likely to pursue~|~pseudo~|~poss~|~1
likely success~|~pseudo~|~poss~|~1
likely failure~|~pseudo~|~poss~|~1
cousin~|~pre~|~exp~|~1
cousins~|~pre~|~exp~|~1
regex:\basymptomatic\s*$~|~post~|~poss~|~2
// AW added end
//KER added start
trace~|~pre~|~poss~|~1
prn~|~pre~|~hypo~|~1
possible~|~pre~|~hypo~|~1
potential~|~pre~|~poss~|~1
mild~|~pre~|~poss~|~1
will be considered~|~post~|~hypo~|~1
would be considered~|~post~|~hypo~|~1
should be considered~|~post~|~hypo~|~1
considered~|~pre~|~hypo~|~1
consider~|~pre~|~hypo~|~1
consideration~|~pre~|~hypo~|~1
should consider~|~pre~|~hypo~|~1
should have~|~pre~|~hypo~|~1
should be offered~|~pre~|~hypo~|~1
scheduled~|~pre~|~hypo~|~1
planned~|~pre~|~hypo~|~1
plans for~|~pre~|~hypo~|~1
plan for~|~pre~|~hypo~|~1
plans are~|~pre~|~hypo~|~1
candidate for~|~pre~|~hypo~|~1
not a candidate for~|~pre~|~neg~|~1
not be a candidate for~|~pre~|~neg~|~1
put off~|~pre~|~hypo~|~1
    vs ~|~pre~|~hypo~|~1
discuss~|~pre~|~hypo~|~1
discussed~|~pre~|~hypo~|~1
discussion~|~pre~|~hypo~|~1
versus~|~pre~|~hypo~|~1
referred~|~pre~|~hypo~|~1
advised~|~pre~|~hypo~|~1
chance~|~pre~|~hypo~|~1
risky~|~post~|~poss~|~1
recommended~|~post~|~poss~|~1
if experiences worsening~|~pre~|~hypo~|~1
does not have~|~pre~|~neg~|~1
doesn't have~|~pre~|~neg~|~1
doesn't appear to have~|~pre~|~neg~|~1
does not appear to have~|~pre~|~neg~|~1
excluding~|~pre~|~neg~|~1
ruled out~|~pre~|~neg~|~1
differential diagnosis~|~pre~|~poss~|~1
would not want to have~|~pre~|~neg~|~1
decline~|~pre~|~neg~|~1
declined~|~pre~|~neg~|~1
//KER added end
//Sunghwan added start
appear~|~pre~|~poss~|~1
appears~|~pre~|~poss~|~1
suspect~|~pre~|~poss~|~1
suspects~|~pre~|~poss~|~1
//appears? to have~|~pre~|~poss //not working why??
to evaluate~|~pre~|~poss~|~1
indeterminate~|~post~|~poss~|~1
indeterminable~|~pre~|~poss~|~1
to prevent~|~pre~|~hypo~|~1
has been instructed~|~pre~|~hypo~|~1
has been instructed in the sign~|~pre~|~hypo~|~1
has been instructed in the signs~|~pre~|~hypo~|~1
should the patient develop~|~pre~|~hypo~|~1
regex:\bno$~|~post~|~neg~|~1
//Sunghwan added end
//following two not working why??
none current~|~post~|~neg~|~1
no current~|~post~|~neg~|~1
hx~|~pre~|~hist~|~1
previous~|~pre~|~hist~|~1
previously~|~pre~|~hist~|~1
previously undergone~|~pre~|~hist~|~1
after undergoing~|~pre~|~hist~|~1
deny~|~pre~|~neg~|~1
no:~|~pre~|~neg~|~1
no :~|~pre~|~neg~|~1
(no~|~pre~|~neg~|~1
--no~|~pre~|~neg~|~1
don't sound like~|~pre~|~neg~|~1
doesn't sound like~|~pre~|~neg~|~1
regex:-? all of which(\s+\S+){0,3} (denies|denied)\b~|~post~|~neg~|~1
denies any of the following symptoms:~|~pre~|~neg~|~1
denies, however,~|~pre~|~neg~|~1
denies any associated~|~pre~|~neg~|~1
denies any significant~|~pre~|~neg~|~1
precaution for~|~pre~|~poss~|~1
resection of~|~pre~|~hist~|~1
debridement of~|~pre~|~hist~|~1
indication for~|~pre~|~hist~|~1
admitted for~|~pre~|~hist~|~1
likely~|~pre~|~poss~|~1
did deny~|~pre~|~neg~|~1
no source of~|~pre~|~poss~|~1
no source for~|~pre~|~poss~|~1
did not show much of~|~pre~|~poss~|~1
did not show much for~|~pre~|~poss~|~1
no definite finding for~|~pre~|~poss~|~1
no definite finding of~|~pre~|~poss~|~1
no definite findings for~|~pre~|~poss~|~1
no definite findings of~|~pre~|~poss~|~1
concern about~|~pre~|~poss~|~1
concerned about~|~pre~|~poss~|~1
would~|~pre~|~poss~|~1
could have~|~pre~|~poss~|~1
may have~|~pre~|~poss~|~1
raise the question of~|~pre~|~poss~|~1
raise the question for~|~pre~|~poss~|~1
raises the question of~|~pre~|~poss~|~1
raises the question for~|~pre~|~poss~|~1
highly unlikely~|~pre~|~poss~|~1
did not show any~|~pre~|~neg~|~1
do not show any~|~pre~|~neg~|~1
does not show any~|~pre~|~neg~|~1
suspicious for~|~pre~|~poss~|~1
suspicion for~|~pre~|~poss~|~1
suspicious of~|~pre~|~poss~|~1
suspicion of~|~pre~|~poss~|~1
a question of~|~pre~|~poss~|~1
a question for~|~pre~|~poss~|~1
without evidence of~|~pre~|~neg~|~1
without evidence for~|~pre~|~neg~|~1
without sign of~|~pre~|~neg~|~1
without sign for~|~pre~|~neg~|~1
without signs of~|~pre~|~neg~|~1
without signs for~|~pre~|~neg~|~1
did not demonstrate~|~pre~|~neg~|~1
suggests~|~pre~|~poss~|~1
suggest~|~pre~|~poss~|~1
neg of~|~pre~|~neg~|~1
neg for~|~pre~|~neg~|~1
whether~|~pre~|~hypo~|~1
sound more like~|~pre~|~poss~|~1
sound like~|~pre~|~poss~|~1
sounds more like~|~pre~|~poss~|~1
sounds like~|~pre~|~poss~|~1
look more like~|~pre~|~poss~|~1
look like~|~pre~|~poss~|~1
looks more like~|~pre~|~poss~|~1
looks like~|~pre~|~poss~|~1
review the use~|~pre~|~poss~|~1
reviewed~|~pre~|~poss~|~1
likely~|~post~|~poss~|~1
will have~|~pre~|~hypo~|~1
may be~|~pre~|~poss~|~1
for excluding~|~pre~|~poss~|~1
potentially represent~|~pre~|~poss~|~1
possibility of~|~pre~|~poss~|~1
possibility for~|~pre~|~poss~|~1
should symptoms suggesting~|~pre~|~poss~|~1
look for~|~pre~|~hypo~|~1
no evidence of~|~pre~|~neg~|~1
no evidences of~|~pre~|~neg~|~1
no evidence for~|~pre~|~neg~|~1
no evidences for~|~pre~|~neg~|~1
no sign of~|~pre~|~neg~|~1
no sign for~|~pre~|~neg~|~1
no signs of~|~pre~|~neg~|~1
no signs for~|~pre~|~neg~|~1
high-risk that she is at for~|~pre~|~hypo~|~1
high-risk that she is at for~|~pre~|~hypo~|~1
high risk that she is at for~|~pre~|~hypo~|~1
high risk that she is at for~|~pre~|~hypo~|~1
high-risk that the patient is at for~|~pre~|~hypo~|~1
high-risk that the patient is at for~|~pre~|~hypo~|~1
high risk that the patient is at for~|~pre~|~hypo~|~1
high risk that the patient is at for~|~pre~|~hypo~|~1
high-risk that he is at for~|~pre~|~hypo~|~1
high-risk that he is at for~|~pre~|~hypo~|~1
high risk that he is at for~|~pre~|~hypo~|~1
high risk that he is at for~|~pre~|~hypo~|~1
risk of~|~pre~|~hypo~|~1
risk for~|~pre~|~hypo~|~1
risks of~|~pre~|~hypo~|~1
risks for~|~pre~|~hypo~|~1
cardiovascular risk~|~pseudo~|~hypo~|~1
cardiovascular risks~|~pseudo~|~hypo~|~1
risk~|~pre~|~hypo~|~1
risks~|~pre~|~hypo~|~1
s/p~|~pre~|~hist~|~1
at high-risk of~|~pre~|~hypo~|~1
at high-risk for~|~pre~|~hypo~|~1
at high risk of~|~pre~|~hypo~|~1
at high risk for~|~pre~|~hypo~|~1
at risk of~|~pre~|~hypo~|~1
at-risk for~|~pre~|~hypo~|~1
at risk of~|~pre~|~hypo~|~1
at-risk for~|~pre~|~hypo~|~1
re-assess~|~pre~|~hypo~|~1
reassess~|~pre~|~hypo~|~1
assess~|~pre~|~hypo~|~1
prior~|~pre~|~hist~|~1
pmh of~|~pre~|~hist~|~1
pmh for~|~pre~|~hist~|~1
concern~|~pre~|~poss~|~1
concerning~|~pre~|~poss~|~1
is concerned~|~post~|~poss~|~1
is concerned of~|~pre~|~poss~|~1
is concerned for~|~pre~|~poss~|~1
a concern of~|~pre~|~poss~|~1
a concern for~|~pre~|~poss~|~1
is possible~|~post~|~poss~|~1
is probable~|~post~|~poss~|~1
is potentional~|~post~|~poss~|~1
no overt clinical sign of~|~pre~|~neg~|~1
no overt clinical sign for~|~pre~|~neg~|~1
no overt clinical signs of~|~pre~|~neg~|~1
no overt clinical signs for~|~pre~|~neg~|~1
monitor of~|~pre~|~hypo~|~1
monitor for~|~pre~|~hypo~|~1
no source of~|~pre~|~neg~|~1
no source for~|~pre~|~neg~|~1
was ruled out of~|~pre~|~neg~|~1
is ruled out of~|~pre~|~neg~|~1
was ruled out for~|~pre~|~neg~|~1
is ruled out for~|~pre~|~neg~|~1
no evidence of~|~pre~|~neg~|~1
no evidence for~|~pre~|~neg~|~1
was negative of~|~pre~|~neg~|~1
was negative for~|~pre~|~neg~|~1
is negative of~|~pre~|~neg~|~1
is negative for~|~pre~|~neg~|~1
probable~|~pre~|~poss~|~1
possible~|~pre~|~poss~|~1
potential~|~pre~|~poss~|~1
probable for~|~pre~|~poss~|~1
probable of~|~pre~|~poss~|~1
possible of~|~pre~|~poss~|~1
possible for~|~pre~|~poss~|~1
potential of~|~pre~|~poss~|~1
potential for~|~pre~|~poss~|~1
negative~|~pre~|~neg~|~1
is possible~|~post~|~poss~|~1
is probable~|~post~|~poss~|~1
is negative~|~post~|~neg~|~1
was possible~|~post~|~poss~|~1
was probable~|~post~|~poss~|~1
was negative~|~post~|~neg~|~1
regex::\s*no\s*(?:$|[,.!?])~|~post~|~neg~|~2
regex::\s*none\s*(?:$|[,.!?])~|~post~|~neg~|~2
asymptomatic~|~pre~|~poss~|~1
//Hongfang added end
absence of~|~pre~|~neg~|~1
absence for~|~pre~|~neg~|~1
adequate to rule her out~|~pre~|~neg~|~1
adequate to rule him out~|~pre~|~neg~|~1
adequate to rule out~|~pre~|~neg~|~1
adequate to rule the patient out~|~pre~|~neg~|~1
although~|~termin~|~neg~|~1
any other~|~pre~|~neg~|~1
apart from~|~termin~|~neg~|~1
are ruled out~|~post~|~neg~|~1
as a cause of~|~termin~|~neg~|~1
as a cause for~|~termin~|~neg~|~1
as a etiology for~|~termin~|~neg~|~1
as a etiology of~|~termin~|~neg~|~1
as a reason for~|~termin~|~neg~|~1
as a reason of~|~termin~|~neg~|~1
as a secondary cause for~|~termin~|~neg~|~1
as a secondary cause of~|~termin~|~neg~|~1
as a secondary etiology for~|~termin~|~neg~|~1
as a secondary etiology of~|~termin~|~neg~|~1
as a secondary origin for~|~termin~|~neg~|~1
as a secondary origin of~|~termin~|~neg~|~1
as a secondary reason for~|~termin~|~neg~|~1
as a secondary reason of~|~termin~|~neg~|~1
as a secondary source for~|~termin~|~neg~|~1
as a secondary source of~|~termin~|~neg~|~1
as a source for~|~termin~|~neg~|~1
as a source of~|~termin~|~neg~|~1
as a cause for~|~termin~|~neg~|~1
as a cause of~|~termin~|~neg~|~1
as an etiology for~|~termin~|~neg~|~1
as an etiology of~|~termin~|~neg~|~1
as an origin for~|~termin~|~neg~|~1
as an origin of~|~termin~|~neg~|~1
as a reason for~|~termin~|~neg~|~1
as a reason of~|~termin~|~neg~|~1
as a secondary cause for~|~termin~|~neg~|~1
as a secondary cause of~|~termin~|~neg~|~1
as a secondary etiology for~|~termin~|~neg~|~1
as a secondary etiology of~|~termin~|~neg~|~1
as a secondary origin for~|~termin~|~neg~|~1
as a secondary origin of~|~termin~|~neg~|~1
as a secondary reason for~|~termin~|~neg~|~1
as a secondary reason of~|~termin~|~neg~|~1
as a secondary source for~|~termin~|~neg~|~1
as a secondary source of~|~termin~|~neg~|~1
as a source for~|~termin~|~neg~|~1
as a source of~|~termin~|~neg~|~1
as has~|~termin~|~neg~|~1
as needed~|~pre~|~hypo~|~1
as the cause for~|~termin~|~neg~|~1
as the cause of~|~termin~|~neg~|~1
as the etiology for~|~termin~|~neg~|~1
as the etiology of~|~termin~|~neg~|~1
as the origin for~|~termin~|~neg~|~1
as the origin of~|~termin~|~neg~|~1
as the reason for~|~termin~|~neg~|~1
as the reason of~|~termin~|~neg~|~1
as the secondary cause for~|~termin~|~neg~|~1
as the secondary cause of~|~termin~|~neg~|~1
as the secondary etiology for~|~termin~|~neg~|~1
as the secondary etiology of~|~termin~|~neg~|~1
as the secondary origin for~|~termin~|~neg~|~1
as the secondary origin of~|~termin~|~neg~|~1
as the secondary reason for~|~termin~|~neg~|~1
as the secondary reason of~|~termin~|~neg~|~1
as the secondary source for~|~termin~|~neg~|~1
as the secondary source of~|~termin~|~neg~|~1
as the source for~|~termin~|~neg~|~1
as the source of~|~termin~|~neg~|~1
as well as any~|~pre~|~neg~|~1
aside from~|~termin~|~neg~|~1
aunt~|~pre~|~exp~|~1
aunt:~|~pre~|~exp~|~1
aunts~|~pre~|~exp~|~1
aunt's~|~pre~|~exp~|~1
be ruled out~|~post~|~poss~|~1
be ruled out for~|~pre~|~poss~|~1
because~|~termin~|~hypo~|~1
being ruled out~|~post~|~poss~|~1
brother~|~pre~|~exp~|~1
brother:~|~pre~|~exp~|~1
brother's~|~pre~|~exp~|~1
brothers~|~pre~|~exp~|~1
but~|~termin~|~neg~|~1
can be ruled out~|~post~|~neg~|~1
can be ruled out for~|~pre~|~neg~|~1
can rule her out~|~pre~|~neg~|~1
can rule her out against~|~pre~|~neg~|~1
can rule her out for~|~pre~|~neg~|~1
can rule him out~|~pre~|~neg~|~1
can rule him out against~|~pre~|~neg~|~1
can rule him out for~|~pre~|~neg~|~1
can rule out~|~pre~|~neg~|~1
can rule out against~|~pre~|~neg~|~1
can rule out for~|~pre~|~neg~|~1
can rule the patient out~|~pre~|~neg~|~1
can rule the patinet out against~|~pre~|~neg~|~1
can rule the patinet out for~|~pre~|~neg~|~1
cannot~|~pre~|~neg~|~1
cannot exclude~|~pre~|~poss~|~2
cause for~|~termin~|~neg~|~1
cause of~|~termin~|~neg~|~1
causes for~|~termin~|~neg~|~1
causes of~|~termin~|~neg~|~1
checked for~|~pre~|~neg~|~1
clear of~|~pre~|~neg~|~1
come back for~|~pre~|~hypo~|~1
come back to~|~pre~|~hypo~|~1
complains~|~termin~|~histexp~|~1
could be ruled out~|~post~|~poss~|~1
//could be~|~both~|~poss~|~1
could be ruled out for~|~pre~|~poss~|~1
currently~|~termin~|~histexp~|~1
dad~|~pre~|~exp~|~1
dad:~|~pre~|~exp~|~1
dad's~|~pre~|~exp~|~1
declined~|~pre~|~neg~|~1
declines~|~pre~|~neg~|~1
denied~|~pre~|~neg~|~1
denies~|~pre~|~neg~|~1
denying~|~pre~|~neg~|~1
did not rule out~|~post~|~poss~|~1
did rule her out~|~pre~|~neg~|~1
did rule her out against~|~pre~|~neg~|~1
did rule her out for~|~pre~|~neg~|~1
did rule him out~|~pre~|~neg~|~1
did rule him out against~|~pre~|~neg~|~1
did rule him out for~|~pre~|~neg~|~1
did rule out~|~pre~|~neg~|~1
did rule out against~|~pre~|~neg~|~1
did rule out for~|~pre~|~neg~|~1
did rule the patient out~|~pre~|~neg~|~1
did rule the patient out against~|~pre~|~neg~|~1
did rule the patient out for~|~pre~|~neg~|~1
doesn't look like~|~pre~|~neg~|~1
ed~|~termin~|~hist~|~1
emergency department~|~termin~|~hist~|~1
etiology for~|~termin~|~neg~|~1
etiology of~|~termin~|~neg~|~1
evaluate for~|~pre~|~neg~|~1
evaluation for~|~pre~|~neg~|~1
except~|~termin~|~neg~|~1
fails to reveal~|~pre~|~neg~|~1
family~|~pre~|~exp~|~1
fam hx~|~pre~|~exp~|~1
fam hx:~|~pre~|~exp~|~1
father~|~pre~|~exp~|~1
father:~|~pre~|~exp~|~1
father's~|~pre~|~exp~|~1
free~|~post~|~neg~|~1
free of~|~pre~|~neg~|~1
gram negative~|~pseudo~|~neg~|~1
grandfather~|~pre~|~exp~|~1
grandfather's~|~pre~|~exp~|~1
grandfather:~|~pre~|~exp~|~1
grandmother~|~pre~|~exp~|~1
grandmother's~|~pre~|~exp~|~1
grandmother:~|~pre~|~exp~|~1
has been negative~|~post~|~neg~|~1
has been ruled out~|~post~|~neg~|~1
have been ruled out~|~post~|~neg~|~1
her~|~termin~|~hypoexp~|~1
his~|~termin~|~hypoexp~|~1
hx of~|~pre~|~hist~|~1
h/o~|~pre~|~hist~|~1
statuspost~|~pre~|~hist~|~1
status/post~|~pre~|~hist~|~1
status-post~|~pre~|~hist~|~1
status post~|~pre~|~hist~|~1
year ago~|~pre~|~hist~|~1
year ago~|~post~|~hist~|~1
years ago~|~pre~|~hist~|~1
years ago~|~post~|~hist~|~1
have had~|~pre~|~hist~|~1
has had~|~pre~|~hist~|~1
had~|~pre~|~hist~|~1
underwent~|~pre~|~hist~|~1
husband~|~pre~|~exp~|~1
ho~|~pre~|~hist~|~1
history~|~pre~|~hist~|~1
history of~|~pre~|~hist~|~1
history and~|~pseudo~|~hist~|~1
history and examination~|~pseudo~|~hist~|~1
history and physical~|~pseudo~|~hist~|~1
history for~|~pseudo~|~hist~|~1
history of chief complaint~|~pseudo~|~hist~|~1
history of present illness~|~pseudo~|~hist~|~1
history taking~|~pseudo~|~hist~|~1
history, physical~|~pseudo~|~hist~|~1
however~|~termin~|~neg~|~1
if~|~pre~|~hypo~|~1
if negative~|~pseudo~|~hypo~|~1
inconsistent with~|~pre~|~neg~|~1
is not~|~pre~|~neg~|~1
is ruled out~|~post~|~neg~|~1
is to be ruled out~|~post~|~poss~|~1
is to be ruled out for~|~pre~|~poss~|~1
isn't~|~pre~|~neg~|~1
lack of~|~pre~|~neg~|~1
lacked~|~pre~|~neg~|~1
may be ruled out~|~post~|~poss~|~1
may be ruled out for~|~pre~|~poss~|~1
discussed~|~pre~|~poss~|~1
might be ruled out~|~post~|~poss~|~1
might be ruled out for~|~pre~|~poss~|~1
mom~|~pre~|~exp~|~1
mom:~|~pre~|~exp~|~1
mom's~|~pre~|~exp~|~1
mother~|~pre~|~exp~|~1
mother:~|~pre~|~exp~|~1
mother's~|~pre~|~exp~|~1
must be ruled out~|~post~|~poss~|~1
must be ruled out for~|~pre~|~poss~|~1
negative for~|~pre~|~neg~|~1
never developed~|~pre~|~neg~|~1
never had~|~pre~|~neg~|~1
nevertheless~|~termin~|~neg~|~1
no~|~pre~|~neg~|~1
no abnormal~|~pre~|~neg~|~1
no cause of~|~pre~|~neg~|~1
no change~|~pseudo~|~neg~|~1
no complaints of~|~pre~|~neg~|~1
no definite change~|~pseudo~|~neg~|~1
no evidence~|~pre~|~neg~|~1
no evidence to suggest~|~pre~|~neg~|~1
no findings of~|~pre~|~neg~|~1
no findings to indicate~|~pre~|~neg~|~1
no history of~|~pre~|~neg~|~1
no increase~|~pseudo~|~neg~|~1
no interval change~|~pseudo~|~neg~|~1
no longer present~|~post~|~neg~|~1
no mammographic evidence of~|~pre~|~neg~|~1
no new~|~pre~|~neg~|~1
no new evidence~|~pre~|~neg~|~1
no other evidence~|~pre~|~neg~|~1
no radiographic evidence of~|~pre~|~neg~|~1
no sign of~|~pre~|~neg~|~1
no significant~|~pre~|~neg~|~1
no significant change~|~pseudo~|~neg~|~1
no significant interval change~|~pseudo~|~neg~|~1
no signs of~|~pre~|~neg~|~1
no suggestion of~|~pre~|~neg~|~1
no suspicious~|~pre~|~neg~|~1
no suspicious change~|~pseudo~|~neg~|~1
non diagnostic~|~post~|~neg~|~1
not~|~pre~|~neg~|~1
not appear~|~pre~|~neg~|~1
not appreciate~|~pre~|~neg~|~1
not associated with~|~pre~|~neg~|~1
not been ruled out~|~post~|~poss~|~1
not cause~|~pseudo~|~neg~|~1
not certain if~|~pseudo~|~neg~|~1
not certain whether~|~pseudo~|~neg~|~1
not complain of~|~pre~|~neg~|~1
not demonstrate~|~pre~|~neg~|~1
not drain~|~pseudo~|~neg~|~1
not exhibit~|~pre~|~neg~|~1
not extend~|~pseudo~|~neg~|~1
not feel~|~pre~|~neg~|~1
not had~|~pre~|~neg~|~1
not have~|~pre~|~neg~|~1
not have evidence of~|~pre~|~neg~|~1
not know of~|~pre~|~neg~|~1
not known to have~|~pre~|~neg~|~1
not necessarily~|~pseudo~|~neg~|~1
not on~|~pseudo~|~neg~|~1
not only~|~pseudo~|~neg~|~1
not recommended~|~post~|~neg~|~1
not recommend~|~pre~|~neg~|~1
not recommending~|~pre~|~neg~|~1
not reveal~|~pre~|~neg~|~1
not ruled out~|~post~|~poss~|~1
not see~|~pre~|~neg~|~1
not to be~|~pre~|~neg~|~1
nothing to suggest~|~pre~|~neg~|~2
noted~|~termin~|~histexp~|~1
now resolved~|~post~|~neg~|~1
origin for~|~termin~|~neg~|~1
origin of~|~termin~|~neg~|~1
origins for~|~termin~|~neg~|~1
origins of~|~termin~|~neg~|~1
other possibilities of~|~termin~|~neg~|~1
ought to be ruled out~|~post~|~poss~|~1
ought to be ruled out for~|~pre~|~poss~|~1
past history~|~pre~|~hist~|~1
past~|~pre~|~hist~|~1
following up~|~pre~|~hist~|~1
following~|~pre~|~hist~|~1
received~|~pre~|~hist~|~1
past medical history~|~pre~|~hist~|~1
patient~|~termin~|~hypoexp~|~1
patient was not~|~pre~|~neg~|~1
patient's~|~termin~|~hypoexp~|~1
poor history~|~pseudo~|~hist~|~1
presenting~|~termin~|~histexp~|~1
presents~|~termin~|~histexp~|~1
prophylaxis~|~post~|~neg~|~1
r/o~|~pre~|~neg~|~1
rather than~|~pre~|~neg~|~1
reason for~|~termin~|~neg~|~1
reason of~|~termin~|~neg~|~1
reasons for~|~termin~|~neg~|~1
reasons of~|~termin~|~neg~|~1
reported~|~termin~|~histexp~|~1
reports~|~termin~|~histexp~|~1
resolved~|~pre~|~neg~|~1
resolved after~|~post~|~neg~|~1
return~|~pre~|~hypo~|~1
ro~|~pre~|~neg~|~1
rule her out~|~pre~|~neg~|~1
rule her out for~|~pre~|~neg~|~1
rule him out~|~pre~|~neg~|~1
rule him out for~|~pre~|~neg~|~1
rule out~|~pre~|~neg~|~1
rule out for~|~pre~|~neg~|~1
rule the patient out~|~pre~|~neg~|~1
rule the patinet out for~|~pre~|~neg~|~1
ruled her out~|~pre~|~neg~|~1
ruled her out against~|~pre~|~neg~|~1
ruled her out for~|~pre~|~neg~|~1
ruled him out~|~pre~|~neg~|~1
ruled him out against~|~pre~|~neg~|~1
ruled him out for~|~pre~|~neg~|~1
ruled out~|~pre~|~neg~|~1
ruled out against~|~pre~|~neg~|~1
ruled out for~|~pre~|~neg~|~1
ruled the patient out~|~pre~|~neg~|~1
ruled the patient out against~|~pre~|~neg~|~1
ruled the patient out for~|~pre~|~neg~|~1
rules her out~|~pre~|~neg~|~1
rules her out for~|~pre~|~neg~|~1
rules him out~|~pre~|~neg~|~1
rules him out for~|~pre~|~neg~|~1
rules out~|~pre~|~neg~|~1
rules out for~|~pre~|~neg~|~1
rules the patient out~|~pre~|~neg~|~1
rules the patient out for~|~pre~|~neg~|~1
secondary~|~termin~|~neg~|~1
secondary to~|~termin~|~neg~|~1
should be ruled out~|~post~|~neg~|~1
should be ruled out for~|~pre~|~neg~|~1
should he~|~pre~|~hypo~|~1
should she~|~pre~|~hypo~|~1
should the patient~|~pre~|~hypo~|~1
should there~|~pre~|~hypo~|~1
since~|~termin~|~hypo~|~1
sister~|~pre~|~exp~|~1
sister's~|~pre~|~exp~|~1
social history~|~pseudo~|~hist~|~1
son~|~pre~|~exp~|~1
source for~|~termin~|~neg~|~1
source of~|~termin~|~neg~|~1
sources for~|~termin~|~neg~|~1
sources of~|~termin~|~neg~|~1
states~|~termin~|~histexp~|~1
still~|~termin~|~neg~|~1
sudden onset of~|~pseudo~|~hist~|~1
sufficient to rule her out~|~pre~|~neg~|~1
sufficient to rule her out against~|~pre~|~neg~|~1
sufficient to rule her out for~|~pre~|~neg~|~1
sufficient to rule him out~|~pre~|~neg~|~1
sufficient to rule him out against~|~pre~|~neg~|~1
sufficient to rule him out for~|~pre~|~neg~|~1
sufficient to rule out~|~pre~|~neg~|~1
sufficient to rule out against~|~pre~|~neg~|~1
sufficient to rule out for~|~pre~|~neg~|~1
sufficient to rule the patient out~|~pre~|~neg~|~1
sufficient to rule the patient out against~|~pre~|~neg~|~1
sufficient to rule the patient out for~|~pre~|~neg~|~1
test for~|~pre~|~neg~|~1
though~|~termin~|~neg~|~1
to exclude~|~pre~|~neg~|~1
today~|~termin~|~histexp~|~1
trigger event for~|~termin~|~neg~|~1
uncle~|~pre~|~exp~|~1
uncle:~|~pre~|~exp~|~1
uncle's~|~pre~|~exp~|~1
unlikely~|~post~|~neg~|~1
unremarkable for~|~pre~|~neg~|~1
was found~|~termin~|~histexp~|~1
was negative~|~post~|~neg~|~1
was not~|~pre~|~neg~|~1
was ruled out~|~post~|~neg~|~1
wasn't~|~pre~|~neg~|~1
what must be ruled out is~|~pre~|~poss~|~1
which~|~termin~|~exp~|~1
wife~|~pre~|~exp~|~1
who~|~termin~|~hypoexp~|~1
will be ruled out~|~post~|~poss~|~1
will be ruled out for~|~pre~|~poss~|~1
with no~|~pre~|~neg~|~1
without~|~pre~|~neg~|~1
without any evidence of~|~pre~|~neg~|~1
without difficulty~|~pseudo~|~neg~|~1
without evidence~|~pre~|~neg~|~1
without indication of~|~pre~|~neg~|~1
without sign of~|~pre~|~neg~|~1
yet~|~termin~|~neg~|~1
    `
};

// The spaCy toolkit
var spacy_toolkit = {

    download_anns_as_jsonl: function(anns, dtd, fn) {
        // create patterns
        var patterns = this.anns2patterns(anns);

        // get the text
        var str = this.patterns2str(patterns);

        // download
        var blob = new Blob([str], {type: "text/txt;charset=utf-8"});
        // saveAs(blob, fn);

        return str;
    },

    anns2patterns: function(anns) {
        // use a dictionary for sorting
        var patterns = {};
        
        // check each ann
        for (let i = 0; i < anns.length; i++) {
            const ann = anns[i];

            // check each tag in this ann
            for (let j = 0; j < ann.tags.length; j++) {
                const tag = ann.tags[j];
                var tag_name = tag.tag;

                if (patterns.hasOwnProperty(tag_name)) {
                    
                } else {
                    patterns[tag_name] = {
                        text_dict: {},
                        pattern_list: []
                    }
                }
                
                // create a pharse pattern

                // but first check the text itself
                if (!tag.hasOwnProperty('text')) {
                    // what?
                    continue;
                }
                var text = tag.text;

                if (text == null) { 
                    // what?
                    continue;
                }

                // remove blank
                text = text.trim();

                if (text == '') {
                    // what??
                    continue;
                }
                
                // change to lower
                text = text.toLocaleLowerCase();

                if (patterns[tag_name].text_dict.hasOwnProperty(text)) {
                    // skip existed text
                    patterns[tag_name].text_dict[text] += 1;
                    continue;
                }

                // create a new pattern
                var p = {
                    label: tag_name.toLocaleUpperCase(),
                    pattern: text,
                    id: tag_name
                };

                // add this as a new pattern
                patterns[tag_name].pattern_list.push(p);
                patterns[tag_name].text_dict[text] = 1;
            }
        }

        // convert the patterns to a list
        var all_patterns = [];
        for (const tag_name in patterns) {
            if (Object.hasOwnProperty.call(patterns, tag_name)) {
                for (let i = 0; i < patterns[tag_name].pattern_list.length; i++) {
                    const p = patterns[tag_name].pattern_list[i];
                    all_patterns.push(p);
                }
            }
        }

        return all_patterns;
    },

    patterns2str: function(patterns) {
        var strs = [];
        for (let i = 0; i < patterns.length; i++) {
            const p = patterns[i];
            var p_str = JSON.stringify(p);
            strs.push(p_str);
        }

        return strs.join('\n');
    }
};

// The IAA Calculator
var iaa_calculator = {
    colors: {
        decision_agreed: '94d2bd',
        decision_disagreed: 'f4978e',
        annotator_a_tag: 'd9e9f1',
        annotator_b_tag: 'd8f7d6',
    },

    default_overlap_ratio: 0.1,

    make_ann_by_iaa: function(ann_rst, ann_iaa, dtd) {
        // create a blank ann by the ann_rst's ann
        var ann = JSON.parse(JSON.stringify(ann_rst.ann));

        // clear the ann tags
        ann.tags = [];

        // clear the meta
        ann.meta = {};

        // check each cate
        var cms = ['tp', 'fp', 'fn'];

        // check the ann in 
        for (const tag_name in ann_iaa.rst.tag) {
            if (Object.hasOwnProperty.call(ann_iaa.rst.tag, tag_name)) {
                const tag_rst = ann_iaa.rst.tag[tag_name].cm.tags;

                for (let i = 0; i < cms.length; i++) {
                    const cm = cms[i];
                    
                    for (let j = 0; j < tag_rst[cm].length; j++) {
                        if (tag_rst[cm][j] == null) {
                            // for ann_iaa, this is not possible
                            continue;
                        }
                        
                        // there may be two tags
                        for (let k = 0; k < 2; k++) {
                            const _tag = tag_rst[cm][j][k];

                            if (cm == 'tp' && k == 1) {
                                // for true positive, just skip the second one
                                continue;
                            }

                            if (_tag == null) {
                                // yes, it's possible for fn
                                continue;
                            }
                            
                            // ok, now we need to save this tag
                            var tag = Object.assign({}, _tag);
                            var tag_def = dtd.tag_dict[tag.tag];

                            // get a new id for this tag
                            var new_id = ann_parser.get_next_tag_id(ann, tag_def);
    
                            // now, set this tag and put it into list
                            tag.id = new_id;
    
                            // add annotator
                            // locate where this tag comes from
                            if (cm == 'tp') {
                                tag._annotator = 'AB';
                                
                            } else if (cm == 'fn') {
                                tag._annotator = 'B';
    
                            } else {
                                tag._annotator = {
                                    0: 'A',
                                    1: 'B'
                                }[k];
                            }
    
                            ann.tags.push(tag);
                        }
                    }
                }
            }
        }

        return ann;
    },
    
    make_ann_by_rst: function(ann_rst, dtd) {
        var ann = JSON.parse(JSON.stringify(ann_rst.ann));

        // clear the ann tags
        ann.tags = [];

        // clear the meta
        ann.meta = {};

        // check each cate
        var cms = ['tp', 'fp', 'fn'];

        for (const tag_name in ann_rst.rst) {
            if (Object.hasOwnProperty.call(ann_rst.rst, tag_name)) {
                const tag_rst = ann_rst.rst[tag_name];

                for (let i = 0; i < cms.length; i++) {
                    const cm = cms[i];
                    
                    for (let j = 0; j < tag_rst[cm].length; j++) {
                        // 2022-04-19: fix download bug due to null tag_rst[cm][j]
                        if (tag_rst[cm][j] == null) {
                            // this situation is possible due to double rejection
                            // so no tag def can be found
                            continue;
                        }
                        var tag = Object.assign({}, tag_rst[cm][j].tag);
                        var tag_def = dtd.tag_dict[tag.tag];

                        // get a new id for this tag
                        var new_id = ann_parser.get_next_tag_id(ann, tag_def);

                        // now, set this tag and put it into list
                        tag.id = new_id;

                        // 2022-05-11: add annotator
                        // locate where this tag comes from
                        if (cm == 'tp') {
                            tag._annotator = 'AB';
                            
                        } else if (cm == 'fp') {
                            tag._annotator = 'A';

                        } else {
                            tag._annotator = 'B';
                        }

                        ann.tags.push(tag);
                    }
                }
            }
        }

        return ann;
    },

    get_default_gs_dict: function(dtd, iaa_dict) {
        // the core of gs is similar to the iaa_dict.ann
        // which is a hashcode based dictionary.
        // and the inner data is similar.
        /*
        {
            hashcode: {
                ann: ann_obj // but the tags are empty,
                rst: {
                    tag_name: {
                        tp: [{tag: tag, from: 'a'}, ...],
                        fp: [],
                        fn: []
                    }
                }
            }
        }

        the length of tp, fp, fn is exactly equal to the iaa_dict
        */
        var gs_dict = {};

        var cnt = 0;
        for (const hashcode in iaa_dict.ann) {
            if (Object.hasOwnProperty.call(iaa_dict.ann, hashcode)) {
                // deep copy a new object
                const ann_rst = JSON.parse(JSON.stringify(iaa_dict.ann[hashcode]));
                cnt += 1;

                // rename the 
                gs_dict[hashcode] = {
                    // copy the ann_a as defult
                    ann: ann_rst.anns[0],
                    rst: {}
                }

                // rename the gs
                var fn_gs = "G_" + this.find_lcs(
                    ann_rst.anns[0]._filename,
                    ann_rst.anns[1]._filename
                ) + '_' + cnt + '.xml';
                
                gs_dict[hashcode].ann._filename = fn_gs;

                // remove the _fh
                delete gs_dict[hashcode].ann._fh;

                // empty the existing tags
                gs_dict[hashcode].ann.tags = [];

                // add one more 
                gs_dict[hashcode].ann._has_star = false;

                for (const tag_name in ann_rst.rst.tag) {
                    if (Object.hasOwnProperty.call(ann_rst.rst.tag, tag_name)) {
                        const tag_rst = ann_rst.rst.tag[tag_name];
                        gs_dict[hashcode].rst[tag_name] = {
                            tp: [],
                            fp: [],
                            fn: []
                        }

                        // fill each in tp
                        for (let i = 0; i < tag_rst.cm.tags.tp.length; i++) {
                            const tags = tag_rst.cm.tags.tp[i];
                            // use ann_a's result
                            gs_dict[hashcode].rst[tag_name].tp.push({
                                tag: tags[0],
                                from: 'A'
                            });
                        }

                        // fill each in fp
                        for (let i = 0; i < tag_rst.cm.tags.fp.length; i++) {
                            const tags = tag_rst.cm.tags.fp[i];
                            // use ann_a's result
                            gs_dict[hashcode].rst[tag_name].fp.push({
                                tag: tags[0],
                                from: 'A'
                            });
                        }
                        
                        // fill each in fn
                        for (let i = 0; i < tag_rst.cm.tags.fn.length; i++) {
                            const tags = tag_rst.cm.tags.fn[i];
                            // use ann_b's result
                            gs_dict[hashcode].rst[tag_name].fn.push({
                                tag: tags[1],
                                from: 'B'
                            });
                        }
                    }
                }
            }
        }

        return gs_dict;
    },

    get_iaa_report_cohen_kappa_json: function(iaa_dict, dtd) {
        // there are the following columns in the cohen's kappa
        // N + 3
        // where the N is the total number of tags
        // the 3 columns are A, EMPTY for B, and P_b
        var js = [];

        // the first row, just names
        // var j = {
        //     'tag_name': ''
        // };
        // for (let i = 0; i < dtd.etags.length; i++) {
        //     const tag_def_col = dtd.etags[i];
        //     j[tag_def_col.name] = tag_def_col.name;
        // }
        // j['EMPTY_b'] = 'EMPTY_b';
        // j['P_b'] = 'P_b';
        // js.push(j);

        // all tags
        for (let i = 0; i < dtd.etags.length; i++) {
            const tag_def_row = dtd.etags[i];
            
            var j = {
                'annotator': 'A',
                'tag_name': tag_def_row.name
            };
            for (let k = 0; k < dtd.etags.length; k++) {
                const tag_def_col = dtd.etags[k];
                if (tag_def_row.name == tag_def_col.name) {
                    j[tag_def_col.name] = iaa_dict.tag[tag_def_col.name].cm.tp;
                } else {
                    j[tag_def_col.name] = '';
                }
            }
            j['EMPTY_b'] = iaa_dict.tag[tag_def_row.name].cm.fp;
            j['P_b'] = this.to_fixed(iaa_dict.all.cohen_kappa.Pes.b[tag_def_row.name]);
            js.push(j);
        }

        // EMPTY for a
        j = {
            'annotator': '',
            'tag_name': 'EMPTY_a'
        }
        for (let i = 0; i < dtd.etags.length; i++) {
            const tag_def_col = dtd.etags[i];
            j[tag_def_col.name] = iaa_dict.tag[tag_def_col.name].cm.fn;
        }
        j['EMPTY_b'] = 0;
        j['P_b'] = this.to_fixed(iaa_dict.all.cohen_kappa.Pes.b['_EMPTY_']);
        js.push(j);

        // P for a
        j = {
            'annotator': '',
            'tag_name': 'P_a'
        }
        for (let i = 0; i < dtd.etags.length; i++) {
            const tag_def_col = dtd.etags[i];
            j[tag_def_col.name] = this.to_fixed(iaa_dict.all.cohen_kappa.Pes.a[tag_def_col.name]);
        }
        j['EMPTY_b'] = this.to_fixed(iaa_dict.all.cohen_kappa.Pes.a['_EMPTY_']);
        j['P_b'] = '';
        js.push(j);

        return js;
    },

    extend_iaa_report_cohen_kappa_json: function(iaa_dict, dtd, js) {
        // blank lines
        js.push({});
        js.push({});
        js.push({});

        // overall 
        js.push({
            'annotator': "Overall Cohen's Kappa",
            "tag_name": this.to_fixed(iaa_dict.all.cohen_kappa.kappa)
        });

        // percentage agreement
        js.push({
            'annotator': 'Percentage Agreement',
            'tag_name': this.to_fixed(iaa_dict.all.cohen_kappa.Po)
        });

        // TP
        js.push({
            'annotator': "TP", 
            'tag_name': iaa_dict.all.cm.tp
        });

        // FP
        js.push({
            'annotator': 'FP',
            'tag_name': iaa_dict.all.cm.fp
        });

        // FN
        js.push({
            'annotator': 'FN',
            'tag_name': iaa_dict.all.cm.fn
        });

        // N
        js.push({
            'annotator': 'N',
            'tag_name': iaa_dict.all.cohen_kappa.N 
        });

        // Po
        js.push({
            'annotator': 'Po',
            'tag_name': this.to_fixed(iaa_dict.all.cohen_kappa.Po)
        });

        // Pe
        js.push({
            'annotator': 'Pe',
            'tag_name': this.to_fixed(iaa_dict.all.cohen_kappa.Pe)
        });

        // SE_k
        js.push({
            'annotator': 'SE_k',
            'tag_name': this.to_fixed(iaa_dict.all.cohen_kappa.SE_k)
        });

        // 95% CI lower
        js.push({
            'annotator': '95% CI Lower',
            'tag_name': this.to_fixed(iaa_dict.all.cohen_kappa.lower)
        });

        // 95% CI upper
        js.push({
            'annotator': '95% CI Upper',
            'tag_name': this.to_fixed(iaa_dict.all.cohen_kappa.upper)
        });
        return js;
    },

    get_iaa_report_cohen_kappa_excelws: function(iaa_dict, dtd) {
        var js = this.get_iaa_report_cohen_kappa_json(
            iaa_dict, 
            dtd
        );

        js = this.extend_iaa_report_cohen_kappa_json(
            iaa_dict,
            dtd,
            js
        );

        var ws_cohen = XLSX.utils.json_to_sheet(js);

        return ws_cohen;
    },

    get_iaa_report_summary_json: function(iaa_dict, dtd) {
        // there are the following columns in the summary
        // Tag Name, F1, precision, recall, TP, FP, FN
        var js = [];

        // add the overall
        js.push({
            'tag_name': 'Overall',
            'F1': this.to_fixed(iaa_dict.all.f1),
            'precision': this.to_fixed(iaa_dict.all.precision),
            'recall': this.to_fixed(iaa_dict.all.recall),
            'TP': iaa_dict.all.cm.tp,
            'FP': iaa_dict.all.cm.fp,
            'FN': iaa_dict.all.cm.fn,
        });

        // now, check each etag
        for (let i = 0; i < dtd.etags.length; i++) {
            const etag_name = dtd.etags[i].name;
            
            // add this tag to the summary
            js.push({
                'tag_name': etag_name,
                'F1': this.to_fixed(iaa_dict.tag[etag_name].f1),
                'precision': this.to_fixed(iaa_dict.tag[etag_name].precision),
                'recall': this.to_fixed(iaa_dict.tag[etag_name].recall),
                'TP': iaa_dict.tag[etag_name].cm.tp,
                'FP': iaa_dict.tag[etag_name].cm.fp,
                'FN': iaa_dict.tag[etag_name].cm.fn,
            });
        }

        return js;
    },

    get_iaa_report_summary_excelws: function(iaa_dict, dtd) {
        var js = this.get_iaa_report_summary_json(
            iaa_dict,
            dtd
        );
        var ws_summary = XLSX.utils.json_to_sheet(js);
        // change the style for the header line
        var cols = 'ABCDEFG'.split('');
        for (let i = 0; i < cols.length; i++) {
            var col = cols[i];
            var row = '1';
            ws_summary[col + row].s = {
                font: {
                    sz: 14,
                    bold: true
                },
            }
        }

        // change the style for the overall F1
        var col_tag = 'A';
        var col_f1 = 'B';
        var overall_f1_value = js[0].F1;
        var overall_f1_color4ws = d3.rgb(
            d3.interpolateBlues(overall_f1_value * 0.9)
        ).formatHex();
        ws_summary[col_f1 + '2'].s = {
            fill: {
                fgColor: {
                    rgb: overall_f1_color4ws.substring(1)
                }
            },
        }

        // change the style for the tag column
        for (let i = 0; i < dtd.etags.length; i++) {
            const etag = dtd.etags[i];
            var row = '' + (i+3);
            // change the tag bg
            ws_summary[col_tag + row].s = {
                fill: {
                    fgColor: {
                        rgb: etag.style.color.substring(1).toLocaleUpperCase()
                    }
                },
            }
            // change the f1 bg
            var f1_value = parseFloat(ws_summary[col_f1 + row].v)
            var color4ws = d3.rgb(
                d3.interpolateBlues(f1_value * 0.9)
            ).formatHex();
            ws_summary[col_f1 + row].s = {
                fill: {
                    fgColor: {
                        rgb: color4ws.substring(1)
                    }
                },
            }
        }

        return ws_summary;
    },

    get_iaa_report_files_json: function(iaa_dict, dtd) {
        // there are following columns in the files json
        // file name
        var js = [];

        for (const doc_hash in iaa_dict.ann) {
            if (Object.hasOwnProperty.call(iaa_dict.ann, doc_hash)) {
                const ann_rst = iaa_dict.ann[doc_hash];
                
                // create a j obj for this file
                var j = {
                    'file_name_A': ann_rst.anns[0]._filename,
                    'file_name_B': ann_rst.anns[1]._filename,
                    'F1': this.to_fixed(ann_rst.rst.all.f1),
                    'precision': this.to_fixed(ann_rst.rst.all.precision),
                    'recall': this.to_fixed(ann_rst.rst.all.recall),
                    'TP': ann_rst.rst.all.cm.tp,
                    'FP': ann_rst.rst.all.cm.fp,
                    'FN': ann_rst.rst.all.cm.fn,
                };

                // add the f1 of each tag
                for (let i = 0; i < dtd.etags.length; i++) {
                    const etag = dtd.etags[i];
                    j[etag.name + '_F1'] = this.to_fixed(
                        ann_rst.rst.tag[etag.name].f1
                    )
                }

                // add the result
                js.push(j);
            }
        }

        return js;
    },

    get_iaa_report_files_excelws: function(iaa_dict, dtd) {
        var js = this.get_iaa_report_files_json(
            iaa_dict,
            dtd
        );

        var ws_files = XLSX.utils.json_to_sheet(js);

        // update the style
        var col_f1 = 'C';
        for (let i = 0; i < js.length; i++) {
            // get the row number
            var row = i + 2;

            // the F1 column is
            const j = js[i];
            
            // get the f1 value
            var f1_value = parseFloat(j.F1);

            // convert the f1 value to RGB color
            var color4ws = d3.rgb(
                d3.interpolateBlues(f1_value)
            ).formatHex();

            // set the style for this cell
            ws_files[col_f1 + row].s = {
                fill: {
                    fgColor: {
                        rgb: color4ws.substring(1)
                    }
                },
            }
        }

        return ws_files;
    },

    /**
     * Get the IAA report, the details of tags.
     *
     * 
     * @param {Object} iaa_dict the dictionary contains IAA result
     * @param {Object} dtd the DTD schema
     * @param {Object} flags flags for controling results
     * @returns JSON format report
     */
    get_iaa_report_tags_json: function(iaa_dict, dtd, flags) {
        if (typeof(flags)=='undefined') {
            flags = {
                skip_agreed_tags: false
            }
        }
        // there are following columns in the files json
        // file name
        var js = [];
        var cms = ['tp', 'fp', 'fn'];
        if (flags.skip_agreed_tags) {
            cms = ['fp', 'fn'];
        }

        for (const doc_hash in iaa_dict.ann) {
            if (Object.hasOwnProperty.call(iaa_dict.ann, doc_hash)) {
                const ann_rst = iaa_dict.ann[doc_hash];

                // now need to check each tag in this ann_rst
                for (let i = 0; i < dtd.etags.length; i++) {
                    const etag = dtd.etags[i];
                    
                    // now need to check each cm
                    for (let j = 0; j < cms.length; j++) {
                        const cm = cms[j];
                        // get the index for the cm tags
                        // for tp and fp, use 0
                        // for fn, use 1
                        var idx = {'tp': 0, 'fp': 0, 'fn': 1}[cm];
                        
                        // the IAA 
                        var iaa = {
                            'tp': 'Agreed',
                            'fp': 'Disagreed',
                            'fn': 'Disagreed'
                        }[cm];
                        
                        // now need to check each item in this
                        var cm_tags = ann_rst.rst.tag[etag.name].cm.tags[cm];
                        for (let k = 0; k < cm_tags.length; k++) {
                            // ok, put each tag to the js
                            const cm_tag = cm_tags[k];
                            
                            for (let anter_idx = 0; anter_idx < 2; anter_idx++) {
                                if (cm_tag[anter_idx] == null) {
                                    // no such tag, skip
                                    continue
                                }
                                // where the tags comes from depends on
                                // the index, which is coded in the parsing iaa
                                var src = {0: 'A', 1: 'B'}[anter_idx];

                                // add this tag to final list
                                // create a base json to hold everything
                                var json = {
                                    'file_name': ann_rst.anns[idx]._filename,
                                    'source': src,
                                    'concept': etag.name,
                                    'id': cm_tag[anter_idx].id,
                                    'spans': cm_tag[anter_idx].spans,
                                    'text': cm_tag[anter_idx].text,
                                    'IAA': iaa
                                };

                                // next need to put all attributes to this
                                // this depends on the schema
                                for (let att_idx = 0; att_idx < etag.attrs.length; att_idx++) {
                                    const etag_att = etag.attrs[att_idx];
                                    
                                    // the attribute name should be the same
                                    // since it is used as the column name.
                                    // So we need to create two new columns:
                                    // 1. att_x_key, for the attr key
                                    // 2. att_x_txt, for the attr value
                                    var col_att_key = 'attr_name_' + att_idx;
                                    var col_att_key_value = etag_att.name;

                                    var col_att_txt = 'attr_value_' + att_idx;
                                    var col_att_txt_value = cm_tag[anter_idx][etag_att.name];

                                    // then put this two columns to the json
                                    json[col_att_key] = col_att_key_value;
                                    json[col_att_txt] = col_att_txt_value;
                                }

                                // put to js
                                js.push(json);
                                
                            }
                        }
                    }
                }
            }
        }

        return js;
    },

    get_iaa_report_tags_excelws: function(iaa_dict, dtd) {
        var js = this.get_iaa_report_tags_json(
            iaa_dict,
            dtd
        );
        var ws_tags = XLSX.utils.json_to_sheet(js);

        // change the style for the IAA column
        var col_concept = 'C';
        var col_iaa = 'G';
        for (let i = 0; i < js.length; i++) {
            // get the data item
            var json = js[i];

            // get the row number
            // the first row is the header, 
            // so the number starts with 2
            var row = i + 2;

            // set the style for the concept name
            ws_tags[col_concept + row].s = {
                fill: {
                    fgColor: {
                        rgb: dtd.tag_dict[json.concept].style.color.substring(1)
                    }
                },
            }

            // get IAA value in that cell and convert to color
            var iaa_value = ws_tags[col_iaa + row].v;
            var iaa_color = iaa_value == 'Agreed'? 
                this.colors.decision_agreed: 
                this.colors.decision_disagreed;

            // set the style for the 
            ws_tags[col_iaa + row].s = {
                fill: {
                    fgColor: {
                        rgb: iaa_color
                    }
                },
            }
            
        }

        return ws_tags;
    },

    /**
     * Get the IAA report in a format for adjudication.
     *
     * 
     * @param {Object} iaa_dict the dictionary contains IAA result
     * @param {Object} dtd the DTD schema
     * @param {Object} flags flags for controling results
     * @returns JSON format report
     */
    get_iaa_report_adjudication_json: function(iaa_dict, dtd, flags) {
        if (typeof(flags)=='undefined') {
            flags = {
                skip_agreed_tags: false
            }
        }
        // there are following columns in the files json
        // file name
        var js = [];
        var cms = ['tp', 'fp', 'fn'];
        if (flags.skip_agreed_tags) {
            cms = ['fp', 'fn'];
        }

        for (const doc_hash in iaa_dict.ann) {
            if (Object.hasOwnProperty.call(iaa_dict.ann, doc_hash)) {
                const ann_rst = iaa_dict.ann[doc_hash];

                // now need to check each tag in this ann_rst
                for (let i = 0; i < dtd.etags.length; i++) {
                    const etag = dtd.etags[i];
                    // processed tags in list b
                    var p_tags_b = [];
                    
                    // now need to check each cm
                    for (let j = 0; j < cms.length; j++) {
                        const cm = cms[j];
                        // the IAA 
                        var iaa = {
                            'tp': 'Agreed',
                            'fp': 'Disagreed',
                            'fn': 'Disagreed'
                        }[cm];
                        
                        // now need to check each item in this
                        var cm_tags = ann_rst.rst.tag[etag.name].cm.tags[cm];
                        for (let k = 0; k < cm_tags.length; k++) {
                            // no matter what the 
                            // ok, put each tag to the js
                            const cm_tag = cm_tags[k];

                            // need to check if tag_b
                            if (cm_tag[1] == null) {
                                // ok, this only involves annotator a
                            } else {
                                // now check if this tag added?
                                if (p_tags_b.contains(cm_tag[1].id)) {
                                    // oh, this tag b has been added
                                    continue
                                } else {
                                    // oh, this is a new tag b
                                    p_tags_b.push(cm_tag[1].id)
                                }
                            }
                            
                            // create a base json to hold everything
                            var json = {
                                // just use the first file as file name
                                'file_name': ann_rst.anns[0]._filename,
                                'concept': etag.name,
                                'IAA': iaa
                            };
                            
                            // decision
                            
                            // then put the annotation from A and B
                            // anter_idx 0 is A
                            // anter_idx 1 is B
                            for (let anter_idx = 0; anter_idx < 2; anter_idx++) {
                                var anter_label = {0:'A', 1:'B'}[anter_idx];
                                if (cm_tag[anter_idx] == null) {
                                    // which means this location is empty
                                    // just put empty content
                                    // due to the xlsx convert design, 
                                    // must put empty text here
                                    json[anter_label+'.id'] = '';
                                    json[anter_label+'.spans'] = '';
                                    json[anter_label+'.text'] = '';
                                } else {
                                    // ok, this is a tag, put it here
                                    json[anter_label+'.id'] = cm_tag[anter_idx].id;
                                    json[anter_label+'.spans'] = cm_tag[anter_idx].spans;
                                    json[anter_label+'.text'] = cm_tag[anter_idx].text;
                                }                                
                            }
                            
                            // next need to put all attributes to this
                            // this depends on the schema
                            // for (let att_idx = 0; att_idx < etag.attrs.length; att_idx++) {
                            //     const etag_att = etag.attrs[att_idx];
                                
                            //     // the attribute name should be the same
                            //     // since it is used as the column name.
                            //     // So we need to create two new columns:
                            //     // 1. att_x_key, for the attr key
                            //     // 2. att_x_txt, for the attr value
                            //     var col_att_key = 'attr_name_' + att_idx;
                            //     var col_att_key_value = etag_att.name;

                            //     var col_att_txt = 'attr_value_' + att_idx;
                            //     var col_att_txt_value = cm_tag[idx][etag_att.name];

                            //     // then put this two columns to the json
                            //     json[col_att_key] = col_att_key_value;
                            //     json[col_att_txt] = col_att_txt_value;
                            // }

                            // put to js
                            js.push(json);
                        }
                    }
                }
            }
        }

        return js;
    },

    get_iaa_report_adjudication_excelws: function(iaa_dict, dtd) {
        var js = this.get_iaa_report_adjudication_json(
            iaa_dict,
            dtd
        );
        var ws_tags = XLSX.utils.json_to_sheet(js);

        // change the style for the adjudication column
        var col_concept = 'B';
        var col_iaa = 'C';
        var cols_a = ['D', 'E', 'F'];
        var cols_b = ['G', 'H', 'I'];
        for (let i = 0; i < js.length; i++) {
            // get the data item
            var json = js[i];

            // get the row number
            // the first row is the header, 
            // so the number starts with 2
            var row = i + 2;

            // set the style for the concept name
            ws_tags[col_concept + row].s = {
                fill: {
                    fgColor: {
                        rgb: dtd.tag_dict[json.concept].style.color.substring(1)
                    }
                },
            }

            // get IAA value in that cell and convert to color
            var iaa_value = ws_tags[col_iaa + row].v;
            var iaa_color = iaa_value == 'Agreed'? 
                this.colors.decision_agreed: 
                this.colors.decision_disagreed;

            // set the style for the 
            ws_tags[col_iaa + row].s = {
                fill: {
                    fgColor: {
                        rgb: iaa_color
                    }
                },
            }

            // set bg color for annotator A
            for (let j = 0; j < cols_a.length; j++) {
                const col = cols_a[j];
                ws_tags[col + row].s = {
                    fill: {
                        fgColor: {
                            rgb: this.colors.annotator_a_tag
                        }
                    },
                }
            }

            // set bg color for annotator B
            for (let j = 0; j < cols_b.length; j++) {
                const col = cols_b[j];
                ws_tags[col + row].s = {
                    fill: {
                        fgColor: {
                            rgb: this.colors.annotator_b_tag
                        }
                    },
                }
            }
        }

        return ws_tags;
    },

    /**
     * Evaluate the IAA based on given schema and 
     * two list of annotations from two annotators
     * 
     * @param {Object} dtd the annotation schema
     * @param {Object} anns_a the annotations by A
     * @param {Object} anns_b the annotations by B
     * @param {string} match_mode overlap or exact match
     * @param {float} overlap_ratio overlap ratio
     * @returns Object of IAA result
     */
    evaluate_anns_on_dtd: function(
        dtd, 
        anns_a, 
        anns_b, 
        match_mode, 
        overlap_ratio,
        tag_attrs,
        remove_tag_b_when_low_overlap
    ) {
        if (typeof(match_mode) == 'undefined') {
            match_mode = 'overlap';
        }
        if (typeof(overlap_ratio) == 'undefined') {
            overlap_ratio = this.default_overlap_ratio;
        }
        if (typeof(tag_attrs) == 'undefined') {
            tag_attrs = null;
        }
        if (typeof(remove_tag_b_when_low_overlap) == 'undefined') {
            remove_tag_b_when_low_overlap = true;
        }
        /* we will build a dictionary for this task
        {
            ann: {
                text_hash: {
                    anns: [ann_a, ann_b],
                    rst: {
                        tag_name: result
                    }
                },
                ...
            },
            all: {pre, rec, f1, cm},
            tag: {
                tag_a: {pre, rec, f1, cm},
            }
        },
        */
        var iaa_dict = {
            ann: {}, // for the file
            all: {},
            tag: {},
            stat: {
                duplicates: [],
                unmatched: [],
                matched_hashcodes: []
            },
        };

        // this is just for checking dupliated ann
        var ann_dict = {};
        
        // first, let's check all anns_a
        for (let i = 0; i < anns_a.length; i++) {
            const ann_a = anns_a[i];
            var hashcode = this.hash(ann_a.text);

            if (ann_dict.hasOwnProperty(hashcode)) {
                // what??? duplicated text in anns_a?
                console.log('* found duplicated ann a', ann_a);
                iaa_dict.stat.duplicates.push({
                    ann: ann_a,
                    from: 'a'
                });
                continue;
            }

            // ok, let's create a new item here
            ann_dict[hashcode] = [{
                ann: ann_a,
                from: 'a'
            }];
        }

        // second, let's check all anns_b
        for (let i = 0; i < anns_b.length; i++) {
            const ann_b = anns_b[i];
            var hashcode = this.hash(ann_b.text);

            if (ann_dict.hasOwnProperty(hashcode)) {
                // one more case about this ann:
                // how many anns have been found?
                if (ann_dict[hashcode].length > 1) {
                    // this is a dupliated ann
                    iaa_dict.stat.duplicates.push({
                        ann: ann_b,
                        from: 'b'
                    });
                    console.log('* found duplicated ann b', ann_b);

                    continue;
                }
            } else {
                // which means this ann has no ann in a
                ann_dict[hashcode] = [{
                    ann: ann_b,
                    from: 'b'
                }];
                iaa_dict.stat.unmatched.push({
                    ann: ann_b,
                    from: 'b'
                });
                console.log('* found unmatched ann b', ann_b);
                continue;
            }
            
            // OK, this ann_b could be matched with ann_a
            var ann_a = ann_dict[hashcode][0].ann;
            iaa_dict.ann[hashcode] = {
                anns: [
                    ann_a,
                    ann_b
                ],
                rst: {},
            };

            // save the hashcode
            iaa_dict.stat.matched_hashcodes.push(hashcode);
            
            // let's save this ann_b
            ann_dict[hashcode].push({ 
                ann: ann_b,
                from: 'b'
            });

            // now, time to evaluate
            var rst = this.evaluate_ann_on_dtd(
                dtd,
                ann_a,
                ann_b,
                match_mode,
                overlap_ratio,
                tag_attrs,
                remove_tag_b_when_low_overlap
            );

            // save this result
            iaa_dict.ann[hashcode].rst = rst;
        }

        // third, check if there is any unmatched from ann a
        for (const hashcode in ann_dict) {
            if (Object.hasOwnProperty.call(ann_dict, hashcode)) {
                if (ann_dict[hashcode].length == 1 &&
                    ann_dict[hashcode][0].from == 'a') {
                    // which means ... this ann is not used for matching
                    iaa_dict.stat.unmatched.push(ann_dict[hashcode][0]);

                    console.log('* found unmatched ann a', ann_dict[hashcode][0].ann);
                }
            }
        }

        // finally, calculate the result at all and tag levels
        var cm_all = { tp: 0, fp: 0, fn: 0 };
        for (let i = 0; i < dtd.etags.length; i++) {
            const tag_def = dtd.etags[i];
            var cm_tag = { tp: 0, fp: 0, fn: 0 };
            
            for (const hashcode in iaa_dict.ann) {
                if (Object.hasOwnProperty.call(iaa_dict.ann, hashcode)) {
                    const iaa = iaa_dict.ann[hashcode];
                    // add the result of this tag
                    cm_tag.tp += iaa.rst.tag[tag_def.name].cm.tp;
                    cm_tag.fp += iaa.rst.tag[tag_def.name].cm.fp;
                    cm_tag.fn += iaa.rst.tag[tag_def.name].cm.fn;
                }
            }
            // get the tag level result
            var tag_result = this.calc_p_r_f1(cm_tag);
            iaa_dict.tag[tag_def.name] = tag_result;

            // add the tag level to all
            cm_all.tp += cm_tag.tp;
            cm_all.fp += cm_tag.fp;
            cm_all.fn += cm_tag.fn;
        }
        // get the all level result
        var all_result = this.calc_p_r_f1(cm_all);

        iaa_dict.all = all_result;

        // update the cohen kappa of all
        all_result.cohen_kappa = this.get_cohen_kappa_overall(iaa_dict);

        return iaa_dict;
    },

    /**
     * Evaluate the IAA based on given schema and 
     * two annotation from two annotators
     * 
     * @param {Object} dtd the annotation schema
     * @param {Object} ann_a an annotation by A
     * @param {Object} ann_b an annotation by B
     * @param {string} match_mode overlap or exact match
     * @param {float} overlap_ratio overlap ratio
     * @param {Object} tag_attrs which attr to be used in calc 
     * @returns Object of IAA result
     */
    evaluate_ann_on_dtd: function(
        dtd, 
        ann_a, 
        ann_b, 
        match_mode, 
        overlap_ratio,
        tag_attrs,
        remove_tag_b_when_low_overlap
    ) {
        if (typeof(match_mode)=='undefined') {
            match_mode = 'overlap';
        }
        if (typeof(overlap_ratio) == 'undefined') {
            overlap_ratio = this.default_overlap_ratio;
        }
        if (typeof(tag_attrs) == 'undefined') {
            tag_attrs = null;
        }
        if (typeof(remove_tag_b_when_low_overlap) == 'undefined') {
            remove_tag_b_when_low_overlap = true;
        }

        // check the text first
        if (ann_a.text != ann_b.text) {
            throw { 
                name: 'Different texts', 
                message: 'The texts are different in given annotations.'
            };
        }

        // check each etag
        var result_ann = {
            all: {},
            tag: {}
        }
        var cm_ann = { tp: 0, fp: 0, fn: 0 };
        for (let i = 0; i < dtd.etags.length; i++) {
            const tag_def = dtd.etags[i];
            var r = this.evaluate_ann_on_tag(
                tag_def, 
                ann_a, 
                ann_b, 
                match_mode, 
                overlap_ratio,
                tag_attrs,
                remove_tag_b_when_low_overlap
            );
            result_ann.tag[tag_def.name] = r;

            // add the result of this tag
            cm_ann.tp += r.cm.tp;
            cm_ann.fp += r.cm.fp;
            cm_ann.fn += r.cm.fn;

        }
        var all_result = this.calc_p_r_f1(cm_ann);

        result_ann.all = all_result;

        // update the cohen kappa of all
        all_result.cohen_kappa = this.get_cohen_kappa_overall(result_ann);

        return result_ann;
    },

    evaluate_ann_on_tag: function(
        tag_def, 
        ann_a, 
        ann_b, 
        match_mode, 
        overlap_ratio,
        tag_attrs,
        remove_tag_b_when_low_overlap
    ) {
        if (typeof(match_mode)=='undefined') {
            match_mode = 'overlap';
        }
        if (typeof(overlap_ratio) == 'undefined') {
            overlap_ratio = this.default_overlap_ratio;
        }
        if (typeof(tag_attrs) == 'undefined') {
            tag_attrs = null;
        }
        if (typeof(remove_tag_b_when_low_overlap) == 'undefined') {
            remove_tag_b_when_low_overlap = true;
        }

        // check the text first
        if (ann_a.text != ann_b.text) {
            throw { 
                name: 'Different texts', 
                message: 'The texts are different in given annotations.'
            };
        }

        // get all tags of this tag_def
        var tag_list_a = this.get_tag_list_by_tag(tag_def, ann_a);
        var tag_list_b = this.get_tag_list_by_tag(tag_def, ann_b);

        var cm = this.calc_matching(
            tag_list_a, 
            tag_list_b, 
            match_mode, 
            overlap_ratio,
            tag_attrs,
            remove_tag_b_when_low_overlap
        );
        var result = this.calc_p_r_f1(cm);

        return result;
    },

    calc_matching: function(
        tag_list_a, 
        tag_list_b, 
        match_mode, 
        overlap_ratio,
        tag_attrs,
        remove_tag_b_when_low_overlap
    ) {
        if (typeof(match_mode)=='undefined') {
            match_mode = 'overlap';
        }
        if (typeof(overlap_ratio) == 'undefined') {
            overlap_ratio = this.default_overlap_ratio;
        }
        if (typeof(tag_attrs) == 'undefined') {
            tag_attrs = null;
        }
        if (typeof(remove_tag_b_when_low_overlap) == 'undefined') {
            remove_tag_b_when_low_overlap = true;
        }
        var cm = {
            tp: 0,
            fp: 0,
            fn: 0,
            
            // save the details
            tags: {
                tp: [],
                fp: [],
                fn: []
            }
        };

        // this dictionary is for generating the list for FN list
        var tag_dict_b = {};
        for (let i = 0; i < tag_list_b.length; i++) {
            const tag = Object.assign({}, tag_list_b[i]);
            tag_dict_b[tag.spans] = tag;
        }

        // check each element in tag_list_a and find matched in b
        for (let i = 0; i < tag_list_a.length; i++) {
            var tag_a = tag_list_a[i];
            
            // the `tag_list_b` may be not empty
            // if not match, may due to the low overlap
            // the return result also contains the overlap rate
            var is_match = this.is_tag_match_in_list(
                tag_a, 
                tag_list_b, 
                match_mode,
                overlap_ratio,
                tag_attrs
            );

            // console.log('* a', tag_a.spans, is_match.is_in, 'b', is_match.tag_b);

            if (is_match.is_in) {
                // This case is simple, two tags are matched
                cm.tp += 1;
                cm.tags.tp.push([
                    tag_a, 
                    is_match.tag_b
                ]);

                // remove this tag_b from the dict
                delete tag_dict_b[is_match.tag_b.spans];

            } else {
                // This case means that this tag is not found in tag_list_b
                cm.fp += 1;
                cm.tags.fp.push([
                    tag_a, 
                    // usually, the tag_b is null,
                    // but sometimes it is not depends on the rate
                    is_match.tag_b
                ]);

                // in some cases, it does not match due to low overlap ratio
                // we need to remove this tag_b as well.
                // but we may also want to keep both?
                if (is_match.tag_b != null) {
                    if (remove_tag_b_when_low_overlap) {
                        delete tag_dict_b[is_match.tag_b.spans];
                    } else {
                        // well, users specify to keep this, then just keep it
                    }
                }
            }
        }

        cm.fn = Object.values(tag_dict_b).length;
        // cm.fn = tag_list_b.length - cm.tp;
        cm.tags.fn = Object.values(tag_dict_b).map(tag => [null, tag]);

        return cm;
    },

    is_tag_match_in_list: function(
        tag, 
        tag_list, 
        match_mode, 
        overlap_ratio,
        tag_attrs
    ) {
        if (typeof(match_mode)=='undefined') {
            match_mode = 'overlap';
        }
        if (typeof(overlap_ratio) == 'undefined') {
            overlap_ratio = this.default_overlap_ratio;
        }
        if (typeof(tag_attrs) == 'undefined') {
            tag_attrs = null;
        }
        var spans = tag.spans;
        var loc_a = this.spans2loc(spans);

        // potential b
        var p_tag_b = null;
        // the overlap rate
        var olpr = 0;

        for (let i = 0; i < tag_list.length; i++) {
            const tag_b = tag_list[i];
            var spans_b = tag_b.spans;

            if (match_mode == 'overlap') {
                // for overlap mode, check ranges of two spans
                var loc_b = this.spans2loc(spans_b);

                // the overlap contains two value
                // first the decision based on the ratio
                // seoncd the how much is overlapped
                var is_olpd = this.is_overlapped(
                    loc_a, 
                    loc_b, 
                    overlap_ratio
                );
                if (is_olpd[0]) {
                    // check if using tag_attrs
                    if (tag_attrs == null) {
                        // OK, the overlap is bigger than the ratio
                        // just return this is matched
                        return { 
                            is_in: true,
                            tag_b: tag_b,
                            olpr: is_olpd[1],
                            atum: null
                        };
                    } else {
                        // too bad, need to check the attributes
                        var is_atmd = this.is_attrs_matched(
                            tag,
                            tag_b,
                            tag_attrs
                        );

                        if (is_atmd[0]) {
                            // great! perfect match!
                            return { 
                                is_in: true,
                                tag_b: tag_b,
                                olpr: is_olpd[1],
                                atum: null
                            };
                        } else {
                            // too bad, some attr maybe different
                            return { 
                                is_in: false,
                                tag_b: tag_b,
                                olpr: is_olpd[1],
                                // ATtribute UnMatched
                                atum: is_atmd[1]
                            };
                        }
                    }
                }
                // in some cases, the overlapped ratio is low
                // but still match, we need to check this case
                if (is_olpd[1] > 0) {
                    p_tag_b = tag_b;
                }
                
            } else if (match_mode == 'exact') {

                if (spans == spans_b) {
                    return {
                        is_in: true,
                        tag_b: tag_b,
                        olpr: 1,
                        atum: null
                    };
                }
                
            }
        }

        return {
            is_in: false,
            tag_b: p_tag_b,
            olpr: olpr,
            atum: null
        };
    },

    is_attrs_matched: function(tag_a, tag_b, tag_attrs) {
        if (typeof(tag_attrs) == 'undefined') {
            tag_attrs = {};
        }
        for (const attr in tag_a) {
            if (!tag_attrs.hasOwnProperty(tag_a.tag)) {
                // what??? 
                break;
            }
            if (!tag_attrs[tag_a.tag].hasOwnProperty(attr)) {
                // skip those system attr
                continue;
            }
            if (!tag_attrs[tag_a.tag][attr]) {
                // skip those unselected attr
                continue;
            }
            if (Object.hasOwnProperty.call(tag_a, attr)) {
                const val_a = tag_a[attr];

                if (tag_b.hasOwnProperty(attr)) {
                    // skip those attrs that not available
                    const val_b = tag_b[attr];

                    if (val_a == val_b) {
                        // ok, nothing to do with one as they are the same 
                        continue;

                    } else {
                        // ok, we found different attr val!
                        return [false, attr];
                    }
                } else {
                    // what??? this can't be!
                    // return [false, attr];
                    continue;
                }
            }
        }
        // ok, is matched and no difference
        return [true, null];
    },

    is_overlapped: function(loc_a, loc_b, overlap_ratio) {
        if (typeof(overlap_ratio)=='undefined') {
            overlap_ratio = this.default_overlap_ratio;
        }
        
        var s_a = new Set(new Array(loc_a[1] - loc_a[0] + 1).fill(loc_a[0]).map((e,i)=>e+i));
        var s_b = new Set(new Array(loc_b[1] - loc_b[0] + 1).fill(loc_b[0]).map((e,i)=>e+i));

        var s_inter = this.set_intersection(s_a, s_b);
        var s_union = this.set_union(s_a, s_b);
        var r = s_inter.size / s_union.size;

        // console.log('* is overlapped', loc_a, '', loc_b, 'i:', s_inter.size, 'u:', s_union.size, 'r:', r);

        if (r >= overlap_ratio) {
            return [true, r];
        } else {
            return [false, r]
        }
    },

    spans2loc: function(spans) {
        var vs = spans.split('~');
        return [
            parseInt(vs[0]), 
            parseInt(vs[1])
        ];
    },

    calc_p_r_f1: function(cm) {
        var precision = this.calc_precision(cm.tp, cm.fp);
        var recall = this.calc_recall(cm.tp, cm.fn);
        var f1 = this.calc_f1_by_pr(precision, recall);
        var cohen_kappa = this.get_cohen_kappa(cm.tp, cm.fp, cm.fn);

        return {
            precision: precision,
            recall: recall,
            f1: f1,
            cohen_kappa: cohen_kappa,
            cm: cm
        }
    },

    calc_precision: function(tp, fp) {
        return tp / (tp + fp);
    },

    calc_recall: function(tp, fn) {
        return tp / (tp + fn);
    },

    /**
     * Calculate the total number of records
     * 
     * @param {number} tp True positive
     * @param {number} fp False positive
     * @param {number} fn False negative
     * @returns number of total
     */
    calc_N: function(tp, fp, fn) {
        return tp + fp + fn;
    },

    /**
     * Calculate the percentage agreement
     * 
     * As this is no TN, the PerAgr is just the TP
     * 
     * @param {number} tp True positive
     * @param {number} fp False positive
     * @param {number} fn False negative
     * @returns Po
     */
    calc_Po: function(tp, fp, fn) {
        return tp / this.calc_N(tp, fp, fn);
    },

    calc_Pe: function(tp, fp, fn) {
        var N = this.calc_N(tp, fp, fn);
        return ((tp + fn) * (tp + fp) + fn * fp) / N**2;
    },

    calc_cohen_kappa: function(Po, Pe) {
        // get the cohen's kappa
        if (Pe == 1) {
            Pe = 1.0001;
        }
        return 1 - (1 - Po) / (1 - Pe);
    },
    
    calc_cohen_kappa_SE_k: function(N, Po, Pe) {
        return (
            Po * (1 - Po) / 
            (N * (1 - Pe) ** 2)
        )**0.5;
    },

    get_cohen_kappa_overall: function(iaa_rst) {
        // the N is just the total number
        var N = this.calc_N(
            iaa_rst.all.cm.tp,
            iaa_rst.all.cm.fp,
            iaa_rst.all.cm.fn
        );
        // the overall Po is as usuall
        var Po = this.calc_Po(
            iaa_rst.all.cm.tp, 
            iaa_rst.all.cm.fp, 
            iaa_rst.all.cm.fn
        );

        // Need to get the sub-Pe
        var sPes = [];
        var Pes = {
            a: {},
            b: {}
        };

        // for the EMPTY tags
        var _eA = 0;
        var _eB = 0;

        for (const tag_name in iaa_rst.tag) {
            if (Object.hasOwnProperty.call(iaa_rst.tag, tag_name)) {
                const rst = iaa_rst.tag[tag_name];
                Pes.a[tag_name] = (rst.cm.tp + rst.cm.fn) / N;
                Pes.b[tag_name] = (rst.cm.tp + rst.cm.fp) / N;
                var sPe = Pes.a[tag_name] * Pes.b[tag_name];
                sPes.push(sPe);

                _eA += rst.cm.fn;
                _eB += rst.cm.fp;
            }
        }

        // calc the _EMPTY_
        Pes.a['_EMPTY_'] = _eA / N;
        Pes.b['_EMPTY_'] = _eB / N;
        sPes.push(Pes.a['_EMPTY_'] * Pes.b['_EMPTY_']);

        // sum all
        var Pe = sPes.reduce((a, b) => a + b, 0);

        // get the cohen's kappa
        var kappa = this.calc_cohen_kappa(Po, Pe);

        // get the SE_k
        var SE_k = this.calc_cohen_kappa_SE_k(N, Po, Pe);

        // get the lower and upper for 95% CI
        var lower = kappa - 1.96 * SE_k;
        var upper = kappa + 1.96 * SE_k;

        return {
            N: N,
            Po: Po,
            Pe: Pe,
            Pes: Pes,
            kappa: kappa,
            SE_k: SE_k,
            lower: lower,
            upper: upper
        };
    },

    /**
     * Get the Cohen's Kappa Score and 95% CI
     * 
     * The definition comes from 
     * https://en.wikipedia.org/wiki/Cohen%27s_kappa
     * 
     * @param {number} tp True positive
     * @param {number} fp False positive
     * @param {number} fn False negative
     * @returns Cohen's Kappa Score and 95% CI
     */
     get_cohen_kappa: function(tp, fp, fn) {
        var N = this.calc_N(tp, fp, fn);
        var Po = this.calc_Po(tp, fp, fn);
        var Pe = this.calc_Pe(tp, fp, fn);

        // get the cohen's kappa
        var kappa = this.calc_cohen_kappa(Po, Pe);

        // get the SE_k
        var SE_k = this.calc_cohen_kappa_SE_k(N, Po, Pe);

        // get the lower and upper for 95% CI
        var lower = kappa - 1.96 * SE_k;
        var upper = kappa + 1.96 * SE_k;

        return {
            N: N,
            Po: Po,
            Pe: Pe,
            kappa: kappa,
            SE_k: SE_k,
            lower: lower,
            upper: upper
        };
    },

    calc_f1: function(tp, fp, fn) {
        var precision = this.calc_precision(tp, fp);
        var recall = this.calc_recall(tp, fn);
        return 2 * precision * recall / (precision + recall);
    },

    calc_f1_by_pr: function(precision, recall) {
        return 2 * precision * recall / (precision + recall);
    },

    get_tag_list_by_tag: function(tag_def, ann) {
        var tag_dict = {};
        for (let i = 0; i < ann.tags.length; i++) {
            const tag = ann.tags[i];
            if (tag.tag == tag_def.name) {
                tag_dict[tag.spans] = tag;
            }
        }

        // conver the dictionary to list
        var tag_list = Object.values(tag_dict);
        return tag_list;
    },

    hash: function(str, seed = 0) {
        let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;
        for (let i = 0, ch; i < str.length; i++) {
            ch = str.charCodeAt(i);
            h1 = Math.imul(h1 ^ ch, 2654435761);
            h2 = Math.imul(h2 ^ ch, 1597334677);
        }
        h1 = Math.imul(h1 ^ (h1>>>16), 2246822507) ^ Math.imul(h2 ^ (h2>>>13), 3266489909);
        h2 = Math.imul(h2 ^ (h2>>>16), 2246822507) ^ Math.imul(h1 ^ (h1>>>13), 3266489909);
        return 4294967296 * (2097151 & h2) + (h1>>>0);
    },

    to_fixed: function(v) {
        if (typeof(v) == 'undefined' ||
            v == null || 
            isNaN(v)) {
            return 'NA';
        }
        return v.toFixed(4);
    },

    set_union: function(setA, setB) {
        let _union = new Set(setA)
        for (let elem of setB) {
            _union.add(elem)
        }
        return _union
    },
    
    set_intersection: function(setA, setB) {
        let _intersection = new Set()
        for (let elem of setB) {
            if (setA.has(elem)) {
                _intersection.add(elem)
            }
        }
        return _intersection
    },

    /**
     * Find the longest common substring
     * @param {string} str1 a string
     * @param {string} str2 another string
     * @returns longest common substring
     */
    find_lcs: function(str1, str2) {
        let m = new Array(str1.length+1).fill(0).map(function() {
            return new Array(str2.length+1).fill(0);
        });
        let max = 0;
        let index = null;
        for (let i = 0; i < str1.length; i++) {
            
            for (let j = 0; j < str2.length; j++) {
                
                if(str1.charAt(i) === str2.charAt(j)){
                    if(i>0 && j>0 && m[i-1][j-1]>0) {
                        m[i][j] = 1 + m[i-1][j-1];
                    } else{
                        m[i][j] = 1;
                    }
                    
                    if(max < m[i][j]){
                        max = m[i][j];
                        index = i;
                    }
                } else {
                    
                }
            }
        }

        return str1.substr(index-max + 1, max)
    },


    /**
     * Get the error tags (FP, FN) for error analysis
     * 
     * @param {Object} iaa_dict the dict for IAA results
     */
    get_iaa_error_tags: function(iaa_dict, dtd) {
        // the final results
        var err_dict = {};
        var doc_dict = {};

        // we only check the fp and fn tags
        var cms = ['fp', 'fn'];

        // check each ann
        for (const doc_hash in iaa_dict.ann) {
            var ann_rst = iaa_dict.ann[doc_hash];

            // now need to check each tag in this ann_rst
            for (let i = 0; i < dtd.etags.length; i++) {
                var etag = dtd.etags[i];
                
                // now need to check each cm
                for (let j = 0; j < cms.length; j++) {
                    var cm = cms[j];
                    // get the index for the cm tags
                    // for fp, use 0
                    // for fn, use 1
                    var idx = {'fp': 0, 'fn': 1}[cm];

                    // now need to check each item in this
                    var cm_tags = ann_rst.rst.tag[etag.name].cm.tags[cm];

                    for (let k = 0; k < cm_tags.length; k++) {
                        // ok, put each tag to the js
                        var cm_tag = cm_tags[k];
                        
                        for (let anter_idx = 0; anter_idx < 2; anter_idx++) {
                            if (cm_tag[anter_idx] == null) {
                                // no such tag, skip
                                continue
                            }
                            // where the tags comes from depends on
                            // the index, which is coded in the parsing iaa
                            var src = {0: 'A', 1: 'B'}[anter_idx];

                            // add this tag to final list
                            // create a text for generating uid
                            var uid_text = 'UID-' +
                                ann_rst.anns[idx]._filename + "|" +
                                etag.name + "|" + 
                                cm + "|" +
                                cm_tag[anter_idx].id + "|" +
                                cm_tag[anter_idx].spans + "|" +
                                cm_tag[anter_idx].text;
                            var uid = this.hash(uid_text);

                            // this ann may not have sentences
                            iaa_dict.ann[doc_hash].anns[idx] = this._update_ann_sentences(
                                iaa_dict.ann[doc_hash].anns[idx]
                            );
                            // get the sentence of this tag
                            // and calc the spans of this tags in this sentence
                            var sen_spans = nlp_toolkit.get_sen_span(
                                cm_tag[anter_idx].spans,
                                ann_rst.anns[idx]._sentences
                            );

                            if (sen_spans.length>1) {
                                console.log('* !!! multi-loc spans found??', sen_spans);
                            }

                            // create a base json to hold everything
                            var json = {
                                'uid': uid,
                                'id': cm_tag[anter_idx].id,
                                'spans': cm_tag[anter_idx].spans,
                                'sentence': sen_spans[0].sentence,
                                'sentence_spans': 
                                    sen_spans[0].sen_span[0] + '~' +
                                    sen_spans[0].sen_span[1],
                                'tag': etag.name,
                                'text': cm_tag[anter_idx].text,
                                // the issue related to the file_name is that,
                                // the file name can be different for same doc.
                                // so we put both information here.
                                // but in the doc dictionary, use hash instead
                                'file_hash': doc_hash,
                                'file_name': ann_rst.anns[idx]._filename,
                                '_annotator': src,
                                '_judgement': cm.toUpperCase(),
                            };

                            // next need to put all attributes to this
                            // this depends on the schema
                            for (let att_idx = 0; att_idx < etag.attrs.length; att_idx++) {
                                const etag_att = etag.attrs[att_idx];

                                // the attribute name should be the same
                                var col_att_key = etag_att.name;
                                var col_att_val = cm_tag[anter_idx][etag_att.name];

                                // then put this two columns to the json
                                json[col_att_key] = col_att_val;
                            }

                            // put to tags
                            err_dict[json.uid] = json;

                            // put doc to docs
                            // instead of using file name, use file_hash
                            // if (!doc_dict.hasOwnProperty(ann_rst.anns[idx]._filename)) {
                            if (!doc_dict.hasOwnProperty(doc_hash)) {
                                // just put the text of this file in doc dictionary
                                doc_dict[doc_hash] = ann_rst.anns[idx].text;
                            }
                        }
                    }
                }
            }
        }

        // ok, let's create return
        var ret = {
            err_dict: err_dict,
            doc_dict: doc_dict
        };

        return ret;
    },

    /**
     * (internal) Update the ann's sentences
     * 
     * @param {Object} ann ann object
     * @returns updated ann
     */
    _update_ann_sentences: function(ann) {
        if (ann._sentences_text != '') {
            // if has updated, just skip
            return ann;
        }
        var r = nlp_toolkit.sent_tokenize(ann.text);
        ann._sentences = r.sentences;
        ann._sentences_text = r.sentences_text;

        // console.log('* updated sentences for ann', ann._filename);
        return ann;
    },

    count_tags_in_anns: function(anns) {
        var cnt = 0;
        for (let i = 0; i < anns.length; i++) {
            const ann = anns[i];
            cnt += ann.tags.length;
        }
        return cnt;
    },
    
};

// The NLP toolkit
var nlp_toolkit = {
    sent_tlb_syms: ' `!@#$%^&*()_+-=[]{}|\\:";\'<>?,/',
    sentencize_exceptions: new Set([
        // time
        'a.m.',
        'p.m.',
        'mon.',
        'tue.',
        'wed.',
        'thu.',
        'fri.',
        'sat.',
        'sun.',
        'jan.',
        'feb.',
        'mar.',
        'apr.',
        'jun.',
        'jul.',
        'aug.',
        'sep.',
        'oct.',
        'nov.',
        'dec.',

        // geo
        'ark.',
        'ala.',
        'ariz.',
        'calif.',
        'colo.',
        'conn.',
        'fla.',
        'ga.',
        'ia.',
        'id.',
        'ill.',
        'ind.',
        'kan.',
        'kans.',
        'ky.',
        'mass.',
        'n.c.',
        'n.d.',
        'n.h.',
        'n.j.',
        'n.m.',
        'n.y.',
        'neb.',
        'nebr.',
        'nev.',
        'okla.',
        'ore.',
        'pa.',
        's.c.',
        'tenn.',
        'va.',
        'wash.',
        'wis.',
        'd.c.',

        // title and names
        'jr.',
        'st.',
        'mr.',
        'mrs.',
        'ms.',
        'dr.',
        'm.d.',
        'ph.d.',
        'prof.',
        'bros.',
        'adm.',

        // other
        '#.',
        'no.',
        'e.g.',
        'ie.',
        'i.e.',
        'inc.',
        'ltd.',
        'co.',
        'corp.',
        'vs.',
        'v.s.',
        'gov.',
        'gen.',
        'n.e.r.v.', // EVANGELION ! :)
    ]),

    sent_tokenize: function(text, backend) {
        if (typeof(backend) == 'undefined') {
            backend = 'simpledot';
        }
        // console.log('* sentencizing text by ' + backend);

        if (backend == 'simpledot') {
            // return this.sent_tokenize_by_simpledot(text);
            return this.sent_tokenize_by_simpledot_v2(text);
        }

        // if (backend == 'compromise') {
        //     return this.sent_tokenize_by_compromise(text);
        // }

        if (backend == 'wink_nlp') {
            return this.sent_tokenize_by_wink_nlp(text);
        }

        throw {
            name: 'Not found backend',
            message: "The backend is not valid."
        }
    },

    tokenize_by_wink_nlp: function(text) {

    },

    /**
     * Convert the spans to the token index
     * 
     * The item in the list of tags need to contain the following:
     * {
     *     name: 'NAME', // the name this tags, e.g., LOC, PER, GEO
     *     span: [1, 2], // the start and end this tag in this sentence
     * }
     * 
     * So, the text of the tag is not required.
     * After processing, this will return a list:
     * [{
     *     token: 'TOKEN TEXT', // the text of this token
     *     span: [1, 2],        // the start and end of this token
     *     label: 'B-LOC'       // the BIO label, e.g., B-X, I-X, O
     * }, ...]
     * 
     * If any pre-processing is needed, please do it before calling.
     * 
     * @param {string} sentence just a sentence text
     * @param {list} tags list of tags
     * 
     * @returns {list} the list of token position and labels
     */
    convert_span_to_bio_by_wink_nlp: function(sentence, tags) {
        // first, convert the sentence to tokens
        var doc = wink_nlp.readDoc(sentence);
        var tokens = doc.tokens().out();
        
        // then search each token and get the position
        var idx = 0; 
        var pos = []; 
        for (let i=0; i<tokens.length; i++) {
            const token = tokens[i];
            var ia = sentence.indexOf(token);
            var tp = 1;
            while(true) {
                if (ia >= idx) {
                    pos.push({
                        token: token,
                        span: [ia, ia + token.length],
                        // the default label is just O
                        label: 'O'
                    })
                    idx = ia + token.length;
                    break;
                } else {
                    ia = sentence.indexOf(token, tp);
                    tp += 1;
                }
            }
        }
        
        // ok, let's check each token pos
        // make a copy of tags
        var tgs = JSON.parse(JSON.stringify(tags));
        for (let i=0; i<pos.length; i++) {
            // the simplest is just check all tags
            for (let j=0; j<tgs.length; j++) {
                if (i==4) {
                    console.log("j=" +j + ': '+ tgs[j].span + ' vs ' + pos[i].span);
                }
                if (this.is_overlapped(tgs[j].span, pos[i].span)) {
                    if (tgs[j].hasOwnProperty('_has_met')) {
                        pos[i].label = 'I-' + tgs[j].name;
                    } else {
                        pos[i].label = 'B-' + tgs[j].name;
                        tgs[j]._has_met = true;
                    }
                    break;
                }
            }
        }
        
        return pos;
    },

    sent_tokenize_by_wink_nlp: function(text) {
        var doc = wink_nlp.readDoc(text);
        var raw_sentences = doc.sentences().out();

        // for get the spans correctly
        // and the value is the last appearance
        var sentences_dict = {};
        // get all sentences and spans
        var sentences = [];
        // get all sentence trimed text
        var sentences_text = [];

        for (let idx=0; idx<raw_sentences.length; idx++) {
            // get this sentence
            var sentence = raw_sentences[idx];
            var spans_start = text.indexOf(sentence);

            // TODO fix the multiple same sentence bug
            if (sentences_dict.hasOwnProperty(sentence)) {
                // which means this is a duplicated 
                var i = 1;
                var cnt = 0;
                while(true) {
                    spans_start = text.indexOf(sentence, i);

                    if (sentences_dict[sentence] == spans_start) {
                        // which means this sentence appeared
                        i += 1;
                        cnt += 1;

                    } else {
                        // which means this span start is a new one
                        sentences_dict[sentence] = spans_start;
                        break;
                    }
                }

            } else {
                // ok, just add this new sentence
                sentences_dict[sentence] = spans_start;
            }
            var spans_end = spans_start + sentence.length;

            // sometimes the sentence has right blanks
            // we need to remove it to avoid unexpected linebreaks
            sentence = sentence.trimRight();

            sentences.push({
                text: sentence, 
                spans: {
                    start: spans_start, 
                    end: spans_end
                }
            });
            sentences_text.push(sentence);
        };

        return { 
            sentences: sentences,
            sentences_text: sentences_text.join('\n')
        };
    },

    /**
     * Sentencize a given text by a simple method
     * @param {String} text the content to be sentencized
     * @returns Object of sentences
     */
    sent_tokenize_by_simpledot: function(text) {
        // get all sentences and spans
        var sentences = [];

        // get all sentence trimed text
        var sentences_text = [];

        // a temp sentence
        var sentence = [];

        // locate the sentence start
        var spans_start = 0;

        // locate the sentence end
        var spans_end = 0;
        
        // flag for a sentence end
        var flag_sent = false;

        for (let i = 0; i < text.length; i++) {
            // get the current char
            const c = text[i];

            // set the end to current char
            spans_end = i;
            
            // before checking, set the flag to false
            flag_sent = false;

            // detect if this is a sentence break
            if (c == '.') {
                // but there are some corner cases
                if (i+1 < text.length && text[i+1].trim() != '') {
                    // which means next char is not empty
                    // this dot is not for a sentence
                    sentence.push(c);

                } else {
                    // this is an end of sentence
                    flag_sent = true;
                    // collect the char
                    sentence.push(c);
                }
                
            } else if ( c == '?' || c == '!' || c == ';') {
                flag_sent = true;
                // collect the char
                sentence.push(c);
    
            } else if ( c == '\n') {
                flag_sent = true;
                // no need to collect
                // sentence.push(c);

            } else {
                // collect the char
                sentence.push(c);
            }

            if (flag_sent) {
                // ok, this is a sentence.
                var _sentence = sentence.join('');

                // clear the collection
                sentence = [];

                // create a new sentence obj
                sentences.push({
                    text: _sentence, 
                    spans: {
                        start: spans_start, 
                        end: spans_end
                    }
                });

                // put the text
                sentences_text.push(_sentence);

                // move the spans_start to spans_end
                spans_start = spans_end + 1;
            }
        }

        // ok, let's check if the sentence collection is empty
        if (sentence.length > 0) {
            // there is a last sentence
            var _sentence = sentence.join('');

            // create a new sentence obj
            sentences.push({
                text: _sentence, 
                spans: {
                    start: spans_start, 
                    end: spans_end
                }
            });

            // put the text
            sentences_text.push(_sentence);
        }

        return { 
            sentences: sentences,
            sentences_text: sentences_text.join('\n')
        };
    },



    /**
     * Sentencize a given text by a simple method v2
     * @param {String} text the content to be sentencized
     * @returns Object of sentences
     */
    sent_tokenize_by_simpledot_v2: function(text, cfg) {
        if (typeof(cfg) == 'undefined') {
            cfg = {}
        }
        // get all sentences and spans
        var sentences = [];

        // get all sentence trimed text
        var sentences_text = [];

        // a temp sentence
        var sentence = [];

        // locate the sentence start
        var spans_start = 0;

        // locate the sentence end
        var spans_end = 0;
        
        // flag for a sentence end
        var flag_sent = false;

        for (let i = 0; i < text.length; i++) {
            // get the current char
            const c = text[i];

            // set the end to current char
            spans_end = i;
            
            // before checking, set the flag to false
            flag_sent = false;

            // detect if this is a sentence break
            // a fake loop for quick break
            // searching for spans_end
            while(1) {
                if (c == '.') {
                    // but there are some corner cases
                    if (i+1 < text.length && text[i+1].trim() != '') {
                        // 1. this case is simple.
                        // which means next char is not empty
                        // this dot is not for a sentence
                        // for example: 192.168.1.200 
                        // this is an IP, not four sentences
                        sentence.push(c);
                        break;

                    } 
                    // look back the whole token
                    var dot_token_start = i;
                    for (let bi = i-1; bi >= 0; bi--) {
                        if (this.sent_tlb_syms.includes(text[bi])) {
                            // ok, we found the break of a token
                            dot_token_start = bi + 1;
                            break;
                        }
                    }
                    // get the token with dot, for example:
                    // 
                    // 0123456789................
                    // when Mr. Anderson wakes up,
                    //     b^ i 
                    // 
                    // the c is at 7,
                    // the bi will find 4,
                    // the dot_token_start ^ will be 5
                    // then the dot_token is Mr.
                    var dot_token = text.substring(
                        dot_token_start,
                        i+1
                    );
                    var dot_token_lower = dot_token.toLocaleLowerCase();

                    // now find check this dot token
                    if (this.sentencize_exceptions.has(dot_token_lower)) {
                        // ok, this token is a special exception
                        // just skip
                        sentence.push(c);
                        break;
                    }
                    
                    // for everthing else
                    // this is an end of sentence
                    flag_sent = true;
                    // collect the char
                    sentence.push(c);
                    break;
                    
                } else if ( c == '?' || c == '!' || c == ';') {
                    flag_sent = true;
                    // collect the char
                    sentence.push(c);
                    break;
        
                } else if ( c == '\n') {
                    flag_sent = true;
                    // no need to collect
                    // sentence.push(c);
                    break;

                } else {
                    // collect the char
                    sentence.push(c);
                    break;
                }
            }

            if (flag_sent) {
                // ok, this is a sentence.
                var _sentence = sentence.join('');

                // clear the collection
                sentence = [];

                // create a new sentence obj
                sentences.push({
                    text: _sentence, 
                    spans: {
                        start: spans_start, 
                        end: spans_end
                    }
                });

                // put the text
                sentences_text.push(_sentence);

                // move the spans_start to spans_end for temp location
                spans_start = spans_end + 1;
            }
        }

        // ok, let's check if the sentence collection is empty
        if (sentence.length > 0) {
            // there is a last sentence
            var _sentence = sentence.join('');

            // create a new sentence obj
            sentences.push({
                text: _sentence, 
                spans: {
                    start: spans_start, 
                    end: spans_end
                }
            });

            // put the text
            sentences_text.push(_sentence);
        }

        return { 
            sentences: sentences,
            sentences_text: sentences_text.join('\n')
        };
    },



    /**
     * Sentencize a given text by a simple method v3
     * @param {String} text the content to be sentencized
     * @returns Object of sentences
     */
    sent_tokenize_by_simpledot_v3: function(text, cfg) {
        if (typeof(cfg) == 'undefined') {
            cfg = {}
        }
        // get all sentences and spans
        var sentences = [];

        // get all sentence trimed text
        var sentences_text = [];

        // a temp sentence
        var sentence = [];

        // locate the sentence start
        var spans_start = 0;

        // locate the sentence end
        var spans_end = 0;
        
        // flag for a sentence end
        var flag_sent = false;

        // flag for searching sentence start
        var flag_sfss = false;

        for (let i = 0; i < text.length; i++) {
            // get the current char
            const c = text[i];

            // set the end to current char
            spans_end = i;
            
            // before checking, set the flag to false
            flag_sent = false;

            // detect if this is a sentence break
            // a fake loop for quick break
            if (flag_sfss) {
                // searching for spans_start
                if (c == ' ') {
                    // event it's blank, just move the start
                    spans_start = i;
                } else {
                    // if non-white space char,
                    // it's a sentence
                    flag_sfss = false;
                    spans_start = i;
                    sentence.push(c);
                }

            } else {
                // searching for spans_end
                while(1) {
                    if (c == '.') {
                        // but there are some corner cases
                        if (i+1 < text.length && text[i+1].trim() != '') {
                            // 1. this case is simple.
                            // which means next char is not empty
                            // this dot is not for a sentence
                            // for example: 192.168.1.200 
                            // this is an IP, not four sentences
                            sentence.push(c);
                            break;
    
                        } 
                        // look back the whole token
                        var dot_token_start = i;
                        for (let bi = i-1; bi >= 0; bi--) {
                            if (this.sent_tlb_syms.includes(text[bi])) {
                                // ok, we found the break of a token
                                dot_token_start = bi + 1;
                                break;
                            }
                        }
                        // get the token with dot, for example:
                        // 
                        // 0123456789................
                        // when Mr. Anderson wakes up,
                        //     b^ i 
                        // 
                        // the c is at 7,
                        // the bi will find 4,
                        // the dot_token_start ^ will be 5
                        // then the dot_token is Mr.
                        var dot_token = text.substring(
                            dot_token_start,
                            i+1
                        );
                        var dot_token_lower = dot_token.toLocaleLowerCase();
    
                        // now find check this dot token
                        if (this.sentencize_exceptions.has(dot_token_lower)) {
                            // ok, this token is a special exception
                            // just skip
                            sentence.push(c);
                            break;
                        }
                        
                        // for everthing else
                        // this is an end of sentence
                        flag_sent = true;
                        // collect the char
                        sentence.push(c);
                        break;
                        
                    } else if ( c == '?' || c == '!' || c == ';') {
                        flag_sent = true;
                        // collect the char
                        sentence.push(c);
                        break;
            
                    } else if ( c == '\n') {
                        flag_sent = true;
                        // no need to collect
                        // sentence.push(c);
                        break;
    
                    } else {
                        // collect the char
                        sentence.push(c);
                        break;
                    }
                }
            }


            if (flag_sent) {
                // ok, this is a sentence.
                var _sentence = sentence.join('');

                // clear the collection
                sentence = [];

                // create a new sentence obj
                sentences.push({
                    text: _sentence, 
                    spans: {
                        start: spans_start, 
                        end: spans_end
                    }
                });

                // put the text
                sentences_text.push(_sentence);

                // move the spans_start to spans_end for temp location
                spans_start = spans_end + 1;
                // set flag for searching start
                flag_sfss = true;
            }
        }

        // ok, let's check if the sentence collection is empty
        if (sentence.length > 0) {
            // there is a last sentence
            var _sentence = sentence.join('');

            // create a new sentence obj
            sentences.push({
                text: _sentence, 
                spans: {
                    start: spans_start, 
                    end: spans_end
                }
            });

            // put the text
            sentences_text.push(_sentence);
        }

        return { 
            sentences: sentences,
            sentences_text: sentences_text.join('\n')
        };
    },


    /**
     * Sentencize a given text by a compromise.cool NLP
     * @param {String} text the content to be sentencized
     * @returns Object of sentences
     */
    sent_tokenize_by_compromise: function(text) {
        // first, convert the raw text to a doc object
        var doc = nlp(text);

        // get all sentences and spans
        var sentences = [];

        // for get the spans correctly
        // and the value is the last appearance
        var sentences_dict = {};

        // get all sentence trimed text
        var sentences_text = [];

        var doc_sentences = doc.sentences().json({
            offset: true
        });

        for (let i = 0; i < doc_sentences.length; i++) {
            const d = doc_sentences[i];
            
            // get this sentence text
            var sentence = d.text;

            // get the offset by compromise.cool NLP
            // thanks to spencer kelly (spencermountain@gmail.com)
            var spans_start = d.offset.start;
            var spans_end = d.offset.start + d.offset.length - 1;

            // to avoid right new line
            sentence = sentence.trimRight();

            // to avoid inline new line
            sentence = sentence.replaceAll('\n', ' ');
            sentence = sentence.replaceAll('\r', ' ');

            // save this sentence
            sentences.push({
                text: sentence, 
                spans: {
                    start: spans_start, 
                    end: spans_end
                }
            });
            sentences_text.push(sentence);
        }

        // doc.sentences().forEach(function(d) {
        //     // get this sentence
        //     var sentence = d.text();
        //     var spans_start = text.indexOf(sentence);

        //     // TODO fix the multiple same sentence bug
        //     if (sentences_dict.hasOwnProperty(sentence)) {
        //         // which means this is a duplicated 
        //         var i = 1;
        //         var cnt = 0;
        //         while(true) {
        //             spans_start = text.indexOf(sentence, i);

        //             if (sentences_dict[sentence] == spans_start) {
        //                 // which means this sentence appeared
        //                 i += 1;
        //                 cnt += 1;

        //             } else {
        //                 // which means this span start is a new one
        //                 sentences_dict[sentence] = spans_start;
        //                 break;
        //             }
        //         }

        //     } else {
        //         // ok, just add this new sentence
        //         sentences_dict[sentence] = spans_start;
        //     }
        //     var spans_end = spans_start + sentence.length;

        //     // sometimes the sentence has right blanks
        //     // we need to remove it to avoid unexpected linebreaks
        //     sentence = sentence.trimRight();

        //     sentences.push({
        //         text: sentence, 
        //         spans: {
        //             start: spans_start, 
        //             end: spans_end
        //         }
        //     });
        //     sentences_text.push(sentence);
        // });

        return { 
            sentences: sentences,
            sentences_text: sentences_text.join('\n')
        };
    },

    find_linech: function(pos, sentences) {
        for (let i = 0; i < sentences.length; i++) {
            const sentence = sentences[i];
            if (pos>=sentence.spans.start &&
                pos<=sentence.spans.end) {
                return {
                    line: i, 
                    ch: pos-sentence.spans.start
                };
            }
        }
        return null;
    },

    is_sub: function(loc_area, loc_sub) {
        if (loc_area[0] <= loc_sub[0] &&
            loc_area[1] >= loc_sub[1]) {
            return true;
        }
        return false;
    },

    is_overlapped: function(a, b) {
        if (a[0] >= b[0] && a[0] < b[1]) {
            return true;
        }
        if (a[1] > b[0] && a[1] <= b[1]) {
            return true;
        }
        if (a[0] <= b[0] && a[1] >= b[1]) {
            return true;
        }
        return false;
    },

    is_overlapped_in_list: function(loc_x, loc_list) {
        for (let i = 0; i < loc_list.length; i++) {
            const loc = loc_list[i];
            if (this.is_overlapped(loc_x, loc)) {
                return true;
            }
        }
        return false;
    },

    update_tag_locs_offset: function(locs, offset) {
        for (let i = 0; i < locs.length; i++) {
            locs[i][0] -= offset;
            locs[i][1] -= offset;
        }
        return locs;
    },

    download_text_tsv: function(anns, dtd, hint_dict, fn) {
        // convert the hint dict to a json obj
        var json = [];

        for (const tag_name in hint_dict) {
            if (Object.hasOwnProperty.call(hint_dict, tag_name)) {
                const tag_dict = hint_dict[tag_name];
                
                for (const tag_text in tag_dict.text_dict) {
                    if (Object.hasOwnProperty.call(tag_dict.text_dict, tag_text)) {
                        const tag = tag_dict.text_dict[tag_text];
                        
                        json.push({
                            tag: tag_name,
                            text: tag_text,
                            count: tag.count
                        });
                    }
                }

                // the nc tag
                for (const fn in tag_dict.nc_dict.ann_fn_dict) {
                    if (Object.hasOwnProperty.call(tag_dict.nc_dict.ann_fn_dict, fn)) {
                        const count = tag_dict.nc_dict.ann_fn_dict[fn];
                        
                        json.push({
                            tag: tag_name,
                            text: fn,
                            count: count
                        });
                    }
                }
            }
        }

        // then convert the json to csv
        var tsv = Papa.unparse(json, {
            delimiter: '\t'
        });

        // download this tsv
        var blob = new Blob([tsv], {type: "text/tsv;charset=utf-8"});
        // saveAs(blob, fn);

        return tsv;
    },


    download_sentence_tsv: function(anns, dtd, fn) {
        // convert the hint dict to a json obj
        var json = [];

        for (let i = 0; i < anns.length; i++) {
            var ann = anns[i];

            // fix the sentence
            ann = app_hotpot.update_ann_sentences(ann);

            for (let j = 0; j < ann.tags.length; j++) {
                const tag = ann.tags[j];
                // now mapping the span to token index
                if (!tag.hasOwnProperty('spans')) {
                    // this is not an entity tag
                    continue;
                }
                // there maybe multiple spans
                var locs = ann_parser.spans2locs(tag.spans);

                for (let k = 0; k < locs.length; k++) {
                    // const _span = spans[k];
                    // const span = nlp_toolkit.txt2span(_span);
                    const span = locs[k];
                    if (span[0] == -1 || span[1] == -1) {
                        // which means this tag is just a non-consuming tag
                        // at present, we won't use this kind of tag 
                        continue;
                    }

                    // find the offset in a sentence
                    var loc0 = this.find_linech(
                        span[0], 
                        ann._sentences
                    );
                    if (loc0 == null) {
                        // something wrong?
                        continue;
                    }
                    // find the location for the right part
                    // var loc1 = this.find_linech(span[1], ann._sentences);
                    var loc1 = Object.assign({}, loc0);
                    loc1.ch += (span[1] - span[0]);

                    // create a new row/item in the output data
                    json.push({
                        concept: tag.tag,
                        text: tag.text,
                        doc_span: span,
                        sen_span: [
                            loc0.ch,
                            loc1.ch
                        ],
                        document: ann._filename,
                        sentence: ann._sentences[loc0.line].text
                    });
                }
            }
        }

        // then convert the json to tsv
        var tsv = Papa.unparse(json, {
            delimiter: '\t'
        });

        // download this tsv
        var blob = new Blob([tsv], {type: "text/tsv;charset=utf-8"});
        saveAs(blob, fn);

        return tsv;
    },

    /**
     * Download the anns as raw XML format
     * @param {list} anns the list of ann objects
     * @param {object} dtd the dtd schema
     * @param {string} fn the download filename
     */
    download_dataset_raw: function(anns, dtd, fn, skip_dtd) {
        if (typeof(skip_dtd)=='undefined') {
            // by default, we don't need the dtd file to be included
            skip_dtd = true;
        }

        // create an empty zip pack
        var zip = new JSZip();
        var file_list = [];

        // put the dtd
        if (skip_dtd) {

        } else {
            // add the dtd content if exists
            if (dtd.hasOwnProperty('text')) {
                var dtd_fn = dtd.name + '.dtd';
                zip.file(dtd_fn, dtd.text);
                file_list.push(dtd.name + '.dtd');
            }
        }

        // create a folder in this zip file
        // var folder_name = 'annotation-'+ dtd.name + '';
        // use the given filename as the folder name (exclude the .zip)
        var folder_name = fn.substring(0, fn.lastIndexOf('.'));

        // check each ann file
        for (let i = 0; i < anns.length; i++) {
            const ann = anns[i];
            
            // convert to xml first
            var xmlDoc = ann_parser.ann2xml(ann, dtd);

            // convert xml to string
            var xmlStr = ann_parser.xml2str(xmlDoc, false);

            // get the filename of this annotation
            var ann_fn = ann._filename;

            // get the file
            // add the text dataset to zip
            var full_fn = folder_name + '/' + ann_fn;
            zip.file(full_fn, xmlStr);
            file_list.push(full_fn);
        }

        // create zip file
        zip.generateAsync({ type: "blob" }).then((function(fn) {
            return function (content) {
                saveAs(content, fn);
            }
        })(fn));

        return file_list.join('\n');
    },

    /**
     * Download the BIO format dataset
     * 
     * @param {list} anns the list of ann object
     * @param {object} dtd the dtd schema
     */
    download_dataset_bio: function(anns, dtd, fn, ratios, skip_non_tags_sentence) {
        if (typeof(ratios)=='undefined') {
            ratios = [0.8, 0.1, 0.1];
        }
        if (typeof(skip_non_tags_sentence)=='undefined') {
            skip_non_tags_sentence = true;
        }
        // first, create the dataset itself
        var ann_sentence_tags = {};

        // check each tag
        for (let i = 0; i < anns.length; i++) {
            var ann = anns[i];

            // 2022-08-10: the sentence may not be not ready 
            // when converting, fix the sentences
            ann = app_hotpot.update_ann_sentences(ann);

            var sentence_tags = {};
            for (let j = 0; j < ann.tags.length; j++) {
                const tag = ann.tags[j];

                // now mapping the span to token index
                if (!tag.hasOwnProperty('spans')) {
                    // this is not an entity tag
                    continue;
                }
                
                var spans = tag.spans.split(',');
                for (let k = 0; k < spans.length; k++) {
                    const _span = spans[k];

                    const span = this.txt2span(_span);
                    if (span[0] == -1 || spans[1] == -1) {
                        // which means this tag is just a non-consuming tag
                        // at present, we won't use this kind of tag when
                        // exporting the BIO
                        continue;
                    }
                    // find the offset in a sentence
                    var loc0 = this.find_linech(span[0], ann._sentences);
                    if (loc0 == null) {
                        // something wrong?
                        continue;
                    }

                    // find the location for the right part
                    // var loc1 = this.find_linech(span[1], ann._sentences);
                    var loc1 = Object.assign({}, loc0);
                    loc1.ch += (span[1] - span[0]);

                    if (!sentence_tags.hasOwnProperty(loc0.line)) {
                        sentence_tags[loc0.line] = {
                            sentence: ann._sentences[loc0.line],
                            tags: []
                        }
                    }

                    // put this tag for this line
                    sentence_tags[loc0.line].tags.push({
                        name: tag.tag,
                        span: [
                            loc0.ch,
                            loc1.ch
                        ],
                        // if k>0, which means this span is a multi location tag
                        force_label_i: k != 0
                    });
                }
            }
            ann_sentence_tags[i] = sentence_tags;
        }

        // now, we need to convert each sentence to 
        // the BIO format
        var bios_all = [];
        for (const ann_idx in ann_sentence_tags) {
            if (Object.hasOwnProperty.call(ann_sentence_tags, ann_idx)) {
                const sentence_tags = ann_sentence_tags[ann_idx];
                for (const sent_idx in sentence_tags) {
                    if (Object.hasOwnProperty.call(sentence_tags, sent_idx)) {
                        if (sentence_tags[sent_idx].tags.length == 0) {
                            if (skip_non_tags_sentence) {
                                continue;
                            }
                        };
                        
                        var labeled_tokens = this.convert_span_to_bio_by_wink_nlp(
                            sentence_tags[sent_idx].sentence.text,
                            sentence_tags[sent_idx].tags
                        );
        
                        bios_all.push(labeled_tokens);
                    }
                }
            }
        }
        // split into train, dev, test
        var [bios_train, bios_dt] = ds_spliter(bios_all, ratios[0]);
        var [bios_dev, bios_test] = ds_spliter(bios_dt, ratios[1] / (ratios[1] + ratios[2]));

        // create a help function for converting
        function bios2text(bios) {
            var txt_ds = [];
            var txt_lb = {};

            for (let i = 0; i < bios.length; i++) {
                const labeled_tokens = bios[i];
                for (let j = 0; j < labeled_tokens.length; j++) {
                    const item = labeled_tokens[j];
                    txt_ds.push(
                        item.token + '\t' + item.label
                    );
                    txt_lb[item.label] = 1;
                }
                // add a blank line after each sentence
                txt_ds.push('');
            }
            return [txt_ds, txt_lb];
        }

        // merge into text
        var [txt_dataset, txt_labels] = bios2text(bios_all);
        var [txt_train, _] = bios2text(bios_train);
        var [txt_dev, _] = bios2text(bios_dev);
        var [txt_test, _] = bios2text(bios_test);
        
        // convert text arr to pure string
        txt_dataset = txt_dataset.join('\n');
        txt_train = txt_train.join('\n');
        txt_dev = txt_dev.join('\n');
        txt_test = txt_test.join('\n');
        txt_labels = Object.keys(txt_labels).sort().join('\n');

        // last, create a zip file, which contains
        // create an empty zip pack
        var zip = new JSZip();
        var folder_name = 'dataset-'+ dtd.name + '-BIO';

        // add the text dataset to zip
        zip.file(folder_name + '/dataset.tsv', txt_dataset);
        // add the label to zip
        zip.file(folder_name + '/labels.tsv', txt_labels);
        // add the splited to zip
        zip.file(folder_name + '/train.tsv', txt_train);
        zip.file(folder_name + '/dev.tsv', txt_dev);
        zip.file(folder_name + '/test.tsv', txt_test);

        // create zip file
        zip.generateAsync({ type: "blob" }).then((function(fn) {
            return function (content) {
                saveAs(content, fn);
            }
        })(fn));

        return txt_dataset;
    },

    txt2span: function(txt) {
        var ps = txt.split('~');
        return [
            parseInt(ps[0]),
            parseInt(ps[1])
        ]
    },

    /**
     * Get the sentence offset of a given spans in document's sentences
     * 
     * @param {string} spans offsets in a document, like 123~124
     * @param {list} sentences a list of `sentence` {spans: {start:, end:}, text:''}
     * @returns a list of possible locations
     */
    get_sen_span: function(spans, sentences) {
        var locs = ann_parser.spans2locs(spans);

        // the ret is a list of results
        var ret = [];

        for (let k = 0; k < locs.length; k++) {
            // const _span = spans[k];
            // const span = nlp_toolkit.txt2span(_span);
            const loc = locs[k];
            if (loc[0] == -1 || loc[1] == -1) {
                // which means this tag is just a non-consuming tag
                // at present, we won't use this kind of tag 
                continue;
            }

            // find the offset in a sentence
            var loc0 = this.find_linech(
                loc[0], 
                sentences
            );
            if (loc0 == null) {
                // something wrong?
                continue;
            }
            // find the location for the right part
            // var loc1 = this.find_linech(span[1], ann._sentences);
            var loc1 = Object.assign({}, loc0);
            loc1.ch += (loc[1] - loc[0]);

            // create a new row/item in the output data
            ret.push({
                doc_span: loc,
                sen_span: [
                    loc0.ch,
                    loc1.ch
                ],
                sentence: sentences[loc0.line].text
            });
        }

        return ret;
    }

};

// The MedTagger toolkit
/**
 * MedTagger format annotation file parser
 * 
 */
 var medtagger_toolkit = {
     regex: {
        // the pattern of key value for each result
        key_and_value: /(\S+)="([^"]+)"/gm,
    },

    convert_medtagger_files_to_anns: function(txts, anns, dtd) {
        // first of all, make a dict for ann file names
        var ann_dict = {};
        for (let i = 0; i < anns.length; i++) {
            const ann = anns[i];
            ann_dict[ann.fh.name] = ann;
        }

        // then, work on each txt
        var mt_anns = [];

        for (let i = 0; i < txts.length; i++) {
            const txt = txts[i];
            
            // the ann name should be exactly the txt + '.ann'
            var ann_fn = txt.fh.name + '.ann';

            if (!ann_dict.hasOwnProperty(ann_fn)) {
                // what???
                console.log('* not found ann file for', txt.fh.name);
                continue;
            }
            var ann = ann_dict[ann_fn];

            // ok, we found the matched ann!
            var ann_rs = this.parse_ann_file(
                ann
            );

            // to xml ann
            var mt_ann = this.to_medtator_ann(
                txt,
                ann_rs,
                dtd
            );

            mt_anns.push(mt_ann);
        }

        return mt_anns;
    },

    to_medtator_ann: function(file, ann_rs, dtd) {
        // this is an empty medtator ann
        var ann = {
            text: file.text,
            dtd_name: dtd.name,
            tags: [],
            meta: {},

            // other info
            _fh: null,
            _filename: file.fh.name + '.xml',
            _has_saved: true,
            _sentences: [],
            _sentences_text: ''
        };

        for (let i = 0; i < ann_rs.length; i++) {
            const r = ann_rs[i];
        
            var tag = {};
            // each r contains many k-v pairs
            // we need to copy some values
            if (r.hasOwnProperty('text')) {
                tag['text'] = r.text;
            }
            if (r.hasOwnProperty('norm')) {
                tag['tag'] = r.norm;
            }
            if (r.hasOwnProperty('start') &&
                r.hasOwnProperty('end')) {
                tag['spans'] = r.start + '~' + r.end;
            }

            // then we need to check the tag quality
            if (tag.hasOwnProperty('tag') &&
                tag.hasOwnProperty('text')&&
                tag.hasOwnProperty('spans')) {
                // get the tag_def for this tag
                if (!dtd.tag_dict.hasOwnProperty(tag.tag)) {
                    // this is possible that the normed term may not be available
                    console.log('* skip unknown norm @' + i + ':', tag.tag);
                    continue;
                }

                // it should be matched with the dtd
                var tag_def = dtd.tag_dict[tag.tag];

                // now need to add an ID for this tag
                tag.id = ann_parser.get_next_tag_id(
                    ann,
                    tag_def
                )

                // one more step, the MedTagger output won't contain attrs
                // which are defined in the dtd, so we need to set them
                for (let k = 0; k < tag_def.attrs.length; k++) {
                    const att = tag_def.attrs[k];
                    if (tag.hasOwnProperty(att.name)) {
                        // ok, that's what it should be
                    } else {
                        // also ok, that's what it actually is 
                        tag[att.name] = att.default_value;                            
                        console.log('* patched missing '+tag.tag+'.'+att.name+'] to ' + tag.id);
                    }
                }
                ann.tags.push(tag);
            } else {
                console.log('* skip incomplete tag', tag);
            }
            
        }

        return ann;
    },

    /**
     * Parse the MedTagger output ann file
     * 
     * @param {Object} ann a MedTagger ann file object
     * @returns a list of key-value dict format
     */
    parse_ann_file: function(ann_file) {

        // first, make a ret
        var rs = [];

        // lines may be not available
        if (!ann_file.hasOwnProperty('lines')) {
            ann_file.lines = ann_file.text.split('\n');
        }

        // second, split the ann lines
        for (let i = 0; i < ann_file.lines.length; i++) {
            const ann_line = ann_file.lines[i];
            var kvs = this.parse_ann_line(ann_line);

            if (kvs == null) {
                // so this line may be empty or no values?
                continue;
            }

            // I guess it works
            rs.push(kvs);
        }

        // no matter what we have at last, just return it
        return rs;
    },

    /**
     * Parse a single line of MedTagger output 
     * 
     * @param {string} ann_line a single line in the MedTagger output file
     * @returns a key-value dict format object
     */
    parse_ann_line: function(ann_line) {
        if (ann_line == '') {
            return null;
        }

        // the parts are seperated by \t sym
        var parts = ann_line.split('\t');

        // r is record or result
        var r = {};

        for (let i = 0; i < parts.length; i++) {
            const p = parts[i];
            var ret = this.get_key_and_value(p);

            if (ret.length < 2) {
                // must be something wrong??
                continue;
            }
            
            // the first value is the key
            // and the second is the value
            r[ret[0]] = ret[1];
        }

        return r;
    },

    get_key_and_value: function(s) {
        let m;
        var ret = [];
        let regex = this.regex.key_and_value;

        while ((m = regex.exec(s)) !== null) {
            // This is necessary to avoid infinite loops with zero-width matches
            if (m.index === regex.lastIndex) {
                regex.lastIndex++;
            }

            // the final values?
            var values = [];

            // The result can be accessed through the `m`-variable.
            m.forEach((match, groupIndex) => {
                // console.log(`Found attr require match, group ${groupIndex}: ${match}`);
                // group 0 is the leading text
                if (groupIndex == 1) {
                    // which is the key
                    values.push(match)

                } else if (groupIndex == 2) {
                    // get value 
                    // not matter what is left, save it
                    values.push(match);
                }
            });

            ret = values;
        }

        
        return ret;
    },

 };

// The Error Analyzer
/**
 * Error Analyzer
 * 
 * A toolkit for analyzing the corpus error.
 * The function is based on IAA calculator's output:
 * 
 * When using annotator A as Gold Standard Corpora (GSC),
 * The annotator B can be regarded as a system to be assessed.
 * The IAA between GSC and B, especially the false positive (FP)
 * and false negative (FN) can be analyzed as errors.
 */
var error_analyzer = {
    // default errors definition
    DEFAULT_ERROR_DEF: {
        "Linguistic": [
            "Lexicon",
            "Orthographic",
            "Morphologic",
            "Syntactic",
            "Semantic",
        ], 
        "Contextual": [
            "Section",
            "Certainty",
            "Status",
            "Temporality",
            "Subject",
            "Absence of Context",
            "Exclusion",
        ], 
        "Annotation": [
            "Missing Annotation",
            "Insufficent Context",
            "Extrapolation of Evidence",
            "Incorrect Annotation",
            "Pattern and Rule",
        ],
        "Concept Definition": [
            "Ambiguity",
            "Source Evidence",
            "Change of Status",
            "Non-defined Concept",
        ]
    },

    UNK_ERROR_TYPE: 'UNKNOWN',
    UNK_ERROR_CATE: 'UNK',

    ERROR_COLOR_SCHEMA: [{
        c_cate: '#890808',
        c_type: ['#2a3366', '#4e315a', '#682f4f', '#7d2b43', '#912437', '#a4192b', '#b7001d']
    }, {
        c_cate: '#3D348B',
        c_type: ['#3d348b', '#3c3c9d', '#3a44b0', '#354cc3', '#2e54d7', '#215cea', '#0065fe']
    }, {
        c_cate: '#7678ED',
        c_type: ['#7678ed', '#7584d2', '#708fb6', '#67999b', '#59a37f', '#41ac62', '#00b541']
    }, {
        c_cate: '#F7B801',
        c_type: ['#f7b801', '#f6c400', '#f5d000', '#f3dc00', '#f1e800', '#eef300', '#ebff00']
    }, {
        c_cate: '#F18701',
        c_type: ['#f18701', '#e5752c', '#d96440', '#cc5150', '#bf3e5d', '#b1276a', '#a10076']
    }, {
        c_cate: '#F29218',
        c_type: ['#f29218', '#dc8013', '#c56d0f', '#b05c0a', '#9a4a06', '#863903', '#712900']
    }, {
        c_cate: '#F39C2D',
        c_type: ['#f39c2d', '#f78d55', '#f97c74', '#fa6a91', '#f855ad', '#f53bc9', '#ef00e4']
    }],

    /**
     * Get statistics on the given tags
     * 
     * The err is an object like the following:
     * 
     * {
        // unique id for this tag in this analysis
        "uid": "8x9iju7xs2",
        // id in that document / file
        "id": "AE1",                
        "spans": "82~87",           
        "sentence": "I got faint",
        "sentence_spans": "6~11",  
        "tag": "AE",                
        "text": "faint",            
        "file_name": "12345.txt",
        "_annotator": "B",
        "_judgement": "FP",
        
        // the following are optional based on dtd
        "certainty": "Positive",    
        "comment": "Are you sure?", 

        // the following may be provided by user or web service
        "errors": [
            { "category": "Linguistic", "type": "Morphologic" },
            { "category": "Annotation", "type": "Missing Annotation" },
            { "category": "Concept Definition", "type": "Ambiguity" }, 
        ]
     * }
     * 
     * @param {Object} iaa_dict a dict of iaa result
     * @param {Object} err_dict a dict of error tags by the uid of error tag
     * @param {Object} dtd annotation schema
     */
    get_err_stat: function(iaa_dict, err_dict, dtd) {
        // there are several things we want
        // 1. basic count by results and concept
        // 2. error type and cate stat
        // 3. token and doc level

        // using basic number in iaa
        var stat_by_iaa = {
            n_TP: iaa_dict.all.cm.tp,
            n_FP: iaa_dict.all.cm.fp,
            n_FN: iaa_dict.all.cm.fn,
            n_F: iaa_dict.all.cm.fp + iaa_dict.all.cm.fn,
            error_rate: this.get_error_rate(
                iaa_dict.all.cm.tp,
                iaa_dict.all.cm.fp,
                iaa_dict.all.cm.fn
            ),
            accuracy: this.get_accuracy(
                iaa_dict.all.cm.tp,
                iaa_dict.all.cm.fp,
                iaa_dict.all.cm.fn
            ),
            precision: iaa_dict.all.precision,
            recall: iaa_dict.all.recall,
            f1: iaa_dict.all.f1,
        };

        // stat by dtd
        var stat_by_dtd = {};
        // init the stat by dtd with dtd etags
        for (let i = 0; i < dtd.etags.length; i++) {
            const etag = dtd.etags[i];
            stat_by_dtd[etag.name] = {
                FP: [],
                FN: [],
            };
        }

        // stat by err
        var stat_by_err = {
            // the only type is UNKNOWN at present
            'UNKNOWN': {
                FP: [],
                FN: []
            }
        };

        // stat by relations for sankey
        var stat_by_rel = {
            // column 1: error 
            c_error: { FP: { 'UNK': [] }, FN: { 'UNK': [] } },
            // column 2: error category
            c_category: { 'UNK': { 'UNKNOWN': [] }},
            // column 3: error type
            c_type: { 'UNKNOWN': {} }
        };

        // stat by something maybe useful
        var stat_by_smu = {
            total_err_labels: 0,
            freq_n_err_labels: {
                // 0 labels, which means not labeled
                0: {FP: [], FN: []},
                // I think 9 should be enough, isn't it?
                1: {FP: [], FN: []},
                2: {FP: [], FN: []},
                3: {FP: [], FN: []},
                4: {FP: [], FN: []},
                5: {FP: [], FN: []},
                6: {FP: [], FN: []},
                7: {FP: [], FN: []},
                8: {FP: [], FN: []},
                9: {FP: [], FN: []},
            }
        };

        // stat by token
        var stat_by_txt = {};

        // stat by document
        var stat_by_doc = {};

        // check each tag
        for (const uid in err_dict) {
            const err = err_dict[uid];

            // update dtd stat
            stat_by_dtd[err.tag][err._judgement].push(err.uid);

            // update the token stat
            if (!stat_by_txt.hasOwnProperty(err.text)) {
                stat_by_txt[err.text] = { FP: [], FN: [] };
            }
            stat_by_txt[err.text][err._judgement].push(uid);

            // update the doc stat
            if (!stat_by_doc.hasOwnProperty(err.file_hash)) {
                stat_by_doc[err.file_hash] = { FP: [], FN: [] };
            }
            stat_by_doc[err.file_hash][err._judgement].push(uid);
            
            // update the error stat if it has
            if (err.hasOwnProperty('errors')) {
                // ok, this has information
                ////////////////////////////////////////
                // stat by smu?
                ////////////////////////////////////////
                stat_by_smu.freq_n_err_labels[err.errors.length][err._judgement].push(uid);

                for (let i = 0; i < err.errors.length; i++) {
                    ////////////////////////////////////////
                    // stat by smu?
                    ////////////////////////////////////////
                    stat_by_smu.total_err_labels += 1;

                    const e = err.errors[i];
                    ////////////////////////////////////////
                    // stat by err
                    ////////////////////////////////////////
                    if (stat_by_err.hasOwnProperty(e.type)) {
                        // ok, no need to revise stat_by_err
                    } else {
                        // stat_by_err doesn't have this?
                        // just init it with an empty one
                        stat_by_err[e.type] = {
                            FP: [], 
                            FN: []
                        };
                    }
                    stat_by_err[e.type][err._judgement].push(uid);

                    ////////////////////////////////////////
                    // stat by relation
                    ////////////////////////////////////////
                    if (i > 0) {
                        // when counting the relationship
                        // just use the first label
                        continue;
                    }
                    // update the relationship
                    // col 1-2
                    if (!stat_by_rel.c_error[err._judgement].hasOwnProperty(e.category)) {
                        // init it as a list
                        stat_by_rel.c_error[err._judgement][e.category] = [];
                    }
                    stat_by_rel.c_error[err._judgement][e.category].push(uid);

                    // col 2-3
                    if (!stat_by_rel.c_category.hasOwnProperty(e.category)) {
                        // init it as a obj
                        stat_by_rel.c_category[e.category] = {};
                    }
                    if (!stat_by_rel.c_category[e.category].hasOwnProperty(e.type)) {
                        // init it as a list
                        stat_by_rel.c_category[e.category][e.type] = [];
                    }
                    stat_by_rel.c_category[e.category][e.type].push(uid);

                    // col 3-4
                    if (!stat_by_rel.c_type.hasOwnProperty(e.type)) {
                        // init it as a obj
                        stat_by_rel.c_type[e.type] = {};
                    }
                    if (!stat_by_rel.c_type[e.type].hasOwnProperty(err.tag)) {
                        // init it as a list
                        stat_by_rel.c_type[e.type][err.tag] = [];
                    }
                    stat_by_rel.c_type[e.type][err.tag].push(uid);

                }
            } else {
                // the freq update
                stat_by_smu.freq_n_err_labels[0][err._judgement].push(uid);

                // oh, this err doesn't have any information
                // just send to UNKNOWN
                stat_by_err['UNKNOWN'][err._judgement].push(uid);

                // update the relationship
                // col 1
                stat_by_rel.c_error[err._judgement].UNK.push(uid);
                // col 2
                stat_by_rel.c_category.UNK.UNKNOWN.push(uid);
                // col 3
                if (!stat_by_rel.c_type.UNKNOWN.hasOwnProperty(err.tag)) {
                    // init it as a list
                    stat_by_rel.c_type.UNKNOWN[err.tag] = [];
                }
                stat_by_rel.c_type.UNKNOWN[err.tag].push(uid);
            }
        }

        // get max values for dtd, start from 10
        var max_val = 10;
        for (let i = 0; i < dtd.etags.length; i++) {
            const etag = dtd.etags[i];
            var _max_val = stat_by_dtd[etag.name].FP.length + 
                stat_by_dtd[etag.name].FN.length;
            if (_max_val > max_val) {
                max_val = _max_val;
            }
        }
        // get the max value for err type
        for (const err_type in stat_by_err) {
            var _max_val = stat_by_err[err_type].FP.length + 
            stat_by_err[err_type].FN.length;
            if (_max_val > max_val) {
                max_val = _max_val;
            }
        }
        // also put this max_val into smu
        stat_by_smu['max_val'] = max_val;

        // get average doc err
        var doc_n_errs = Object.values(stat_by_doc).map(d=>d.FP.length + d.FN.length);
        // make sure math.js is imported
        var med_n_err_per_doc = math.median(doc_n_errs);
        // also put this into smu
        stat_by_smu['med_n_err_per_doc'] = med_n_err_per_doc;
        
        // build a ret object
        var ret = {
            by_iaa: stat_by_iaa,
            by_dtd: stat_by_dtd,
            by_err: stat_by_err,
            by_rel: stat_by_rel,
            by_txt: stat_by_txt,
            by_doc: stat_by_doc,
            by_smu: stat_by_smu,
        };

        return ret;
    },

    /**
     * Get the Sankey Diagram Data
     * 
     * @param {Object} stat_by_rel statistics on the relationship
     * @returns sankey data object
     */
    get_sankey_data: function(stat_by_rel, err_def_dict) {
        var nodes = {};
        var links = [];

        // build col 1
        var cols = ['c_error', 'c_category', 'c_type'];
        for (let i = 0; i < cols.length; i++) {
            const col = cols[i];
            for (const nLeft in stat_by_rel[col]) {
                for (const nRight in stat_by_rel[col][nLeft]) {
                    var uids = stat_by_rel[col][nLeft][nRight];
                    var class_name = 'cursor-pointer';

                    if (nLeft == this.UNK_ERROR_CATE ||
                        nRight == this.UNK_ERROR_CATE) {
                        if (uids.length == 0) {

                            // no need to add UNK when there is no uid
                            continue;
                        }
                    }
                    
                    // update the link
                    links.push({
                        source: nLeft,
                        target: nRight,
                        value: uids.length,
                        uids: uids,
                        column: i,
                        class_name: class_name
                    });
    
                    // update the left node
                    if (!nodes.hasOwnProperty(nLeft)) {
                        var _cls = class_name;
                        if (col == 'c_error') {
                            _cls += ' razer-bg-' + nLeft;
                        }
                        // add this node
                        nodes[nLeft] = {
                            id: nLeft,
                            name: nLeft,
                            value: 0,
                            uids: [],
                            layer: i,
                            // style
                            class_name: _cls,
                            color: clr
                        }
                    }
                    // update node value
                    if (i <= 0) {
                        // no need to double add after first column
                        nodes[nLeft].value += uids.length;
                        nodes[nLeft].uids = nodes[nLeft].uids.concat(uids);
                    }
    
                    // update the right node
                    if (!nodes.hasOwnProperty(nRight)) {
                        // add this node
                        var _cls = class_name;
                        if (col=='c_type') {
                            _cls += ' svgmark-tag-' + nRight;
                        }
                        var clr = '';
                        if (col == 'c_error' || col == 'c_category') {
                            clr = err_def_dict.adv_def[nRight].color;
                        }
                        nodes[nRight] = {
                            id: nRight,
                            name: nRight,
                            value: 0,
                            uids: [],
                            layer: i + 1,
                            class_name: _cls,
                            color: clr
                        }
                    }
                    // update the right node
                    nodes[nRight].value += uids.length;
                    nodes[nRight].uids = nodes[nRight].uids.concat(uids);
                }
            }
        }
        
        // convert nodes to node list
        nodes = Object.values(nodes);

        var ret = {
            nodes: nodes,
            links: links,
        };

        return ret;
    },

    get_top_10_tokens: function(stat_by_txt) {
        // first, get the list of all txt
        var ns = [];
        var ts = [];
        for (const txt in stat_by_txt) {
            var s = stat_by_txt[txt];
            var n = s.FP.length + s.FN.length;
            ns[ns.length] = n;
            ts[ts.length] = txt;
        }
        // get top 10
        var rs = stat_helper.get_top_n(ns, 10);
        // export tokens
        var tokens = [];
        for (let i = 0; i < rs.length; i++) {
            const r = rs[i];
            // r is [val, index] format
            tokens.push(
                ts[r[1]]
            );
        }

        return tokens;
    },

    use_tews: function(url, req, callback) {
        $.ajax({
            type: 'POST',
            url: url,
            data: {
                data: JSON.stringify(req)
            },
            success: callback,
            error: function(jqXHR, textStatus, errorThrown) {
                console.error(textStatus, errorThrown);
            }
        });
    },

    use_eaws: function(url, req, callback) {
        $.ajax({
            type: 'POST',
            url: url,
            data: {
                data: JSON.stringify(req)
            },
            success: callback,
            error: function(jqXHR, textStatus, errorThrown) {
                console.error(textStatus, errorThrown);
            }
        });
    },

    use_eaws_q: function(url, req, callback) {
        $.ajaxQueue({
            type: 'POST',
            url: url,
            data: {
                data: JSON.stringify(req)
            },
            success: callback,
            error: function(jqXHR, textStatus, errorThrown) {
                console.error(textStatus, errorThrown);
            }
        });
    },

    get_error_rate: function(tp, fp, fn) {
        var sum = tp + fp + fn;
        if (sum == 0) {
            return NaN;
        }
        return (fp + fn) / sum;
    },

    get_accuracy: function(tp, fp, fn) {
        var sum = tp + fp + fn;
        if (sum == 0) {
            return NaN;
        }
        return tp / sum;
    },

    get_razer_report_summary: function(razer, format) {
        if (typeof(format) == 'undefined') {
            format = 'json';
        }
        // FP, FN, ER, Acc, Pre, Rec, F1 ...
        var js = [];

        js.push({ 'item': 'TP', 'result': razer.err_stat.by_iaa.n_TP });
        js.push({ 'item': 'FP', 'result': razer.err_stat.by_iaa.n_FP });
        js.push({ 'item': 'FN', 'result': razer.err_stat.by_iaa.n_FN });
        js.push({ 'item': 'Error Rate', 'result': razer.err_stat.by_iaa.error_rate });
        js.push({ 'item': 'Accuracy', 'result': razer.err_stat.by_iaa.accuracy });
        js.push({ 'item': 'Precision', 'result': razer.err_stat.by_iaa.precision });
        js.push({ 'item': 'Recall', 'result': razer.err_stat.by_iaa.recall });
        js.push({ 'item': 'F1-Score', 'result': razer.err_stat.by_iaa.f1 });

        if (format == 'json' || format != 'excelws') {
            return js;
        }

        // ok, let's parse for excel
        var ws = XLSX.utils.json_to_sheet(js);
        return ws;
    },

    get_razer_report_stat_by_concept: function(razer, format) {
        if (typeof(format) == 'undefined') {
            format = 'json';
        }

        var js = [];
        for (const etag_name in razer.err_stat.by_dtd) {
            var stat = razer.err_stat.by_dtd[etag_name];
            js.push({
                'concept': etag_name,
                'FP': stat.FP.length,
                'FN': stat.FN.length,
            });
        }

        if (format == 'json' || format != 'excelws') {
            return js;
        }

        // ok, let's parse for excel
        var ws = XLSX.utils.json_to_sheet(js);
        return ws;
    },

    get_razer_report_stat_by_err_type: function(razer, razer_err_def, format) {
        if (typeof(format) == 'undefined') {
            format = 'json';
        }

        var js = [];
        for (const err_cate in razer_err_def) {
            js.push({
                'category': err_cate,
                'type': '',
                'FP': '',
                'FN': ''
            });
            for (let i = 0; i < razer_err_def[err_cate].length; i++) {
                const err_type = razer_err_def[err_cate][i];
                var FP = 0;
                var FN = 0;
                if (razer.err_stat.by_err.hasOwnProperty(err_type)) {
                    FP = razer.err_stat.by_err[err_type].FP.length;
                    FN = razer.err_stat.by_err[err_type].FN.length;
                }
                js.push({
                    'category': '',
                    'type': err_type,
                    'FP': FP,
                    'FN': FN
                });
            }
        }

        if (format == 'json' || format != 'excelws') {
            return js;
        }

        // ok, let's parse for excel
        var ws = XLSX.utils.json_to_sheet(js);
        return ws;
    },

    get_razer_report_tag_list: function(razer, format) {
        if (typeof(format) == 'undefined') {
            format = 'json';
        }

        var js = [];
        for (const uid in razer.err_dict) {
            var t = razer.err_dict[uid];

            var j = {
                uid: uid,
                'id': t.id,
                'spans': t.spans,
                'tag': t.tag,
                'text': t.text,
                'error': t._judgement,
                'file_name': t.file_name,
                'sentence_spans': t.sentence_spans,
                'sentence': t.sentence,
            };

            if (t.hasOwnProperty('errors')) {
                for (let k = 0; k < t.errors.length; k++) {
                    const e = t.errors[k];
                    j['label_'+(k+1)] = e.type;
                }
            }
            js.push(j);
        }

        if (format == 'json' || format != 'excelws') {
            return js;
        }

        // ok, let's parse for excel
        var ws = XLSX.utils.json_to_sheet(js);
        return ws;
    },

    get_stat_of_err_def: function(err_def) {
        if (err_def == null) {
            return {
                short_title: 'NA',
                n_cates: 0,
                n_types: 0
            };
        }
        var n_cates = Object.keys(err_def).length;
        var n_types = 0;

        var short_title = null;
        for (const c in err_def) {
            n_types += err_def[c].length;

            if (short_title == null) {
                short_title = c;
            }
        }
        if (short_title == null) {
            short_title = '';
        } else {
            short_title += ' and ' + (n_cates - 1) + ' more';
        }
        return {
            short_title: short_title,
            n_cates: n_cates,
            n_types: n_types
        };
    }
};

// The Sankey Diagram based on D3.js
/**
 * Sankey Diagram based on D3-sankey
 */
var figmker_sankey = {


make_fig: function(box_id) {

return {
    // settings for the sankey figure
    width: 620,
    height: 400,
    margin: {
        top: 15, 
        right: 10, 
        bottom: 10, 
        left: 10
    },

    node_width: 15,
    lane_width: 140,
    n_lanes: 3,
    padding: 8,

    // variables for quick access
    svg: null,

    // for all elements in sankey
    chart: null,

    // the sankey function by d3-sankey
    sankey: null,

    // graph created by sankey function
    graph: null,

    // links element in the graph
    links: null,

    // nodes element in the grpah
    nodes: null,

    // DOM, please modify when init
    box_id: box_id,

    // Headers for each lane of node
    headers: [
        'A', 'B', 'C', 'D'
    ],

    // callbacks
    on_click_node: function(event, d) {
        console.log('* clicked node', event, d);
    },
    on_click_link: function(event, d) {
        console.log('* clicked link', event, d);
    },

    init: function() {
        // get the svg
        this.svg = d3.select("#"+this.box_id)
            .append("svg")
            .attr('id', this.box_id+'_svg')
            .attr("width", this.width + this.margin.left + this.margin.right)
            .attr("height", this.height + this.margin.top + this.margin.bottom);

        // create the sankey
        this.sankey = d3.sankey()
            .size([
                this.node_width + 
                    this.n_lanes * (this.lane_width + this.node_width),
                this.height
            ])
            .nodeId(d => d.id)
            .nodeWidth(this.node_width)
            .nodePadding(this.padding)
            .nodeSort(this.node_sort)
            .linkSort(this.link_sort)
            .nodeAlign(d3.sankeyCenter);
    },

    node_sort: function(a, b) {
        return b.value - a.value;
    },

    link_sort: function(a, b) {
        return b.value - a.value;
    },

    clear: function() {
        this.chart.remove();
        this.chart = null;
    },

    draw: function(data) {
        this.graph = this.sankey(data);

        if (this.chart != null) {
            // this is not a new chart
            this.clear();
        }

        // draw a blank chart for 
        this._draw_blank_chart();
        
        // draw links
        this._draw_links();

        // draw nodes
        this._draw_nodes();

        // draw headers
        this._draw_headers();
    },

    _draw_blank_chart: function() {
        // get the chart
        this.chart = this.svg.append("g")
            .attr('id', this.box_id + '_chart')
            .attr("class", "sankey-chart")
            .attr("transform", 
                "translate(" + this.margin.left + "," + this.margin.top + ")"
            );
    },

    _draw_links: function() {
        // draw links
        this.links = this.chart.append("g")
            .classed("links", true)
            .selectAll("path")
            .data(this.graph.links)
            .enter()
            .append("path")
            .classed("link", true)
            .attr("d", d3.sankeyLinkHorizontal())
            .attr("class", d=>{
                if (d.hasOwnProperty('class_name')) {
                    return 'sankey-link ' + d.class_name;
                } else {
                    return 'sankey-link'
                }
            })
            .attr("fill", "none")
            .attr("stroke", function(d) {
                // if (d.layer == 2) {
                //     return d.target.color;
                // } else {
                //     return d.source.color;
                // }
                return '#cccccc';
            })
            .attr("stroke-width", d => d.width)
            .attr("stroke-opacity", .5)
            .on('click', this.on_click_link);
    },

    _draw_nodes: function() {
        this.nodes = this.chart.append("g")
            .classed("nodes", true)
            .selectAll("rect")
            .data(this.graph.nodes)
            .enter();

        // add the rect of each node
        this.nodes
            .append("rect")
            .classed("node", true)
            .attr("x", d => d.x0)
            .attr("y", d => d.y0)
            .attr("width", d => d.x1 - d.x0)
            .attr("height", d => d.y1 - d.y0)
            .attr("class", d=>{
                if (d.hasOwnProperty('class_name')) {
                    return 'sankey-node ' + d.class_name;
                } else {
                    return 'sankey-node';
                }
            })
            .attr("fill", function(d) {
                if (d.color != '') {
                    return d.color;
                }
                return '#999999';
            })
            .attr("opacity", 1)
            .on('click', this.on_click_node);

        // add text
        this.nodes.append("g")
            .attr('class', 'node-label')
            .attr('transform', function(d) {
                var offset = 0;
                var dx = d.x0 + 20 + offset;
                var dy = d.y0 + (d.y1 - d.y0) / 2;
                return `translate(${dx}, ${dy})`;
            })
            .each(function(d) {
                var node = d3.select(this);
                node.append('text')
                    .attr('class', 'nodel-name')
                    .attr("text-anchor", "start")
                    .attr("transform", null)
                    .attr('font-size', d=>d.value>10?10:8)
                    .attr('y', 5)
                    .text(d.name + ' (' + d.value + ')');

                // node.append('text')
                //     .attr('class', 'nodel-name')
                //     .attr("text-anchor", "start")
                //     .attr("transform", null)
                //     .attr('font-size', 10)
                //     .attr('y', -1)
                //     .text(d.name);
                // node.append('text')
                //     .attr('class', 'nodel-value')
                //     .attr("text-anchor", "start")
                //     .attr("transform", null)
                //     .attr('font-size', 8)
                //     .attr('y', 8)
                //     .text("" + d.value);
            });
    },

    _draw_headers: function() {
        // add the header
        this.chart.selectAll('text.header')
            .data(this.headers)
            .enter()
            .append('text')
            .attr('x', (function(fig) {
                return function(d, i) {
                    return (fig.node_width + fig.lane_width) * i;
                }
            })(this))
            .attr('y', -5)
            .attr('font-size', 10)
            .attr("font-family", "Helvetica")
            .attr('font-weight', 'bold')
            .text(function(d) {
                return d;
            });
    }
}

} // end of make_fig

};

// The Vue App
var app_hotpot = {
    // metro app toast
    metro_toast: Metro.toast.create,

    // for tracking how many anns
    n_anns: 0,

    // the magic number for MedTator World Peace
    // (no need to force update)
    cnt_no_more_anns: 0,

    // the threshold of number of anns for a small project
    n_anns_small_project: 100,

    // for tour
    tour: {
        annotation: null,
    },

    // waiting for closing 
    seconds_before_closing_loading_anns_panel: 3,

    // for key event
    has_pressed_ctrl_meta: false,

    // vue app
    vpp: null,
    vpp_id: '#app_hotpot',

    vpp_data: {
        // system version
        // this will be overwritten in index.html
        version: '',

        // for the section control
        section: 'annotation',

        // for the dtd
        dtd: null,

        // decide which ann file is working on.
        // null indicates that currently it is not editing
        ann_idx: null,

        // for the ann files in the file list
        anns: [],
        mn4anns: 0.1,

        // pagination
        pg_index: 0,
        pg_total: 1,
        pg_numpp: 100,

        // for loading many anns
        is_loading_anns: false,
        is_loaded_anns: false,
        msg_loading_anns: '',
        n_anns_droped: 0,
        n_anns_loaded: 0,
        n_anns_error: 0,

        // sort anns
        // - default: how the anns are imported into tool
        // - alphabet: A-Z
        // - alphabet_r: Z-A
        // - tags: 0-N
        // - tags_r: N-0
        // - label: color
        sort_anns_by: 'default',

        // for annotation tab working mode
        // there will be the following mode:
        // 1. annotation, which is the usually mode, and it is default
        // 2. adjudication, which is for adjudication from adj.tab
        // the UI logic will be different in each mode
        annotation_tab_working_mode: 'annotation',

        // for showing the tag by tag_name,
        display_tag_name: '__all__',

        // statistics
        display_stat_doc_sum_selected: null,
        stat_filter_min_tokens: 0,
        stat_filter_token_text: true,

        // for the hints of current ann
        hints: [],

        // for all hints of all anns
        hint_dict: {},

        // for popmenu
        clicked_tag_id: null,

        // hover
        hovered_tag: null,

        // a flag for showing which mode we are working
        is_linking: false,
        linking_tag_def: null,
        linking_tag: null,
        linking_atts: [],
        
        // linking
        pan_working_tag: {
            pos: {
                clientX: undefined,
                clientY: undefined,
                movementX: 0,
                movementY: 0
            }
        },

        // for converting the txt to xmls
        txt_anns: [],
        txt_xmls: [],
        txt_xml_prefix: '',
        txt_xml_suffix: '',

        // for file name filter
        fn_pattern: '',

        // for updating the sub module
        force_module_update: Math.random(), 

        // for IAA
        // see app_hotpot_ext_iaa.js

        // cm settings
        cm: {
            // document / sentences
            display_mode: 'document',

            // node / span
            mark_mode: 'node',

            // simple / smart
            hint_mode: 'simple',

            // update the hint when delete
            // but I found this is not doable.
            // the deleted tag may be used in different place,
            // so simplely deleting the token from hint dict 
            // may cause issue.
            enabled_auto_hint_update: true,

            // display the hints or not
            enabled_hints: true,

            // display the links
            enabled_links: true,

            // display the link name
            enabled_link_name: true,

            // display complex link
            enabled_link_complex: true,

            // for updating the codemirror instance
            is_expire: false
        },

        // general cfg
        // this has been move to the extension
        // app_hotpot_ext_settings.js
        cfg: {},

        // for export
        export_text: '',

        // for texts
        // this variable would be replaced by the 
        // app_hotpot_ext_texts.js module
        texts: {}
    },

    vpp_methods: {

        show_quick_help: function() {

        },

        /////////////////////////////////////////////////////////////////
        // Settings related functions
        /////////////////////////////////////////////////////////////////
        // moved to app_hotpot_ext_settings.js

        /////////////////////////////////////////////////////////////////
        // Loading files related functions
        /////////////////////////////////////////////////////////////////
        on_dragover_prevent_default: function(event) {
            event.preventDefault();
        },

        on_click_open_dtd_file: function() {
            // the settings for dtd file
            var pickerOpts = {
                types: [
                    {
                        description: 'Annotation Schema File',
                        accept: {
                            'text/dtd': ['.dtd', '.json', '.yaml']
                        }
                    },
                ],
                excludeAcceptAllOption: true,
                multiple: false
            };

            // get the file handles
            var promise_fileHandles = fs_open_files(pickerOpts);

            promise_fileHandles.then(function(fileHandles) {
                // read the fh and set dtd
                // in fact, there is only one file for this dtd
                for (let i = 0; i < fileHandles.length; i++) {
                    const fh = fileHandles[i];

                    // read the file
                    var p_dtd = fs_read_dtd_file_handle(fh);

                    p_dtd.then((function(){
                        return function(dtd) {
                            if (dtd == null) {
                                // must be something wrong
                                app_hotpot.msg(
                                    'Something wrong with the selected file, please check the schema format.', 
                                    'warning'
                                );
                                return;
                            }
                            // just set the dtd
                            app_hotpot.set_dtd(dtd);
                        }
                    })());
                    
                    // just one file
                    break;
                }
            });
            
        },

        on_drop_dropzone_dtd: function(event) {
            // prevent the default download event
            event.preventDefault();

            if (!isFSA_API_OK) {
                app_hotpot.msg('Please use modern web browser for reading local file', 'warning');
                return;
            }

            let items = event.dataTransfer.items;

            // user should only upload one folder or a file
            if (items.length>1) {
                console.log('* selected more than 1 item!');
                app_hotpot.msg('Please just drop only one schema file', 'warning');
                return;
            }

            let item = items[0].getAsFileSystemHandle();
            console.log('* using FSA API to load item as dtd');
            
            // read this handle
            item.then(function(fh) {
                if (fh.kind != 'file') { return null; }

                // get the dtd object
                var p_dtd = fs_read_dtd_file_handle(fh);

                // handle the response
                // we just create a function agent
                // for support other parameters in future if possible
                p_dtd.then((function(){
                    return function(dtd) {
                        if (dtd == null) {
                            // must be something wrong
                            app_hotpot.msg(
                                'Something wrong with the dropped file, please check the schema format.', 
                                'warning'
                            );
                            return;
                        }
                        // just set the dtd
                        app_hotpot.set_dtd(dtd);
                    }
                })());
            });
        },

        on_click_open_ann_files: function() {
            if (this.dtd == null) {
                app_hotpot.msg(
                    "Please load the annotation schema first.",
                    "warning"
                );
                return;
            }
            var pickerOpts = {
                types: [
                    {
                        description: 'Annotation Files',
                        accept: {
                            'text/dtd': ['.xml', '.txt']
                        }
                    },
                ],
                excludeAcceptAllOption: true,
                multiple: true
            };

            var p_fhs = fs_open_files(pickerOpts);

            p_fhs.then(function(fhs) {
                var p_files = fs_get_file_texts_by_fhs(
                    fhs,
                    function(fn) {
                        if (app_hotpot.is_file_ext_txt(fn)) {
                            return true;
                        }
                        if (app_hotpot.is_file_ext_xml(fn)) {
                            return true;
                        }
                        return false;
                    }
                )
                p_files.then(function(files) {
                    app_hotpot.vpp.add_files_to_anns(files);

                    // fix the missing?
                    // app_hotpot.vpp.refresh_v_anns();
                });
            });
        },

        on_drop_filelist: function(event) {
            // prevent the default download event
            event.preventDefault();

            const items = event.dataTransfer.items;
            console.log('* dropped ' + items.length + ' items but maybe not all are acceptable.');

            if (items.length == 0) {
                // ???
                return;

            } else if (items.length == 1) {
                // hmmm ... it's interesting ...
                // this can be the schema or workspace?
                // let item = items[0].getAsFileSystemHandle();
                // console.log('* drop one item', item);

            } else if (items.length > 1) {
                // which means it is usually the annotation files
                if (this.dtd == null) {
                    app_hotpot.msg(
                        "Please load the annotation schema first.",
                        "warning"
                    );
                    return;
                }
            }

            // first, set to loading status and init the values
            this.reset_loading_anns_status();
            this.is_loading_anns = true;
            this.msg_loading_anns = 'Reading files ...';

            var promise_files = fs_get_file_texts_by_items(
                items,
                function(fn) {
                    if (app_hotpot.is_file_ext_txt(fn)) {
                        // which means it is raw text file
                        return true;
                    }
                    if (app_hotpot.is_file_ext_xml(fn)) {
                        // which means it is annotation file
                        return true;
                    }
                    if (app_hotpot.is_file_ext_json(fn)) {
                        // which means it can a json workspace or schema
                        return true;
                    }
                    if (app_hotpot.is_file_ext_dtd(fn)) {
                        // which means it can a schema
                        return true;
                    }
                    if (app_hotpot.is_file_ext_yaml(fn)) {
                        // which means it can a schema
                        return true;
                    }
                    return false;
                }
            );
            promise_files.then(function(files) {
                if (files.length == 1 && app_hotpot.is_file_ext_json(files[0].fn)) {
                    // ok, this file[0] can be a schema or workspace
                    var j = JSON.parse(files[0].text);
                    if (app_hotpot.is_vpp_data_json(j)) {
                        // which means it is a vpp_data!
                        // just load it
                        app_hotpot.set_vpp_data_json(j);
                        // app_hotpot.toast('Successfully loaded workspace!');
                        console.log('* loaded workspace!');

                    } else {
                        app_hotpot.msg(
                            "The given JSON file is not a valid schema or workspace file. Please check the file format and try later.",
                            "warning"
                        );
                        console.log('* skipped the unknown json file', j);
                    }
                    app_hotpot.vpp.reset_loading_anns_status();

                } else if (files.length == 1 && (
                    app_hotpot.is_file_ext_yaml(files[0].fn) || 
                    app_hotpot.is_file_ext_dtd(files[0].fn) )) {

                    // this means it's a schema file!
                    var format = app_hotpot.get_file_ext(files[0].fn);
                    var dtd = dtd_parser.parse(files[0].text, format);
                    if (dtd == null) {
                        // must be something wrong
                        app_hotpot.msg(
                            'Something wrong with the given schema file, please check the schema format and try again later.', 
                            'warning'
                        );
                        return;
                    }
                    // just set the dtd
                    app_hotpot.set_dtd(dtd);
                    app_hotpot.vpp.reset_loading_anns_status();

                } else {
                    app_hotpot.vpp.add_files_to_anns(files);
                }
            });
        },

        add_files_to_anns: function(files) {
            if (this.dtd == null) {
                app_hotpot.msg(
                    "Please load the annotation schema first.",
                    "warning"
                );
                return;
            }
            // now we know how many files are droped
            this.n_anns_droped = files.length;

            // let's parse all files
            var anns = [];
            this.msg_loading_anns = 'Parsing files ...'
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                var ann = app_hotpot.parse_file2ann(
                    file,
                    this.dtd
                );
                
                // it is possible that something wrong
                if (ann == null) {
                    this.n_anns_error += 1;
                }

                // ok, let's save this ann
                anns[anns.length] = ann;
                this.n_anns_loaded += 1;
            }

            // update the status
            this.msg_loading_anns = 'Updating file list ...'

            // last step! add to
            this.add_anns(anns);
            this.msg_loading_anns = 'Loaded all annotation files!'

            this.is_loaded_anns = true;
            console.log('* has added ' + anns.length + ' annotation files');

            if (anns.length > this.pg_numpp) {
                setTimeout(
                    'app_hotpot.vpp.reset_loading_anns_status()', 
                    app_hotpot.seconds_before_closing_loading_anns_panel * 1000
                );
            } else {
                this.reset_loading_anns_status();
            }
        },

        add_ann: function(ann) {
            // this.anns.push(ann);
            this.anns[this.anns.length] = ann;
            // update the hint_dict by this ann
            ann_parser.add_ann_to_hint_dict(
                ann,
                this.hint_dict
            );
        },

        add_ann_by_push: function(ann) {
            this.anns.push(ann);
            // update the hint_dict by this ann
            ann_parser.add_ann_to_hint_dict(
                ann,
                this.hint_dict
            );
        },

        add_anns: function(anns) {
            /**
             * 2022-07-13: performance issue when large dataset
             * 
             * When there are just a few files (<500),
             * .push() can handle smoothly and the file count
             * can be updataed instantly without intervention.
             * But when the number of files increase,
             * the loading will take extremely long time.
             * 
             * After debugging, there are mainly three reasons:
             * 
             * 1. `anns.push(ann)` takes very long time.
             * it seems the .push() method runs much slower while size increases.
             * the only way I know is to change to `anns[anns.length] = ann`
             * 
             * 2. `$forceUpdate()` or automatic refresh.
             * When the data in Vue app is changed, 
             * the binded UI will also be redrawn.
             * But as the number of files increase, 
             * the relevent calculation needs more time, 
             * and most of the calcuation is redundant.
             * 
             * 3. `update_hint_dict_by_anns()` batch update.
             * To get the statistics on the anns,
             * this function is called whenever anns changes.
             * But in fact, it's not necessary at all (I think).
             * If the user doesn't want to use hint,
             * or only a few things are updated,
             * it's not necessary to update the whole dictionary from all anns.
             * 
             * To address these issues ...
             * 
             * Pagination!
             */
            for (let i = 0; i < anns.length; i++) {
                this.add_ann(anns[i]);
            }

            // ok, now update v_ann
            this.refresh_v_anns();
        },
        
        refresh_v_anns: function() {
            // just for trigger the vue's computed prop
            this.mn4anns = Math.random();
        },

        reset_loading_anns_status: function() {
            this.is_loading_anns = false;
            this.is_loaded_anns = false;
            this.msg_loading_anns = '';
            this.n_anns_droped = 0;
            this.n_anns_loaded = 0;
            this.n_anns_error = 0;
        },

        goto_anns_page: function(new_pg_index) {
            this.pg_index = new_pg_index;
        },

        reset_anns_page: function() {
            this.pg_index = 0;
        },

        save_xml_by_ann: function(ann) {
            var idx = this.find_included(
                ann._filename,
                this.anns
            );
            if (idx < 0) {
                // what????
                return
            } else {
                // ok, we find it
            }

            this.save_xml_by_idx(idx);
        },

        save_xml_by_idx: function(idx) {
            // switch to this ann first
            if (this.ann_idx != idx) {
                this.ann_idx = idx;
            }
            // $this.$forceUpdate();
            this.save_xml();
        },

        save_xml: function() {
            // before checking, need to ensure the FSA API
            if (this.has_FSA_API()) {
                // OK, go go go
            } else {
                // well ... it's ok ...
                app_hotpot.msg(
                    'The browser you are using does not support File System Access API. You can use "Download XML" function instead.', 
                    'warning'
                );
                return;
            }
            // before saving, need to check the _fh
            var p_ann = null;
            if (this.ann_idx == null) {
                app_hotpot.msg(
                    'Please open an annotation file for saving.',
                    'warning'
                );
                return;
            }
            if (!this.anns[this.ann_idx].hasOwnProperty('_fh') || 
                this.anns[this.ann_idx]._fh === null ||
                typeof(this.anns[this.ann_idx]._fh.createWritable)==='undefined') {
                // which means this ann's original file is not available
                // or it is a txt-converted ann
                // let's go to save as directly
                p_ann = fs_save_new_ann_file(
                    this.anns[this.ann_idx],
                    this.dtd
                );
                
            } else {
                // normal save
                var p_ann = fs_save_ann_file(
                    this.anns[this.ann_idx],
                    this.dtd
                );
            }
            p_ann.then(function(ann) {
                // usually it should be OK ...
                // but it may change ...
                // using the given ann to replace the current ann
                app_hotpot.vpp.set_current_ann(ann);
                app_hotpot.vpp.refresh_v_anns();
                app_hotpot.toast('Successfully saved ' + ann._filename);
            })
            .catch(function(error) {
                console.log(error);
                if (error.name == 'AbortError') {
                    app_hotpot.toast('Cancelled file saving.');
                    return;
                }
                if (error.name == 'NotAllowedError') {
                    // which means user or system cancelled this saving
                    app_hotpot.toast('Cancelled file saving.');
                    return;
                }
                app_hotpot.msg(
                    'Saving xml failed. Try to use "Save As" instead.', 
                    'bg-lightCrimson fg-white'
                );
                console.log('* error when save xml', error);
            });;
        },
        
        /////////////////////////////////////////////////////////////////
        // "Label" related functions
        /////////////////////////////////////////////////////////////////
        has_any_label: function(ann) {
            if (ann.hasOwnProperty('meta') &&
                ann.meta.hasOwnProperty('label') &&
                ann.meta.label.length > 0) {
                return true;
            }

            return false;
        },

        set_label: function(color, ann) {
            if (typeof(color)=='undefined') {
                color = 'green';
            }

            if (typeof(ann)=='undefined') {
                // just a reference
                ann = this.anns[this.ann_idx];
            }

            // if this is not label, the `label` may be available
            if (!this.has_any_label(ann)) {
                ann.meta['label'] = [];
            }

            // just set the label
            ann.meta['label'] = [{
                'color': color
            }];

            // mark this file is changed and needs to be saved
            ann._has_saved = false;
            this.set_ann_unsaved(ann);

            // update the UI
            this.$forceUpdate();
        },

        remove_labels: function(ann) {
            if (typeof(ann)=='undefined') {
                // just a reference
                ann = this.anns[this.ann_idx];
            }

            ann.meta['label'] = [];

            // mark this file is changed and needs to be saved
            ann._has_saved = false;
            this.set_ann_unsaved(ann);

            // update the UI
            this.$forceUpdate();
        },
        
        /////////////////////////////////////////////////////////////////
        // "Save as" related functions
        /////////////////////////////////////////////////////////////////
        save_as_xml: function() {
            // convert to xml
            var xmlDoc = ann_parser.ann2xml(
                this.anns[this.ann_idx],
                this.dtd
            );

            // convert to text
            var xmlStr = ann_parser.xml2str(xmlDoc, false);

            // get the current file name
            var fn = this.anns[this.ann_idx]._filename;

            // create a new name for suggestion
            var new_fn = 'copy_of_' + fn;

            // ask for new fh for this file
            var p_fh = fs_get_new_ann_file_handle(new_fn);

            // when new fh is ready, save it
            p_fh.then((function(xmlStr){
                return function(fh) {
                    // first, update the fh
                    
                    // save this xmlStr with the given fh
                    let p_done = fs_write_file_system_handle(
                        fh,
                        xmlStr
                    );

                    // show something when saved
                    p_done.then(function(fh) {
                        app_hotpot.toast('Successfully saved as ' + fh.name);
                    });
                }
            })(xmlStr))
            .catch(function(error) {
                console.log('* error when save as xml', error);
            });
        },

        download_schema_as_dtd: function() {
            // if (this.dtd.hasOwnProperty('text')) {
            //     // get the current file name
            //     var fn = this.dtd.name + '.dtd';

            //     // download this dtd text
            //     var blob = new Blob([this.dtd.text], {type: "text/txt;charset=utf-8"});
            //     saveAs(blob, fn);
            // } else {
            //     // what???
            //     return;
            // }
            
            // first, convert the base_dtd to text
            var text = dtd_parser.stringify_yaml(
                this.dtd
            );

            // then save it
            // get the current file name
            var fn = this.dtd.name + '.yaml';

            // download this dtd text
            var blob = new Blob(
                [text], 
                {type: "text/txt;charset=utf-8"}
            );
            saveAs(blob, fn);
        },
        
        download_copy_as_xml: function() {
            // convert to xml
            var xmlDoc = ann_parser.ann2xml(
                this.anns[this.ann_idx],
                this.dtd
            );

            // convert to text
            var xmlStr = ann_parser.xml2str(xmlDoc, false);

            // get the current file name
            var fn = this.anns[this.ann_idx]._filename;

            // download this csv
            var blob = new Blob([xmlStr], {type: "text/xml;charset=utf-8"});
            saveAs(blob, fn);
        },

        download_copy_as_bioc: function() {
            // create a new file name for this format
            var fn = 'BioC-' + this.anns[this.ann_idx]._filename;
            bioc_parser.download_dataset_bioc(
                [this.anns[this.ann_idx]],
                this.dtd,
                fn
            );
        },

        download_all_as_zip: function(skip_dtd) {
            if (typeof(skip_dtd) == 'undefined') {
                skip_dtd = true;
            }
            var fn = 'annotation-' + 
                this.dtd.name + 
                '-' +
                this.get_datetime_now() +
                '.zip';
            console.log('* download all as zip ' + fn);

            var file_list = nlp_toolkit.download_dataset_raw(
                this.anns,
                this.dtd,
                fn,
                skip_dtd
            );
            
            console.log('* downloaded zip file:', file_list);
            // update the UI?
        },

        /////////////////////////////////////////////////////////////////
        // Search related functions
        /////////////////////////////////////////////////////////////////

        show_search_bar: function() {
            app_hotpot.codemirror.execCommand('find');
        },

        clear_search_result: function() {
            app_hotpot.codemirror.execCommand('clearSearch');
        },

        clear_filter_box: function() {
            this.fn_pattern = '';
        },

        /////////////////////////////////////////////////////////////////
        // Help related functions
        /////////////////////////////////////////////////////////////////

        show_wiki: function() {
            // app_hotpot.start_tour_annotation();
            window.open(
                'https://github.com/OHNLP/MedTator/wiki',
                '_blank'
            );
        },

        show_best_practice: function() {
            window.open(
                'https://github.com/OHNLP/MedTator/wiki/Annotation-Best-Practices',
                '_blank'
            );
        },

        report_an_issue: function() {
            window.open(
                'https://github.com/OHNLP/MedTator/issues',
                '_blank'
            );
        },

        show_changelog: function() {
            var html = [];
            // parse the latest change log
            var lines = jarvis.changelog_latest.split('\n');
            for (let i = 0; i < lines.length; i++) {
                var line = lines[i];
                line = line.trim();
                if (line == '') {
                    // nothing to do with empty line
                    continue;
                }
                if (html.length == 0) {
                    // this is the first line, the title
                    html.push(
                        '<h3 class="changelog-h3">' + 
                        '<b>MedTator</b> v' + 
                        line + 
                        '</h3>'
                    );
                } else {
                    html.push(
                        '<p class="changelog-p">'+line+'</p>'
                    );
                }
            }
            // last line is the link
            html.push(
                '<p>For more details, check <a target="_blank" href="https://github.com/OHNLP/MedTator#change-log">the README on our GitHub repo</a>.</p>'
            );
            html = html.join('');
            Metro.infobox.create(html);
        },

        show_howtouse: function() {
            window.open(
                'https://github.com/OHNLP/MedTator/wiki/Manual#how-to-use-the-exported-data',
                '_blank'
            );
        },

        show_sample_schema_files: function() {
            window.open(
                'https://github.com/OHNLP/MedTator/tree/main/sample',
                '_blank'
            );
        },

        load_sample_ds: function(ds_name) {
            if (typeof(ds_name) == 'undefined') {
                ds_name = 'MINIMAL_TASK';
            }
            // for local version, load JSON data through binding
            if (jarvis.hasOwnProperty('sample_dict')) {
                var sample_data = jarvis.sample_dict[ds_name];

                // copy the sample to overwrite app_hotpot
                Object.assign(app_hotpot.vpp.$data, sample_data);
                app_hotpot.set_dtd(
                    app_hotpot.vpp.$data.dtd
                );
                app_hotpot.vpp.set_ann_idx(0);

                return;
            }

            // for web version, load JSON data through AJAX
            // $.get(
            //     './static/data/vpp_data_'+ds_name+'.json', 
            //     {
            //         rnd: Math.random()
            //     }, 
            //     function(data) {
            //         Object.assign(app_hotpot.vpp.$data, data);
            //         app_hotpot.set_dtd(
            //             app_hotpot.vpp.$data.dtd
            //         );
            //         app_hotpot.vpp.set_ann_idx(0);
            //     }, 
            //     'json'
            // );

            $.ajax({
                url: './static/data/vpp_data_'+ds_name+'.json', 
                dataType: 'json',
                success: function(data) {
                    Object.assign(app_hotpot.vpp.$data, data);
                    app_hotpot.set_dtd(
                        app_hotpot.vpp.$data.dtd
                    );
                    app_hotpot.vpp.set_ann_idx(0);
                }, 
                error: function (xhr, status, error) {
                    // console.error(error);

                    app_hotpot.toast(
                        'Something wrong when loading the sample dataset, check the data availability and try later?',
                        'alert'
                    );
                }
            });
        },

        load_sample_ds_remote: function(ds_name) {
            if (typeof(ds_name) == 'undefined') {
                ds_name = 'MINIMAL_TASK';
            }
            // always try to load github repo
            $.ajax({
                // https://ohnlp.github.io/MedTator/static/data/vpp_data_MINIMAL_TASK.json?rnd=0.26234995297601804
                // url: './static/data/vpp_data_'+ds_name+'.json', 
                url: 'https://ohnlp.github.io/MedTator/static/data/vpp_data_'+ds_name+'.json', 
                dataType: "json",
                success: function(data, status, xhr) {
                    // parse the data and load it
                    Object.assign(app_hotpot.vpp.$data, data);
                    app_hotpot.set_dtd(
                        app_hotpot.vpp.$data.dtd
                    );
                    app_hotpot.vpp.set_ann_idx(0);

                    // toast?
                    app_hotpot.toast(
                        'Loaded Sample Dataset',
                        'info'
                    );
                },
                error: function (xhr, status, error) {
                    console.error(error);

                    app_hotpot.toast(
                        'Something wrong when loading the sample dataset, try later?',
                        'warning'
                    );
                }
            })
        },

        load_sample_txt: function() {
            if (this.dtd == null) {
                app_hotpot.toast(
                    'Please load annotation schema first',
                    'warning'
                );
                return;
            }
            var ann = this.add_sample_txt_as_ann(
                jarvis.sample_text['covid_vax']
            );

            app_hotpot.toast(
                'Loaded a sample text [' + 
                ann._filename +
                '] for test'
            );
        },

        load_sample_txt_from_input: function() {
            if (this.dtd == null) {
                app_hotpot.toast(
                    'Please load annotation schema first',
                    'warning'
                );
                return;
            }
            var txt = window.prompt(
                'Please input text in the following input box.'
            );
        
            if (txt == null) {
                app_hotpot.toast(
                    'Cancelled creating sample text.'
                );
                return;
            }
            
            // just in case empty
            txt = txt.trim();
            if (txt.length == 0) {
                app_hotpot.toast(
                    'Failed to create a sample text from empty input.'
                );
                return;
            }

            var ann = this.add_sample_txt_as_ann(
                txt
            );

            app_hotpot.toast(
                'Loaded a sample text [' + 
                ann._filename +
                '] for test'
            );
        },

        add_sample_txt_as_ann: function(text) {

            // first, create an ann
            var ann = ann_parser.txt2ann(text, this.dtd);

            // bind the filename seperately
            ann._filename = 'sample-'+
                (Math.random() + 1).toString(36).substring(7)+
                '.xml';

            // add this ann
            this.add_ann_by_push(ann);
            
            return ann;
        },
        

        /////////////////////////////////////////////////////////////////
        // Concept List related functions
        /////////////////////////////////////////////////////////////////
        
        update_tag_table: function(tag) {
            // update the display tag
            if (typeof(tag) == 'undefined') {
                // set to all 
                this.display_tag_name = '__all__';

            } else {
                // set to specific tag
                this.display_tag_name = tag.name;
            }

            // need to re-render the code-mirror accordingly
            if (this.is_render_tags_of_all_concepts()) {
                // no need to update marks if render all by default
            } else {
                app_hotpot.cm_update_marks();
            }
        },

        /////////////////////////////////////////////////////////////////
        // File list related functions
        /////////////////////////////////////////////////////////////////

        sort_filelist_by: function(sort_by) {
            this.sort_anns_by = sort_by;
        },

        get_sort_by: function() {
            if (this.hasOwnProperty('sort_anns_by')) {
                return this.sort_anns_by;
            } else {
                return 'default';
            }
        },

        get_sort_by_label: function(sort_by) {
            return {
                'default': 'Sort',
                'label': 'Gr-NA',
                'label_r': 'NA-Gr',
                'alphabet': 'A-Z',
                'alphabet_r': 'Z-A',
                'tags': '0-N',
                'tags_r': 'N-0'
            }[sort_by];
        },

        get_sorted_v_anns: function() {
            var sort_by = this.get_sort_by();
            var current_ann_idx = this.ann_idx;

            const start = performance.now();

            // a virtual list of ann, just contain the file name
            // this is prepared for sorting only
            // because the sort is an in-place sort
            // we can't modify the order in the original anns
            var v_anns = [];
            for (let i = 0; i < this.anns.length; i++) {
                var ann = this.anns.at(i);

                // add filter logic here
                if (!this.is_match_filename(ann._filename)) {
                    continue;
                }

                // add style logic here
                var css_class = '';
                if (i == current_ann_idx) {
                    css_class = 'file-selected';
                }

                var ann_label = 'zunisha';
                if (this.has_any_label(ann)) {
                    ann_label = ann.meta.label[0].color;
                }
                v_anns[v_anns.length] = {
                    // file name
                    _filename: ann._filename,

                    // number of annotated tags
                    n_tags: ann.tags.length,

                    // label color
                    label: ann_label,

                    // the true idx
                    idx: i,

                    // special style
                    css_class: css_class
                };
            }

            if (sort_by == 'default') {
                // OK, just default anns

            } else if (sort_by == 'alphabet') {
                v_anns.sort(function(a, b) {
                    return a._filename.localeCompare(
                        b._filename
                    )
                });

            } else if (sort_by == 'alphabet_r') {
                v_anns.sort(function(a, b) {
                    return -a._filename.localeCompare(
                        b._filename
                    )
                });
                
            } else if (sort_by == 'tags') {
                v_anns.sort(function(a, b) {
                    return a.n_tags - b.n_tags
                });

            } else if (sort_by == 'tags_r') {
                v_anns.sort(function(a, b) {
                    return b.n_tags - a.n_tags
                });
                
            } else if (sort_by == 'label') {
                // blue
                // green
                // red
                // yellow
                // zunisha
                v_anns.sort(function(a, b) {
                    return a.label.localeCompare(
                        b.label
                    )
                });

            } else if (sort_by == 'label_r') {
                v_anns.sort(function(a, b) {
                    return b.label.localeCompare(
                        a.label
                    )
                });

            } else {
                // ???
            }

            const duration = performance.now() - start;
            console.log('* sorted v_anns in ' +  duration);
            return v_anns;
        },

        set_current_ann: function(ann) {
            // replace the ann object
            this.anns[this.ann_idx] = ann;

            // reset the marks and others
            this.set_ann_idx(this.ann_idx);
        },

        set_ann_idx: function(idx) {
            console.log('* set ann_idx', idx);

            // update the ann_idx
            this.ann_idx = idx;

            if (idx == null) {
                // which means remove the content
                app_hotpot.cm_set_ann(null);

                // update the marks
                app_hotpot.cm_update_marks();

            } else {
                // update the text display
                app_hotpot.cm_set_ann(
                    this.anns[this.ann_idx]
                );

                // update the marks
                app_hotpot.cm_update_marks();
            }
        },

        set_ann_idx_to_next: function() {
            if (this.anns.length > 0 && 
                this.ann_idx < this.anns.length - 1) {
                this.set_ann_idx(this.ann_idx + 1);
            }
        },

        set_ann_idx_to_prev: function() {
            if (this.anns.length > 0 && 
                this.ann_idx > 0) {
                this.set_ann_idx(this.ann_idx - 1);
            }
        },

        set_ann_idx_by_ann: function(v_ann) {
            // find the idx
            var idx = this.find_included(
                v_ann._filename,
                this.anns
            );

            if (idx < 0) {
                // what?? how could it be?
                return;
            } else {
                // ok, we get it
            }

            // finally, just call the set_ann_idx
            this.set_ann_idx(idx);
        },

        show_ann_file: function(fn) {
            // first, find the ann_idx
            var idx = this.find_included(fn, this.anns);

            if (idx < 0) {
                // no such file
                app_hotpot.toast('Not found ' + fn + ' file', 'bg-yellow');
                return;
            }

            // then switch to annotation to ensure the UI logic
            this.switch_mui('annotation');

            // then show the idx
            this.set_ann_idx(idx);

            // trick for cm late update
            this.cm.is_expire = true;
        },

        remove_ann_file_by_ann: function(ann) {
            var idx = this.find_included(
                ann._filename,
                this.anns
            );
            
            // delete this first
            this.anns.splice(idx, 1);

            // once the file is removed, update the hint_dict
            // app_hotpot.update_hint_dict_by_anns();

            if (idx == this.ann_idx) {
                this.set_ann_idx(null);
            }

            // need to move the current ann_idx location
            if (idx < this.ann_idx) {
                this.ann_idx -= 1;
            }
        },

        remove_all_ann_files: function(force_remove) {
            if (typeof(force_remove) == 'undefined') {
                force_remove = false;
            }
            if (force_remove) {
                // just remove
                this.set_ann_idx(null);
                this.anns = [];

            } else {
                // ask for user confirm
                var ret = window.confirm('Are you sure to remove all annotation files?');
                if (ret) {
                    this.set_ann_idx(null);
                    this.anns = [];
                }
            }
            // also remove the loading if any
            this.reset_loading_anns_status();
            // also reset page number
            this.reset_anns_page();
        },


        /////////////////////////////////////////////////////////////////
        // Tag list related functions
        /////////////////////////////////////////////////////////////////

        on_click_tag_table_row: function(tag) {
            if (!this.is_etag(tag)) {
                // no need to highlight other tag
                return;
            }

            if (this.is_etag_doc_level(tag)) {
                // no need to highlight doc-level tag
                return;
            }

            // in the editor
            // 1. jump to this tag for display
            app_hotpot.cm_jump2tag(
                tag, 
                this.anns[this.ann_idx]
            );
            // 2. highlight the tag in editor
            app_hotpot.cm_highlight_editor_tag(tag.id);

            // 3. in the tag table, highlight the row
            app_hotpot.highlight_tag_table_row(tag.id);
        },

        on_change_attr_value: function(event) {
            // just mark current ann as unsaved
            // this.anns[this.ann_idx]._has_saved = false;
            this.set_current_ann_unsaved();
            console.log('* changed attr in', event.target);
        },

        on_change_idref_value: function(event) {
            // this.anns[this.ann_idx]._has_saved = false;
            // need to notify v_ann update
            this.set_current_ann_unsaved();
            // then, need to update this value
            this.on_change_link_settings(event);
        },

        on_input_attr_value: function(event) {
            // just mark current ann as unsaved
            // this.anns[this.ann_idx]._has_saved = false;
            this.set_current_ann_unsaved();
            console.log('* changed input attr to', event.target.value);
        },

        on_change_display_mode: function(event) {
            // console.log();
            // need to set ann again,
            // it will display according to the mode
            app_hotpot.cm_set_ann(
                this.anns[this.ann_idx]
            );
            app_hotpot.cm_update_marks();
            console.log('* changed display mode to ' + event.target.value);
        },

        on_change_mark_mode: function(event) {
            console.log(event.target.value);
            app_hotpot.cm_update_marks();
        },

        // on_change_hint_mode: function(event) {
        //     console.log(event.target.value);
        //     app_hotpot.cm_update_marks();
        // },
        on_change_hint_mode: function(hint_mode) {
            this.cm.hint_mode = hint_mode;
            app_hotpot.cm_update_marks();
        },

        on_change_link_settings: function(event) {
            console.log(event.target.value);
            // app_hotpot.cm_clear_rtag_marks();

            // have to update all marks ...
            app_hotpot.cm_update_marks();
        },

        accept_all_hints: function() {
            if (this.hints.length == 0) {
                app_hotpot.msg('No hints found');
                return;
            }

            var msg = [
                "There are " + this.hints.length + " hints found and not decided yet in current annotation:\n\n"
            ];
            for (let i = 0; i < this.hints.length; i++) {
                msg.push((i+1) + ' | ' + this.hints[i].tag + ', ' + this.hints[i].spans + ' [' + this.hints[i].text + ']\n');
            }
            msg.push('\nAre you sure to accept all of them?');

            msg = msg.join('');

            var ret = window.confirm(msg);

            if (ret) {
                // check all hints
                for (let i = 0; i < this.hints.length; i++) {
                    const hint_id = this.hints[i].id;
                    this.add_tag_by_hint(hint_id, false);
                }
                // update the cm
                app_hotpot.cm_update_marks();
                // scroll the view
                app_hotpot.scroll_annlist_to_bottom();

            } else {
                return;
            }
        },

        get_hint: function(hint_id) {
            for (let i = 0; i < this.hints.length; i++) {
                if (this.hints[i].id == hint_id) {
                    return this.hints[i];
                }
            }
            return null;
        },

        add_tag_by_hint: function(hint_id, update_marks) {
            if (typeof(update_marks)=='undefined') {
                update_marks = true;
            }
            // get the hint from list 
            var hint = this.get_hint(hint_id);
            if (hint == null) { 
                // fix the missing
                app_hotpot.cm_update_marks();
                return; 
            }
            var tag_name = hint.tag;

            // createa new ann tag
            var _tag = {
                'spans': hint.spans,
                'text': hint.text
            }
            var tag_def = this.dtd.tag_dict[tag_name];
            
            // create a new tag
            var tag = app_hotpot.make_etag(
                _tag, 
                tag_def, 
                this.anns[this.ann_idx]
            );

            // add this tag to ann
            this.anns[this.ann_idx].tags.push(tag);

            // mark _has_saved
            // this.anns[this.ann_idx]._has_saved = false;
            this.set_current_ann_unsaved();
            console.log('* added tag by hint, ' + tag_name + ' on ' + hint.text);

            // update the hint_dict
            app_hotpot.update_hint_dict_by_tag(
                this.anns[this.ann_idx],
                tag
            );

            if (update_marks) {
                // update the cm
                app_hotpot.cm_update_marks();
                // scroll the view
                app_hotpot.scroll_annlist_to_bottom();
            }
        },

        add_nc_etag_by_ctxmenu: function(tag_def) {
            this.add_nc_etag(tag_def);

            // for ctxmenu, we need to remove the ctx after click
            app_hotpot.ctxmenu_nce.hide();

            // scroll the view
            app_hotpot.scroll_annlist_to_bottom();

            console.log('* added nc etag by right click, ' + tag_def.name);
        },

        add_etag_by_ctxmenu: function(tag_def) {
            // get the basic tag
            var _tag = app_hotpot.cm_make_basic_etag_from_selection();

            // then call the general add_etag process
            this.add_etag(_tag, tag_def);

            // clear the selection to avoid stick keys
            app_hotpot.cm_clear_selection();

            // for ctxmenu, we need to remove the ctx after click
            app_hotpot.ctxmenu_sel.hide();

            // scroll the view
            app_hotpot.scroll_annlist_to_bottom();

            console.log('* added etag by right click, ' + tag_def.name);
        },

        add_etag_by_shortcut_key: function(key) {
            // first, get selection
            var selection = app_hotpot.cm_get_selection();
            if (selection.sel_txts == '') {
                // nothing selected for tag, skip
                return;
            }

            // then get the tag_def by the given key
            var tag_def = null;
            for (let i = 0; i < this.dtd.etags.length; i++) {
                if (this.dtd.etags[i].shortcut == key) {
                    // found!
                    tag_def = this.dtd.etags[i];
                    break
                }
            }
            if (tag_def == null) {
                // oh, this shortcut is not registered
                return;
            }

            // get a basic tag
            var _tag = app_hotpot.cm_make_basic_etag_from_selection();

            // then call the general add_etag process
            this.add_etag(_tag, tag_def);

            // clear the selection to avoid stick keys
            app_hotpot.cm_clear_selection();

            console.log('* added tag by shortcut, ' + tag_def.name + ' on ' + _tag.text);
        },

        /////////////////////////////////////////////////////////////////
        // Ann and tag related functions
        /////////////////////////////////////////////////////////////////

        set_ann_unsaved: function(ann) {
            // set status
            ann._has_saved = false;
            // notify the virutal anns to be refreshed
            this.refresh_v_anns();

            // it's still under test
            if (this.is_auto_save_ann()) {
                // wow, auto save is enabled?
                this.save_xml();
            }
        },

        set_current_ann_unsaved: function() {
            this.set_ann_unsaved(
                this.anns[this.ann_idx]
            );
        },

        add_etag: function(basic_tag, tag_def) {
            // create a new tag
            var tag = app_hotpot.make_etag(
                basic_tag, 
                tag_def, 
                this.anns[this.ann_idx]
            );

            // add this tag to ann
            this.anns[this.ann_idx].tags.push(tag);

            // mark _has_saved
            // this.anns[this.ann_idx]._has_saved = false;
            this.set_ann_unsaved(
                this.anns[this.ann_idx]
            );

            // add this new tag to hint_dict
            app_hotpot.update_hint_dict_by_tag(this.anns[this.ann_idx], tag);

            // update the cm
            app_hotpot.cm_update_marks();
        },

        add_nc_etag: function(etag_def) {
            var etag = app_hotpot.make_empty_etag_by_tag_def(etag_def);

            // set to nc 
            etag.spans = dtd_parser.NON_CONSUMING_SPANS;

            // create an tag_id
            var tag_id = ann_parser.get_next_tag_id(
                this.anns[this.ann_idx],
                etag_def
            );
            etag.id = tag_id;
            
            // add to list
            this.anns[this.ann_idx].tags.push(etag);

            // mark _has_saved
            // this.anns[this.ann_idx]._has_saved = false;
            this.set_ann_unsaved(
                this.anns[this.ann_idx]
            );

            // ok, that's all?
            app_hotpot.toast('Added a new document-leve tag [' + etag.id + ']');
        },

        add_empty_etag: function(etag_def) {
            var etag = app_hotpot.make_empty_etag_by_tag_def(etag_def);
            // create an tag_id
            var tag_id = ann_parser.get_next_tag_id(
                this.anns[this.ann_idx],
                etag_def
            );
            etag.id = tag_id;
            
            // add to list
            this.anns[this.ann_idx].tags.push(etag);

            // mark _has_saved
            // this.anns[this.ann_idx]._has_saved = false;
            this.set_ann_unsaved(
                this.anns[this.ann_idx]
            );
            // ok, that's all?
            app_hotpot.toast('Added a new entity tag [' + etag.id + ']');
        },

        add_empty_rtag: function(rtag_def) {
            var rtag = app_hotpot.make_empty_rtag_by_tag_def(rtag_def);

            // create an tag_id
            var tag_id = ann_parser.get_next_tag_id(
                this.anns[this.ann_idx],
                rtag_def
            );
            rtag.id = tag_id;

            // add to list
            this.anns[this.ann_idx].tags.push(rtag);

            // mark _has_saved
            // this.anns[this.ann_idx]._has_saved = false;
            this.set_ann_unsaved(
                this.anns[this.ann_idx]
            );

            // ok, that's all?
            app_hotpot.toast('Added a new relation tag [' + rtag.id + ']');
        },

        delete_tag: function(tag_id) {
            // delete the clicked tag id
            app_hotpot.delete_tag(
                tag_id, 
                this.anns[this.ann_idx]
            );
        },

        set_tag_annotator: function(tag_id, annotator, ann) {
            if (typeof(ann) == 'undefined') {
                // just use the current ann
                ann = this.anns[this.ann_idx];
            }
            var tag_idx = -1;
            for (let i = 0; i < ann.tags.length; i++) {
                if (ann.tags[i].id == tag_id) {
                    ann.tags[i]._annotator = annotator;
                    break;
                }            
            }

            // what to do?
            if (tag_idx == -1) {
                // ???
            } else {
                // ???
            }

            // mark this file is changed and needs to be saved
            // ann._has_saved = false;
            this.set_ann_unsaved(
                ann
            );

            console.log('* set annotator to tag: ', 
                tag_id + '._annotator = ' + annotator);

            return ann;
        },

        /////////////////////////////////////////////////////////////////
        // Statistics related functions
        /////////////////////////////////////////////////////////////////
        // see app_hotpot_ext_statistics.js
        

        /////////////////////////////////////////////////////////////////
        // IAA Related
        /////////////////////////////////////////////////////////////////
        // see app_hotpot_ext_iaa.js


        /////////////////////////////////////////////////////////////////
        // Exporter Related
        /////////////////////////////////////////////////////////////////
        // see app_hotpot_ext_exporter.js


        /////////////////////////////////////////////////////////////////
        // Context Menu Related
        /////////////////////////////////////////////////////////////////
        get_nc_etags: function() {
            var nc_etags = [];
            // no dtd yet?
            if (this.dtd == null) { return []; }
            // no file selected yet?
            if (this.ann_idx == null) { return []; }
            for (let i = 0; i < this.dtd.etags.length; i++) {
                const etag = this.dtd.etags[i];
                if (etag.is_non_consuming) {
                    nc_etags.push(etag);
                }
            }
            return nc_etags;
        },

        close_ctxmenu: function() {
            app_hotpot.ctxmenu_sel.hide();
            app_hotpot.ctxmenu_nce.hide();
        },

        close_popmenu: function() {
            app_hotpot.popmenu_tag.hide();
        },

        on_click_editor_tag: function(event, tag_id) {
            // console.log('* clicked on editor etag', tag_id);

            // set the clicked tag_id
            this.clicked_tag_id = tag_id;

            // get the position of user pointer
            // var mouseX = event.clientX;
            // var mouseY = event.clientY;

            // get the position of the tag it self
            var elm = $(event.target);
            var x = elm.offset().left;
            var y = elm.offset().top;

            // then show the popmenu
            app_hotpot.show_tag_popmenu_at(x, y);

            // then show the item in the list
            app_hotpot.scroll_tag_table_to(tag_id);

            // then highlight this item in table
            app_hotpot.highlight_tag_table_row(tag_id);

            // then highlight this item in editor
            app_hotpot.cm_highlight_editor_tag(tag_id);
        },

        on_enter_tag: function(event) {
            // console.log('* enter etag', event.target);
            var elm = $(event.target);
            var tag_id = elm.attr('tag_id');
            this.hovered_tag = this.get_tag_by_tag_id(
                tag_id,
                this.anns[this.ann_idx]
            );

            // set location
            $('#hoverbox_etag').css('top', elm.offset().top + 20);
            $('#hoverbox_etag').css('left', elm.offset().left);
        },

        on_leave_tag: function(event) {
            // console.log('* leave etag', event.target);
            this.hovered_tag = null;
        },

        popmenu_del_tag: function() {
            // delete the clicked tag id
            app_hotpot.delete_tag(
                this.clicked_tag_id, 
                this.anns[this.ann_idx]
            );

            // hide the menu 
            app_hotpot.popmenu_tag.hide();

            // reset the clicked tag id
            this.clicked_tag_id = null;
        },

        popmenu_start_linking: function(rtag_def) {
            // first, set the working mode
            this.is_linking = true;

            // set the linking tag_def
            this.linking_tag_def = rtag_def;

            // create a rtag
            this.linking_tag = app_hotpot.make_empty_rtag_by_tag_def(rtag_def);

            // then get the linking atts for this rtag
            // this list contains all atts for this rtag
            // and during the linking, we will remove those linked att out
            this.linking_atts = this.get_idref_attrs(rtag_def);

            // let's set the first idref attr
            // pop the first att from atts
            var att = this.linking_atts[0];
            this.linking_atts.splice(0, 1)
            this.linking_tag[att.name] = this.clicked_tag_id;
            
            // maybe we could show a float panel
            // for showing the current annotation
            console.log('* start linking', rtag_def.name, 
                'on attr [', att.name,
                '] =', this.clicked_tag_id
            );
        },

        popmenu_set_linking: function(att_idx) {
            // pop the target idx att from atts
            var att = this.linking_atts[att_idx];
            this.linking_atts.splice(att_idx, 1);

            // set current tag to this att
            this.linking_tag[att.name] = this.clicked_tag_id;
            
            console.log('* set linking', this.linking_tag_def.name, 
                'on attr [', att.name,
                '] =', this.clicked_tag_id
            );

            // final check the left?
            if (this.linking_atts.length == 0) {
                // which means we have tagged all idrefs
                // we could append this linking tag to ann
                var tag_id = ann_parser.get_next_tag_id(
                    this.anns[this.ann_idx],
                    this.linking_tag_def
                );
                this.linking_tag.id = tag_id;
                this.anns[this.ann_idx].tags.push(this.linking_tag);

                // mark _has_saved
                // this.anns[this.ann_idx]._has_saved = false;
                this.set_ann_unsaved(
                    this.anns[this.ann_idx]
                );

                // then, we could show this new link in cm
                app_hotpot.cm_draw_rtag(
                    this.linking_tag,
                    this.linking_tag_def,
                    this.anns[this.ann_idx]
                );

                // we could reset linking status
                this.cancel_linking();

            } else {
                // not finished yet?
                // keep working on it
            }
        },

        done_linking: function() {
            // no matter what decision, just done this linking,
            // we could append this linking tag to ann
            var tag_id = ann_parser.get_next_tag_id(
                this.anns[this.ann_idx],
                this.linking_tag_def
            );
            this.linking_tag.id = tag_id;
            this.anns[this.ann_idx].tags.push(this.linking_tag);

            // mark unsaved
            // this.anns[this.ann_idx]._has_saved = false;
            this.set_ann_unsaved(
                this.anns[this.ann_idx]
            );

            // then, we could show this new link in cm
            app_hotpot.cm_draw_rtag(
                this.linking_tag,
                this.linking_tag_def,
                this.anns[this.ann_idx]
            );

            // we could reset linking status
            this.cancel_linking();
        },

        cancel_linking: function() {
            // so, user doesn't want to continue current linking
            this.is_linking = false;
            this.linking_tag_def = null;
            this.linking_tag = null;
            this.linking_atts = [];
        },

        dragMouseDown: function(event) {
            console.log('* drag start', event);
            event.preventDefault()
            // get the mouse cursor position at startup:
            this.pan_working_tag.pos.clientX = event.clientX
            this.pan_working_tag.pos.clientY = event.clientY
            document.onmousemove = this.elementDrag
            document.onmouseup = this.closeDragElement
        },
        elementDrag: function (event) {
            event.preventDefault()
            this.pan_working_tag.pos.movementX = this.pan_working_tag.pos.clientX - event.clientX
            this.pan_working_tag.pos.movementY = this.pan_working_tag.pos.clientY - event.clientY
            this.pan_working_tag.pos.clientX = event.clientX
            this.pan_working_tag.pos.clientY = event.clientY
            // set the element's new position:
            this.$refs.pan_working_tag_box.style.top = (this.$refs.pan_working_tag_box.offsetTop - this.pan_working_tag.pos.movementY) + 'px'
            this.$refs.pan_working_tag_box.style.left = (this.$refs.pan_working_tag_box.offsetLeft - this.pan_working_tag.pos.movementX) + 'px'
        },
        closeDragElement () {
            document.onmouseup = null
            document.onmousemove = null
        },

        /////////////////////////////////////////////////////////////////
        // Other utils
        /////////////////////////////////////////////////////////////////

        switch_mui: function(section) {
            console.log('* switch to section', section);
            this.section = section;

            if (section == 'annotation') {
                // refresh the code mirror
                this.set_ann_idx(this.ann_idx);

                // trick for cm late update
                this.cm.is_expire = true;

                // bind drop zone for dtd
                // app_hotpot.bind_dropzone_dtd();

                // bind drop zone for annotation xml/txt files
                // app_hotpot.bind_dropzone_ann();

            } else if (section == 'iaa') {

                // bind drop zone for anns
                // app_hotpot.bind_dropzone_iaa();

            } else if (section == 'corpus') {
                // need something?

            }

            // no matter what tab, resize the UI
            app_hotpot.resize();

            // maybe need to close the tqv
            this.hide_tqv();
        },

        make_html_bold_tag_name: function(tag) {
            var html = '<span class="tag-list-row-name-id-prefix">' + tag.id_prefix + '</span>';
            var name = tag.name;
            name = name.replace(tag.id_prefix, '');
            html = html += name;
            return html;
        },

        get_smaller_value: function(a, b) {
            return Math.min(a, b);
        },

        get_bigger_value: function(a, b) {
            return Math.max(a, b);
        },

        count_n_tags: function(tag) {
            if (this.ann_idx == null) {
                return '';
            }
            var cnt = 0;
            if (tag == null) {
                return this.anns[this.ann_idx].tags.length;
            }
            for (let i = 0; i < this.anns[this.ann_idx].tags.length; i++) {
                if (this.anns[this.ann_idx].tags[i].tag == tag.name) {
                    cnt += 1;
                }
            }
            return cnt;
        },

        is_current_ann: function(ann) {
            if (this.ann_idx == null) {
                // which means there is no ann displayed now
                return false;
            }
            if (ann._filename == this.anns[this.ann_idx]._filename) {
                return true;
            } else {
                return false;
            }
        },

        is_match_filename: function(fn) {
            if (this.fn_pattern == '') {
                return true;
            }
            if (fn.lastIndexOf(this.fn_pattern) >= 0) {
                return true;
            } else {
                return false;
            }
        },

        find_included: function(fn, anns) {
            for (let i = 0; i < anns.length; i++) {
                if (anns[i]._filename == fn) {
                    return i;
                }
            }

            return -1;
        },

        has_included: function(fn, anns) {
            // return false;
            for (let i = 0; i < anns.length; i++) {
                if (anns[i]._filename == fn) {
                    return true;
                }
            }

            return false;
        },

        has_included_ann_file: function(fn) {
            return this.has_included(fn, this.anns);
        },

        get_new_ann_fn_by_txt_fn: function(txt_fn) {
            // var new_fn = txt_fn + '.xml';
            // var i = 1;
            // while (true) {
            //     if (this.has_included_ann_file(new_fn)) {
            //         new_fn = txt_fn + '_' + i + '.xml';
            //         i += 1;
            //     } else {
            //         break;
            //     }
            // }
            // return new_fn;
            return app_hotpot.get_new_ann_fn_by_txt_fn(txt_fn);
        },

        has_included_txt_ann_file: function(fn) {
            return this.has_included(fn, this.txt_anns);
        },

        has_unsaved_ann_file: function() {
            for (let i = 0; i < this.anns.length; i++) {
                const ann = this.anns[i];
                if (ann._has_saved) {

                } else {
                    return true;
                }
            }
            return false;
        },

        get_tag_spans_text: function(tag) {
            if (tag.spans == '-1~-1') {
                return 'DOCLEVEL';
            } else {
                return tag.spans;
            }
        },

        get_tags_by_tag_name: function(ann, tag_name) {
            var tags = [];
            for (let i = 0; i < ann.tags.length; i++) {
                const tag = ann.tags[i];
                if (tag.tag == tag_name) {
                    tags.push(tag);
                }
            }
            return tags;
        },

        get_tags_by_type: function(ann, dtd) {
            if (typeof(type) == 'undefined') {
                type = 'etag';
            }
            var tags = [];
            for (let i = 0; i < ann.tags.length; i++) {
                const tag = ann.tags[i];
                if (dtd.tag_dict[tag.tag].type==type) {
                    tags.push(tag);
                }
            }
            return tags;
        },

        get_tag_desc_html: function(tag) {
            var html = [];

            for (const attr in tag) {
                if (Object.hasOwnProperty.call(tag, attr)) {
                    const val = tag[attr];
                    if (['id', 'tag', 'spans', 'text', '_annotator'].indexOf(attr)>=0) {
                        continue;
                    }

                    html.push(
                        "<span class='tag-desc-item'>" +
                        "<span class='tag-desc-attr'>" + attr + ": </span>" +
                        "<span class='tag-desc-value'>" + val + "</span>" +
                        "</span>"
                    );
                }
            }

            html = html.join('<br>');

            return html;
        },

        get_clicked_tag: function() {
            if (this.clicked_tag_id == null) {
                return null;
            }
            if (this.ann_idx == null) {
                return null;
            }
            return this.get_tag_by_tag_id(
                this.clicked_tag_id, 
                this.anns[this.ann_idx]
            )
        },

        get_tag_by_tag_id: function(tag_id, ann) {
            if (ann == null) {
                return null;
            }
            for (let i = 0; i < ann.tags.length; i++) {
                if (ann.tags[i].id == tag_id) {
                    return ann.tags[i];
                }                
            }
            return null;
        },

        get_tag_def: function(tag_name) {
            if (this.dtd.tag_dict.hasOwnProperty(tag_name)) {
                return this.dtd.tag_dict[tag_name];
            } else {
                return null;
            }
        },

        get_idref_attr_by_seq: function(rtag_def, seq=0) {
            var cnt = -1;
            for (let i = 0; i < rtag_def.attrs.length; i++) {
                if (rtag_def.attrs[i].vtype == 'idref') {
                    cnt += 1;
                    if (cnt == seq) {
                        // great! we get the attr we want
                        return rtag_def.attrs[i];
                    }
                }
            }
            return null;
        },

        get_idref_attrs: function(rtag_def) {
            var attrs = [];
            for (let i = 0; i < rtag_def.attrs.length; i++) {
                const att = rtag_def.attrs[i];
                if (att.vtype == 'idref') {
                    attrs.push(att);
                }
            }
            return attrs;
        },

        to_fixed: function(v) {
            if (typeof(v) == 'undefined' ||
                v == null || 
                isNaN(v)) {
                return 'NA';
            }
            return v.toFixed(2);
        },

        to_comma: function(v) {
            if (typeof(v) == 'undefined' ||
                v == null || 
                isNaN(v)) {
                return 'NA';
            }
            // format as number
            var _v = parseFloat("" + v);
            return _v.toLocaleString("en-US");
        },

        val2width: function(val, max_val, max_width) {
            if (typeof(val) == 'undefined' ||
                val == null ||
                isNaN(val)) {
                val = 0;
            }
            if (typeof(max_val) == 'undefined' ||
                max_val < 10) {
                max_val = 10;
            }
            if (typeof(max_width) == 'undefined') {
                // which means 100px
                max_width = 100;
            }

            // very simple conversion
            var width = val / max_val * max_width;

            return width;
        },

        per2width: function(v) {
            if (typeof(v) == 'undefined' ||
                v == null ||
                isNaN(v)) {
                return 1;
            }
            return v * 100;
        },

        has_doc_sum_selected_tags: function() {
            if (this.display_stat_doc_sum_selected == null) {
                return false;
            }
            if (this.has_included_ann_file(
                this.display_stat_doc_sum_selected.file_name
            )) {
                return true;
            }
            return false;
        },

        on_click_stat_ann_tag_box: function(event, file_name, tag_name) {
            // get the dom element
            var elm = $(event.target);

            // set the obj for this event
            this.display_stat_doc_sum_selected = {
                file_name: file_name,
                tag_name: tag_name
            };

            console.log('* display_stat_doc_sum_selected:', this.display_stat_doc_sum_selected);

            // show the box
            $('#stat_doc_tag_detailbox').css('top', elm.offset().top - 215);
            $('#stat_doc_tag_detailbox').css('left', elm.offset().left + 25);
        },

        on_close_stat_ann_tag_box: function() {
            this.display_stat_doc_sum_selected = null;
            // I'm not sure why, but there is a 26px bar left???
            // so just move it out of view
            $('#stat_doc_tag_detailbox').css('top', -1000);
        },

        has_FSA_API: function() {
            return isFSA_API_OK;
        },

        show_help: function(token) {
            if (typeof(token) == 'undefined') {
                // ?
                return;
            }

            // find this token
            if (app_hotpot.texts.hasOwnProperty(token)) {
                var html_content = '';

                // add the title
                html_content += 
                    "<h4>" + 
                    app_hotpot.texts[token].title + 
                    "</h4>";
                
                // add the content
                html_content += app_hotpot.texts[token].html;

                // show the html content
                Metro.infobox.create(html_content);

            } else {
                // ???
            }
        },

        is_display_tag_name: function(tag_name) {
            if (this.display_tag_name == '__all__') {
                return true;
            }

            if (this.display_tag_name == tag_name) {
                return true;
            }

            return false;
        },

        /**
         * Show UI for error analysis
         * 
         * The UI workflow could be changed by the setting
         * `cfg.new_ui_for_ea`.
         * 
         * @returns true/false
         */
        is_show_new_ui_for_ea: function() {
            return this.cfg.new_ui_for_ea == 'enable';
        },

        /**
         * Show UI for toolkit
         * 
         * The UI workflow could be changed by the setting
         * `cfg.new_ui_for_tk`.
         * 
         * @returns true/false
         */
        is_show_new_ui_for_tk: function() {
            return this.cfg.new_ui_for_tk == 'enable';
        },

        /**
         * Render all tags of all concepts or not
         * 
         * The UI workflow could be changed by the setting
         * `cfg.linking_marks_selection`.
         * 
         * @returns true/false
         */
        is_render_tags_of_all_concepts: function() {
            return this.cfg.linking_marks_selection == 'all_concepts';
        },

        /**
         * Check if a tag is related to a certain tag type
         * 
         * @param {object} tag a tag object
         * @param {list} tag_name tag names to be checked
         * @param {object} ann annotation
         */
        is_tag_related_to_tag_name: function(tag, tag_names, ann) {
            // find the 
            var related_tags = ann_parser.get_linked_rtags(
                tag.id,
                ann
            );

            // check each related tag, which is usually a link tag
            for (let i = 0; i < related_tags.length; i++) {
                const related_tag = related_tags[i];
                if (tag_names.indexOf(related_tag.tag)>=0) {
                    return true;
                }
            }

            return false;
        },

        is_etag_doc_level: function(tag) {
            if (tag.spans == '-1~-1') {
                return true;
            }
            return false;
        },
        
        is_etag: function(tag) {
            if (tag.hasOwnProperty('spans')) {
                return true;
            }
            return false;
        },

        stat_value2width: function(value, max_value) {
            return this.val2width(value, max_value);
        },

        stat_value2bgcolor: function(value, max_value, zero_color) {
            if (typeof(max_value)=='undefined') {
                max_value = 10;
            }
            if (typeof(zero_color)=='undefined') {
                zero_color = '#ffffff';
            }
            if (value == 0) {
                return zero_color;
            } else {
                return d3.rgb(
                    d3.interpolateReds(value / max_value)
                ).formatHex() + '';
            }
        },

        stat_value2ftcolor: function(value, max_value, zero_color) {
            if (typeof(max_value)=='undefined') {
                max_value = 10;
            }
            if (typeof(zero_color)=='undefined') {
                zero_color = '#eeeeee';
            }
            if (value == 0) {
                return zero_color;
            } else {
                if (value / max_value < 0.6) {
                    return '#000000';
                } else {
                    return '#ffffff';
                }
            }
        },

        get_date_now: function() {
            return dayjs().format('YYYY-MM-DD');
        },

        get_datetime_now: function() {
            return dayjs().format('YYYY-MM-DD_HH.mm.ss');
        },

        get_n_pages_by_total: function(total) {
            return Math.ceil(total / this.pg_numpp);
        },

        get_pages_by_total: function(total) {
            return [...Array(this.get_n_pages_by_total(total)).keys()];
        },
        
    },

    vpp_computed: {
        pages_of_anns_total: function() {
            return Math.ceil(this.anns.length / this.pg_numpp);
        },

        pages_of_anns: function() {
            return [...Array(Math.ceil(this.anns.length / this.pg_numpp)).keys()];
        },

        virtual_anns: function() {
            if (this.section == 'annotation' && 
                this.mn4anns>0) {

                if (this.anns.length > 0) {
                    var v_anns = this.get_sorted_v_anns();

                    var v_anns_paged = v_anns;
                    // get the page of current
                    if (Math.ceil(v_anns.length / this.pg_numpp) > 1) {
                        v_anns_paged = v_anns.slice(
                            this.pg_index * this.pg_numpp,
                            (this.pg_index + 1) * this.pg_numpp
                        );
                    }

                    return {
                        v_anns: v_anns,
                        v_anns_paged: v_anns_paged
                    };
                }   
            }
            // for all other cases
            return {
                v_anns: [],
                v_anns_paged: []
            };
        },

        stat_docs_by_tags: function() {
            if (this.section == 'statistics') {
                return stat_helper.get_stat_docs_by_tags_json(
                    this.anns,
                    this.dtd
                );
            } else {
                // don't update if not in stat section
                return stat_helper.get_stat_docs_by_tags_json(
                    [],
                    this.dtd
                );
            }
        },

        stat_summary: function() {
            if (this.section == 'statistics') {
                return stat_helper.get_stat_items(
                    this.anns,
                    this.dtd
                );
            } else {
                // don't update if not in stat section
                return [];
            }
        },

        stat_doc_sum_selected_tags: function() {
            if (this.section == 'statistics') {
                if (this.display_stat_doc_sum_selected == null) {
                    return null;
                }
                // find this ann
                var ann_idx = this.find_included(
                    this.display_stat_doc_sum_selected.file_name,
                    this.anns
                );

                // find the tags
                var tags = this.get_tags_by_tag_name(
                    this.anns[ann_idx],
                    this.display_stat_doc_sum_selected.tag_name
                );

                // last is just update tags
                return tags;
            } else {
                // don't update if not in stat section
                return [];
            }
        }
    },

    // code mirror instance
    codemirror: null,
    // marked texts in code mirror
    marktexts: [],
    // the selected text
    selection: null,

    // the context menu for selection
    ctxmenu_sel: null,

    // the context menu for nc etags
    ctxmenu_nce: null,

    // the popup menu for tag
    popmenu_tag: null,

    // interval update
    interval_force_update: null,
    // the seconds for interval
    interval_force_update_duration: 1,

    start_interval_force_update: function() {
        if (this.interval_force_update != null) {
            // which means it is already started
            return;
        }
        // start !
        app_hotpot.interval_force_update = setTimeout(
            "app_hotpot.exec_interval_force_update()", 
            app_hotpot.interval_force_update_duration * 1000
        );
        console.log('* started auto interval force update')
    },

    exec_interval_force_update: function() {
        if (app_hotpot.n_anns == app_hotpot.vpp.$data.anns.length) {
            if (app_hotpot.cnt_no_more_anns >= 3) {
                // ok, nothing to do now
                // let's stop the interval
                app_hotpot.cnt_no_more_anns = 0;
                app_hotpot.interval_force_update = null;
                console.log('* cleared auto interval force update');

            } else {
                // just double check later
                app_hotpot.cnt_no_more_anns += 1;
            }
        } else {
            // force update
            app_hotpot.n_anns = app_hotpot.vpp.$data.anns.length;
            app_hotpot.vpp.$forceUpdate();
            console.log('* force-updated app_hotpot vpp!');
        }

        if (app_hotpot.interval_force_update == null) {
            // that's great!
            // no need to check later
        } else {
            app_hotpot.interval_force_update = setTimeout(
                "app_hotpot.exec_interval_force_update()", 
                app_hotpot.interval_force_update_duration * 1000
            );
            console.log(
                '* scheduled interval force update in ' + 
                app_hotpot.interval_force_update_duration + ' second(s).'
            );
        }
    },

    init: function() {
        this.vpp = new Vue({
            el: this.vpp_id,
            data: this.vpp_data,
            methods: this.vpp_methods,

            mounted: function() {
                Metro.init();
            },

            computed: this.vpp_computed,

            updated: function() {
                this.$nextTick(function () {
                    // Code that will run only after the
                    // entire view has been re-rendered
                    if (this.section == 'annotation') {
                        if (this.cm.is_expire) {
                            this.set_ann_idx(this.ann_idx);
                            this.cm.is_expire = false;
                        }
                    }
                });
            }
        });

        // init the setting panel 
        this.init_settings();

        // the code mirror
        this.cm_init();

        // the global event
        this.bind_events();

        // set the resize
        this.resize();

        // init brat
        fig_bratvis.init();
    },

    /**
     * Set the whole vpp_data JSON to restore workspace
     * for debug/demo purpose
     * 
     * @param {Object} vpp_data_json the saved workspace
     */
    set_vpp_data_json: function(vpp_data_json) {
        Object.assign(this.vpp.$data, vpp_data_json);
        app_hotpot.set_dtd(
            app_hotpot.vpp.$data.dtd
        );
        if (app_hotpot.vpp.$data.anns.length != 0) {
            if (app_hotpot.vpp.$data.ann_idx == null) {
                app_hotpot.vpp.set_ann_idx(0);
            } else {
                app_hotpot.vpp.set_ann_idx(
                    app_hotpot.vpp.$data.ann_idx
                );
            }
        }
    },

    /**
     * Set the DTD for this annotation project
     * 
     * @param {Object} dtd An object of dtd
     */
    set_dtd: function(dtd) {
        console.log('* set dtd', dtd);
        this.vpp.$data.dtd = dtd;

        // update the color define
        this.update_tag_styles();

        // update the shortcuts
        this.update_tag_shortcuts();

        // update the context menu
        this.update_tag_ctxmenu();

        // update the context menu
        this.update_nce_ctxmenu();

        // update the pop menu
        this.update_tag_popmenu();

        // special rule for dtd meta
        if (dtd.hasOwnProperty('meta')) {
            console.log('* found meta in annotation schema', dtd.meta);
            this.set_meta_from_dtd(dtd);
        }

        // force update
        this.vpp.$forceUpdate();
    },

    set_meta_from_dtd: function(dtd) {
        if (dtd.meta.hasOwnProperty('sentencize_exceptions')) {
            // this is for the sentencizer
            this.set_meta_of_sentencize_exceptions(dtd.meta.sentencize_exceptions);
        }

        if (dtd.meta.hasOwnProperty('error_definition')) {
            // this is for the error analysis
            this.vpp.set_razer_err_def(dtd.meta.error_definition);
        }
    },

    set_meta_of_sentencize_exceptions: function(sentencize_exceptions) {
        // this is for the nlp_toolkit
        for (let i = 0; i < sentencize_exceptions.length; i++) {
            var se = sentencize_exceptions[i];
            var se_lower = se.toLocaleLowerCase();

            // add to the nlp_toolkit sentencize_exceptions
            nlp_toolkit.sentencize_exceptions.add(se_lower);
        }
        this.toast('Updated NLP Toolkit sentencize_exceptions with ' + 
            sentencize_exceptions.length + ' tokens.',
            'info'
        );
    },

    clear_ann_all: function() {
        // clean all annotations and related data
        this.anns = [];
        this.ann_idx = null;
        this.hint_dict = {};
    },

    reset_vpp: function() {
        this.dtd = null;
        this.clear_ann_all();
        this.clear_iaa_all();
    },

    add_ann: function(ann, is_switch_to_this_ann) {
        // check the schema first
        // if (ann.dtd_name != this.vpp.$data.dtd.name) {
        //     console.log('* skip unmatched ann', ann);
        //     app_hotpot.msg('Skipped unmatched file ' + ann._filename, 'warning');
        //     return;
        // }

        // if (this.vpp.$data.anns.length < this.n_anns_small_project) {
        //     this.vpp.$data.anns.push(ann);
        // } else {
        //     this.vpp.$data.anns[
        //         this.vpp.$data.anns.length
        //     ] = ann;
        //     // this.start_interval_force_update();
        // }

        // update hint_dict when add new ann file
        // this.update_hint_dict_by_ann(ann);

        // if (is_switch_to_this_ann || this.vpp.$data.anns.length == 1) {
        //     this.vpp.$data.ann_idx = this.vpp.$data.anns.length - 1;

        //     // update the text display
        //     this.cm_set_ann(
        //         this.vpp.$data.anns[this.vpp.$data.ann_idx]
        //     );
    
        //     // update the marks
        //     this.cm_update_marks();
        // }

        // this.vpp.$forceUpdate();
        // console.log("* added ann", ann._filename);
    },

    /////////////////////////////////////////////////////////////////
    // Events related
    /////////////////////////////////////////////////////////////////

    bind_events: function() {
        // init bind for annotation

        // bind drop zone for dtd
        // this.bind_dropzone_dtd();

        // bind drop zone for annotation xml/txt files
        // this.bind_dropzone_ann();

        // bind global click event for annotation
        this.bind_click_event();

        // bind global key event for annotation
        this.bind_keypress_event();

        // bind a dragable for tqv
        this.bind_tqv_dragable();

        // global bind
        // bind the closing event
        this.bind_unload_event();
    },

    bind_click_event: function() {
        document.getElementById('app_hotpot').addEventListener(
            "click",
            function(event) {
                // console.log('* clicked on', event.target);

                var dom = event.target;
                var obj = $(dom);

                if (obj.hasClass('mark-tag') ||
                    obj.hasClass('mark-tag-text')) {
                    // which means clicks on a tag.
                    // so don't touch the popmenu
                } else {
                    // 
                    if (app_hotpot.popmenu_tag != null) {
                        app_hotpot.popmenu_tag.hide();
                    }
                }

                // show the menu
                // var mouseX = event.clientX;
                // var mouseY = event.clientY;

                // close the right click menu
                if (app_hotpot.ctxmenu_sel != null) {
                    app_hotpot.ctxmenu_sel.hide();
                }
                if (app_hotpot.ctxmenu_nce != null) {
                    app_hotpot.ctxmenu_nce.hide();
                }

                // if (obj.hasClass('mark-tag-text')) {
                //     // this is a mark in code mirror
                //     var tag_id = dom.getAttribute('tag_id');

                //     // set the clicked tag_id
                //     app_hotpot.vpp.$data.clicked_tag_id = tag_id;

                //     // show the menu
                //     app_hotpot.show_tag_popmenu_at(mouseX, mouseY);
                // } else {
                //     // what to do?
                // }
            }
        );
    },

    bind_keypress_event: function() {
        document.addEventListener(
            // "keypress",
            "keydown",
            function(event) {
                // console.log('* pressed on', event);

                if (event.key.toLocaleLowerCase() == 'h') {
                    app_hotpot.vpp.show_quick_help();
                    return;
                }

                if (event.altKey) {
                    if (event.key == 'ArrowUp') {
                        app_hotpot.vpp.set_ann_idx_to_prev();
                    } else if (event.key == 'ArrowDown') {
                        app_hotpot.vpp.set_ann_idx_to_next();
                    }

                    return;
                }

                // first, check if there is any selection
                app_hotpot.vpp.add_etag_by_shortcut_key(
                    event.key.toLocaleLowerCase()
                );
            }
        );

        document.addEventListener('keydown', function(event) {
            if (event.ctrlKey ||
                event.metaKey || 
                event.which === 19) {
                app_hotpot.has_pressed_ctrl_meta = true;
                timer = Date.now();
            }
            if (app_hotpot.has_pressed_ctrl_meta && 
                event.which === 83 && 
                Date.now()-timer<100){
                event.preventDefault();
                app_hotpot.has_pressed_ctrl_meta = false;

                // ok, let's do saving
                console.log('* pressed Cmd/Ctrl + S for saving the current annotation')
                app_hotpot.vpp.save_xml();
            }
          });
    },

    bind_unload_event: function() {
        window.addEventListener('beforeunload', function (event) {
            if (app_hotpot.vpp.has_unsaved_ann_file()) {
                event.preventDefault();
                var msg = 'There are unsaved annotation files, are you sure to leave them unsaved?';
                event.returnValue = msg;
                return msg;
            }
        });
    },

    resize: function() {
        var w = $(window).width();
        var h = $(window).height();
        $('.main-ui').css('height', h - 145);

        if (this.vpp.$data.section == 'annotation') {
            // due the svg issue, when resizing the window,
            // redraw all rtag marks only when annotation 
            this.cm_clear_rtag_marks();

            // redraw all marks
            this.cm_update_tag_marks();
        }

        console.log('* resized windows to ' + w + 'x' + h);
    },

    parse_file2ann: function(file, dtd) {
        var ann = null;
        if (app_hotpot.is_file_ext_txt(file.fh.name)) {
            // this is a text file
            ann = ann_parser.txt2ann(
                file.text,
                dtd
            );

            // bind fh, but txt has no real fh
            ann._fh = null;
            // bind the filename seperately
            // create a file name 
            ann._filename = app_hotpot.get_new_ann_fn_by_txt_fn(
                file.fh.name
            );

        } else if (app_hotpot.is_file_ext_xml(file.fh.name)) {
            // this is a xml file
            ann = ann_parser.xml2ann(
                file.text,
                dtd
            );

            // bind the fh
            ann._fh = file.fh;
            // bind the filename seperately
            ann._filename = file.fh.name;
        }

        return ann;
    },


    read_file_async: function(fileEntry, callback) {
        fileEntry.file(function(file) {
            let reader = new FileReader();
            reader.onload = callback;
            reader.readAsText(file)
        });
    },

    parse_ann_file_fh: function(fh, dtd) {
        // show something if this file exists
        // check if this file name exists
        if (app_hotpot.vpp.has_included_ann_file(fh.name)) {
            // exists? skip this file
            app_hotpot.msg('Skipped same name or duplicated ' + fh.name);
            return;
        }

        // if drop a txt!
        if (app_hotpot.is_file_ext(fh.name, 'txt')) {
            // parse this txt file
            app_hotpot.parse_ann_txt_file_fh(
                fh,
                dtd
            );
            return;
        }

        // should be a ann txt/xml file
        if (app_hotpot.is_file_ext(fh.name, 'xml')) {
            app_hotpot.parse_ann_xml_file_fh(
                fh,
                dtd
            );
            return;
        }

        console.log('* skip unknown format file', fh.name);
    },

    get_new_ann_fn_by_txt_fn: function(txt_fn) {
        return txt_fn + '.xml';
    },

    update_ann_sentences: function(ann, skip_existed) {
        if (typeof(skip_existed) == 'undefined') {
            skip_existed = true;
        }

        if (ann._sentences_text != '') {
            if (skip_existed) {
                return ann;
            }
        }
        var r = nlp_toolkit.sent_tokenize(
            ann.text,
            app_hotpot.vpp.$data.cfg.sentence_splitting_algorithm
        );
        ann._sentences = r.sentences;
        ann._sentences_text = r.sentences_text;

        // console.log('* updated sentences for ann', ann._filename);
        return ann;
    },

    /////////////////////////////////////////////////////////////////
    // DTD update related
    /////////////////////////////////////////////////////////////////
    // the default colors are from
    // https://colorbrewer2.org/#type=qualitative&scheme=Set3&n=12
    app_colors: [
        '#a6cee3',
        // '#1f78b4',
        '#51a1d7',
        '#b2df8a',
        '#33a02c',
        '#fb9a99',
        '#e31a1c',
        '#fdbf6f',
        '#ff7f00',
        '#cab2d6',
        '#9654dc',
        '#d0aa3d',
        '#b15928',
        '#8dd3c7',
        '#9c9c64',
        '#bebada',
        '#fb8072',
        '#80b1d3',
        '#fdb462',
        '#b3de69',
        '#fccde5',
        '#d9d9d9',
        '#bc80bd',
        '#ccebc5',
        '#ffed6f',
    ],

    update_tag_styles: function() {
        var elem_style = document.getElementById ("dtd_style");
        var style = elem_style.sheet ? elem_style.sheet : elem_style.styleSheet;

        // clear all rules first
        while(style.cssRules.length>0) {
            style.deleteRule(0);
        }

        // check each tag
        var i = 0;
        for (const tag_name in this.vpp.$data.dtd.tag_dict) {
            if (Object.hasOwnProperty.call(this.vpp.$data.dtd.tag_dict, tag_name)) {
                var tag = this.vpp.$data.dtd.tag_dict[tag_name];
                
                // add a new style for this tag
                var color = 'white';
                if ( i < this.app_colors.length ) {
                    // use default color
                    color = this.app_colors[i];
                } else {
                    // we don't have enough colors now
                    // just use a random color
                    color = '#' + Math.floor(Math.random()*16777215).toString(16);
                }

                // update the color for this tag
                this.vpp.$data.dtd.tag_dict[tag_name].style = {
                    color: color
                };
                
                // add this tag as the given color
                // set this color for related css rules
                style.insertRule(
                    ".mark-tag-" + tag_name + " { background-color: " + color + "; }",
                    0
                );
                style.insertRule(
                    ".border-tag-" + tag_name + " { border-color: " + color + " !important; }",
                    0
                );
                style.insertRule(
                    ".fg-tag-" + tag_name + " { color: " + color + " !important; }",
                    0
                );

                // add this for svg
                style.insertRule(
                    ".svgmark-tag-" + tag_name + " { fill: " + color + "; }",
                    0
                );

                // add this tag as the hint
                style.insertRule(
                    ".mark-hint-" + tag_name + ":hover { background-color: " + color + "; }",
                    0
                );
                
                i += 1;
            }
        }
    },

    app_shortcuts: [
        '1',
        '2',
        '3',
        '4',
        '5',
        'q',
        'w',
        'e',
        'r',
        't',
        'a',
        's',
        'd',
        'f',
        'g',
        'z',
        'x',
        'c',
        'v',
        'b'
    ],

    update_tag_shortcuts: function() {
        for (let i = 0; i < this.vpp.dtd.etags.length; i++) {
            if (i < this.app_shortcuts.length) {
                // assign a key to this etag
                this.vpp.dtd.etags[i].shortcut = this.app_shortcuts[i];
                
                // now, we need to update the tag_dict
            }
        }
    },

    show_tag_ctxmenu: function(x, y) {
        var w = this.ctxmenu_sel.width();
        var h = this.ctxmenu_sel.height();
        var new_y = this.adjust_ctxmenu_y(y, h);
        console.log("* show tag ctx menu on ", x, y, "("+new_y+")", 'w', w, 'h', h);

        // show the tag ctx menu
        this.ctxmenu_sel.css('left', (x - 10 - w) + 'px')
            .css('top', (new_y + 10) + 'px')
            .show('drop', {}, 200, null);
    },

    show_nce_ctxmenu: function(x, y) {
        var w = this.ctxmenu_nce.width();
        var h = this.ctxmenu_nce.height();
        var new_y = this.adjust_ctxmenu_y(y, h);
        console.log("* show nce ctx menu on ", x, y, "("+new_y+")", 'w', w, 'h', h);
        
        // show the document level menu
        this.ctxmenu_nce.css('left', (x - 10 - w) + 'px')
            .css('top', (new_y + 10) + 'px')
            .show('drop', {}, 200, null);
    },

    show_tag_popmenu_at: function(x, y) {
        var w = this.popmenu_tag.width();
        console.log("* show tag pop menu ("+w+") on ", x, y);
        // fix for not rendering
        if (w < 150) { w = 150;}
        this.popmenu_tag.css('left', (x - 10 - w) + 'px')
            .css('top', (y + 10) + 'px')
            .show('drop', {}, 200, null);
    },

    adjust_ctxmenu_y: function(y, h) {
        // get the height of current window
        var win_h = $(window).height();

        // set a new y position
        var new_y = y;

        // check the height to avoid hidden by 
        if (y + h > win_h) {
            new_y = win_h - h - 15;
        }

        return new_y;
    },

    update_tag_ctxmenu: function() {
        // update the context menu
        this.ctxmenu_sel = $('#ctxmenu_sel').menu({
            items: "> :not(.ui-widget-header)"
        });
    },

    update_nce_ctxmenu: function() {
        // update the context menu
        this.ctxmenu_nce = $('#ctxmenu_nce').menu({
            items: "> :not(.ui-widget-header)"
        });
    },

    update_tag_popmenu: function() {
        // update the pop menu
        this.popmenu_tag = $('#popmenu_tag').menu({
            items: "> :not(.ui-widget-header)"
        });
    },

    update_hint_dict_by_ann: function(ann) {
        this.vpp.hint_dict = ann_parser.add_ann_to_hint_dict(
            ann,
            this.vpp.hint_dict
        );
    },

    update_hint_dict_by_tag: function(ann, tag) {
        this.vpp.hint_dict = ann_parser.add_tag_to_hint_dict(
            ann, 
            tag, 
            this.vpp.hint_dict
        );
        //console.log('* updated hint_dict by a tag', this.vpp.hint_dict, tag);
    },

    /////////////////////////////////////////////////////////////////
    // Tag Related
    /////////////////////////////////////////////////////////////////
    make_etag: function(basic_tag, tag_def, ann) {
        // first, add the tag name
        basic_tag['tag'] = tag_def.name;

        // find the id number
        // var n = 0;
        // for (let i = 0; i < ann.tags.length; i++) {
        //     if (ann.tags[i].tag == tag_def.name) {
        //         // get the id number of this tag
        //         var _id = parseInt(ann.tags[i].id.replace(tag_def.id_prefix, ''));
        //         if (_id >= n) {
        //             n = _id + 1;
        //         }
        //     }
        // }
        // basic_tag['id'] = tag_def.id_prefix + n;
        basic_tag['id'] = ann_parser.get_next_tag_id(ann, tag_def);

        // add other attr defined in the tag_dee from schema (.dtd)
        for (let i = 0; i < tag_def.attrs.length; i++) {
            const att = tag_def.attrs[i];

            if (att.name == 'spans') {
                // special rule for spans attr
                // which means it could be a non-consuming tag?
            } else {
                // set the default value
                basic_tag[att.name] = att.default_value;
            }
        }

        return basic_tag;
    },

    make_rtag: function() {

    },

    make_empty_etag_by_tag_def: function(tag_def) {
        var etag = {
            id: '',
            tag: tag_def.name,
            spans: '',
            text: ''
        };

        // for non-consuming tag (doc-level tag)
        if (tag_def.hasOwnProperty('is_non_consuming') &&
            tag_def.is_non_consuming) {
            etag.spans = dtd_parser.NON_CONSUMING_SPANS;
        }

        // then add other attr
        for (let i = 0; i < tag_def.attrs.length; i++) {
            const att = tag_def.attrs[i];

            if (att.name == 'spans') {
                // special rule for spans attr
                etag.spans = dtd_parser.NON_CONSUMING_SPANS;

            } else {
                // set the default value
                etag[att.name] = att.default_value;
            }
        }

        return etag;
    },

    make_empty_rtag_by_tag_def: function(tag_def) {
        var rtag = {
            id: '',
            tag: tag_def.name
        };

        // then add other attr
        for (let i = 0; i < tag_def.attrs.length; i++) {
            const att = tag_def.attrs[i];

            if (att.name == 'spans') {
                // special rule for spans attr
            } else {
                // set the default value
                rtag[att.name] = att.default_value;
            }
        }

        return rtag;
    },
    
    remove_tag_from_ann: function(tag_id, ann) {
        var tag_idx = -1;
        for (let i = 0; i < ann.tags.length; i++) {
            if (ann.tags[i].id == tag_id) {
                tag_idx = i;
                break;
            }            
        }

        // delete the found tag idx
        if (tag_idx == -1) {
            // ???
        } else {
            ann.tags.splice(tag_idx, 1); 
        }

        return ann;
    },

    delete_tag: function(tag_id, ann, is_check_rtag, is_update_marks) {
        if (typeof(ann) == 'undefined') {
            ann = this.vpp.$data.anns[this.vpp.$data.ann_idx];
        }
        if (typeof(is_check_rtag) == 'undefined') {
            is_check_rtag = true;
        }
        if (typeof(is_update_marks) == 'undefined') {
            is_update_marks = true;
        }

        if (is_check_rtag) {
            // when deleting etag, need to check if there is linked rtag
            var linked_rtags = ann_parser.get_linked_rtags(tag_id, ann);

            if (linked_rtags.length == 0) {
                // great! no links!
                // just keep going
            } else {
                // ok, are you sure?
                // let's make a long message
                var msg = ['There are ' + linked_rtags.length + ' link tag(s) related to [' + tag_id + ']:\n'];
                for (let i = 0; i < linked_rtags.length; i++) {
                    const rtag = linked_rtags[i];
                    msg.push('- ' + rtag.id + ' (' + rtag.tag + ') ' + '\n');
                }
                msg.push('\nDeleting [' + tag_id + '] will also delete the above link tag(s).\n');
                msg.push('Are you sure to continue?');
                msg = msg.join('');

                var ret = this.confirm(msg);

                if (ret) {
                    // ok, let's delete the links first
                    for (let i = 0; i < linked_rtags.length; i++) {
                        const rtag = linked_rtags[i];
                        // save some time when running this inner deletion
                        this.delete_tag(
                            rtag.id, 
                            ann, 
                            false, 
                            false
                        );
                    }
                } else {
                    // nice choice! keep them all!
                    return;
                }
            }
        }

        // just remove this tag now
        this.vpp.$data.anns[this.vpp.$data.ann_idx] = this.remove_tag_from_ann(tag_id, ann);

        // mark _has_saved
        // this.vpp.$data.anns[this.vpp.$data.ann_idx]._has_saved = false;
        this.vpp.set_current_ann_unsaved();

        console.log('* deleted tag ' + tag_id);

        // remove the hover box
        this.vpp.hovered_tag = null;

        // update the marks
        if (is_update_marks) {
            app_hotpot.cm_update_marks();
        }

        // toast
        app_hotpot.toast(
            'Successfully deleted tag ' + tag_id,
            ''
        );
    },

    /////////////////////////////////////////////////////////////////
    // Annotation Related
    /////////////////////////////////////////////////////////////////

    scroll_annlist_to_bottom: function() {
        var objDiv = document.getElementById("mui_annlist");
        objDiv.scrollTop = objDiv.scrollHeight;
    },

    scroll_tag_table_to: function(tag_id) {
        // get the annlist height
        var h = $('#mui_annlist').height();
        
        // get the offset of this tag
        var tr = $('#tag-table-row-' + tag_id);
        if (tr.length != 1) {
            // which means no such element
            return; 
        }
        var offset_y = tr[0].offsetTop;

        // scroll to the view
        // when scrolling to the offset
        $('#mui_annlist')[0].scrollTo(
            0, // the x-axis should be no scroll
            offset_y - h / 2
        );
    },

    highlight_tag_table_row: function(tag_id) {
        // get the row of this tag
        var tagr = $('#tag-table-row-' + tag_id);
        if (tagr.length != 1) {
            // which means no such element
            return; 
        }
        var flag_actived = tagr.hasClass('tag-table-tr-actived');

        // remove other style
        $('.tag-table-row').removeClass('tag-table-tr-actived');

        // add a class to this dom
        if (flag_actived) {

        } else {
            tagr.addClass('tag-table-tr-actived');
        }
        // show animation
        // tagr.animate({backgroundColor: 'yellow'}, 300)
        // .animate({backgroundColor: 'white'}, 700);
    },
    
    /////////////////////////////////////////////////////////////////
    // Shared utils for all functions
    /////////////////////////////////////////////////////////////////
    is_same_dtd: function(dtd_a, dtd_b, level) {
        if (typeof(level) == 'undefined') {
            level = 0;
        }

        if (level>=0) {
            if (dtd_a.name == dtd_b.name) {
                
            } else {
                return false;
            }
        }

        return true;
    },

    is_fn_existed_in_files: function(fn, files) {
        for (let i = 0; i < files.length; i++) {
            const _f = files[i];
            if (_f.fh.name == fn) {
                return true;
            }
        }

        return false;
    },

    is_file_ext: function(filename, ext) {
        var fn_lower = filename.toLocaleLowerCase();

        if (fn_lower.endsWith("." + ext)) {
            return true;
        }

        return false;
    },

    is_file_ext_txt: function(fn) {
        return app_hotpot.is_file_ext(fn, 'txt');
    },

    is_file_ext_xml: function(fn) {
        return app_hotpot.is_file_ext(fn, 'xml');
    },

    is_file_ext_json: function(fn) {
        return app_hotpot.is_file_ext(fn, 'json');
    },

    is_file_ext_yaml: function(fn) {
        return app_hotpot.is_file_ext(fn, 'yaml');
    },

    is_file_ext_dtd: function(fn) {
        return app_hotpot.is_file_ext(fn, 'dtd');
    },

    is_file_ext_ann: function(fn) {
        return app_hotpot.is_file_ext(fn, 'ann');
    },

    get_file_ext: function(filename) {
        var ext = filename.split('.').pop();
        ext = ext.toLocaleLowerCase();
        return ext;
    },

    toast: function(msg, cls, timeout) {
        if (typeof(cls) == 'undefined') {
            cls = '';
        }
        if (typeof(timeout) == 'undefined') {
            timeout = 3000;
        }
        var options = {
            showTop: true,
            timeout: timeout,
            clsToast: cls
        };
        Metro.toast.create(msg, null, null, null, options);
    },

    msg: function(msg, cls) {
        if (typeof(cls) == 'undefined') {
            cls = 'info';
        }
        msg = '<i class="fa fa-info-circle"></i> ' + msg; 
        var notify = Metro.notify;
        notify.setup({
            width: 300,
            timeout: 3000,
            animation: 'swing'
        });
        notify.create(msg, null, { 
            cls: cls
        });
    },

    confirm: function(msg) {
        return window.confirm(msg);
        // Metro.dialog.create({
        //     title: "Use Windows location service?",
        //     content: "<div>Bassus abactors ducunt ad triticum...</div>",
        //     actions: [
        //         {
        //             caption: "Agree",
        //             cls: "js-dialog-close alert",
        //             onclick: function(){
        //                 alert("You clicked Agree action");
        //             }
        //         },
        //         {
        //             caption: "Disagree",
        //             cls: "js-dialog-close",
        //             onclick: function(){
        //                 alert("You clicked Disagree action");
        //             }
        //         }
        //     ]
        // });
    },

    get_elem_shape: function(elem) {
        // get the bounding box for this element
        var bounds = elem.getBBox();

        // get the extend style 
        var style = getComputedStyle(elem);
        var padding_top = parseInt(style["padding-top"])
        var padding_left = parseInt(style["padding-left"])
        var padding_right = parseInt(style["padding-right"])
        var padding_bottom = parseInt(style["padding-bottom"])

        // now, we could get the shape of this element
        var shape = {
            x: bounds.x - padding_left,
            y: bounds.y - padding_top,
            width: bounds.width + padding_left + padding_right,
            height: bounds.height + padding_top + padding_bottom
        }

        return shape;
    },

    make_svg_text_bg: function(elem, cls) {
        // get the shape
        var shape = this.get_elem_shape(elem);

        // create a background
        var bg = document.createElementNS(
            "http://www.w3.org/2000/svg", 
            "rect"
        );

        // set the attributes of this bg
        bg.setAttribute("x", shape.x);
        bg.setAttribute("y", shape.y);
        bg.setAttribute("width", shape.width);
        bg.setAttribute("height", shape.height);
        bg.setAttribute("class", 'tag-linktext-bg ' + cls);

        elem.parentNode.insertBefore(bg, elem);
    },


    hard_slice: function(a, n) {
        if (typeof(n) == 'undefined') {
            n = 10;
        }

        if (n>a.length) {
            n = a.length;
        }

        var b = [];
        for (let i = 0; i < n; i++) {
            b.push(a[i]);
        }

        return b;
    },

    is_vpp_data_json: function(j) {
        if (
            j.hasOwnProperty('cfg') && 
            j.hasOwnProperty('dtd') && 
            j.hasOwnProperty('anns') &&
            j.hasOwnProperty('hints') &&
            j.hasOwnProperty('version')
        ) {
            // we use a VERY simple rule to detect vpp_data json
            // just by the keys
            return true;
        } else {
            return false;
        }
    }

    /////////////////////////////////////////////////////////////////
    // Code Mirror Related
    /////////////////////////////////////////////////////////////////
    // see app_hotpot_ext_codemirror.js

    
    /////////////////////////////////////////////////////////////////
    // Tour Related
    /////////////////////////////////////////////////////////////////
    // see app_hotpot_ext_tour.js

};

// update the version information
// so this will be used in the following programs
app_hotpot.vpp_data.version = "1.3.15";

// extend the App with settings
/**
 * This is an extension for setting management
 */

/////////////////////////////////////////////////////////////////
// setting management related variables
/////////////////////////////////////////////////////////////////
Object.assign(app_hotpot.vpp_data, {
    // for enable the auto save/load config feature
    // this list will contain all the setting names in cfg
    auto_sl_cfg_names: [],

    // configurations
    cfg: {
        // display the setting panel or not
        enable_show_settings: false,

        // display the old menu dropzone
        enable_display_menu_dropzone_ann: false,

        // auto save the current ann
        auto_save_current_ann: 'disable',

        // auto save the current configs
        auto_sl_current_cfg: 'disable',

        // active tab
        active_setting_tab: 'gui',

        // which algorithm to use as default
        sentence_splitting_algorithm: 'simpledot',

        // render all marks or only the selected marks
        linking_marks_selection: 'all_concepts',

        // show the new UI for ea
        new_ui_for_ea: 'disable',

        // show the new UI for toolkit
        new_ui_for_tk: 'enable',

        // show the new UI for cohen's kappa
        // due to the 
        new_ui_for_ck: 'disable',
    },

    // default cfg for reset
    cfg_default_vals: {}
});


/////////////////////////////////////////////////////////////////
// setting management related functions
/////////////////////////////////////////////////////////////////
Object.assign(app_hotpot, {
    init_settings: function() {
        // get the default vals from code
        this.vpp.cfg_default_vals = JSON.parse(JSON.stringify(
            this.vpp.cfg
        ));

        // init 
        this.vpp.init_auto_sl_cfg_names();

        // load settings?
        let local_is_auto_sl_cfg = localStorage.getItem('auto_sl_current_cfg');

        if (local_is_auto_sl_cfg == 'enable') {
            this.vpp.load_local_settings();
        } else {
            // which means it is null or disable
            // just skip
        }
    },
});

/////////////////////////////////////////////////////////////////
// setting management related functions
/////////////////////////////////////////////////////////////////
Object.assign(app_hotpot.vpp_methods, {
    /**
     * Init the list for auto save/load
     */
    init_auto_sl_cfg_names: function() {
        this.auto_sl_cfg_names = [];
        for (const key in this.cfg) {
            if (Object.hasOwnProperty.call(this.cfg, key)) {
                this.auto_sl_cfg_names.push(key);
            }
        }
        console.log('* found ' + this.auto_sl_cfg_names.length + ' config names for auto S/L');
    },

    switch_setting_tab: function(tab) {
        this.cfg.active_setting_tab = tab;
    },

    is_adjudication_working_mode: function() {
        return this.annotation_tab_working_mode == 'adjudication';
    },

    is_auto_save_ann: function() {
        return this.cfg.auto_save_current_ann == 'enable';
    },

    is_auto_sl_cfg: function() {
        return this.cfg.auto_sl_current_cfg == 'enable';
    },

    get_metator_mem: function() {
        // return Math.floor(window.performance.memory.totalJSHeapSize / 1024 / 1024);
        if (window.hasOwnProperty('performance')) {
            if (window.performance.hasOwnProperty('memory')) {
                return Math.floor(window.performance.memory.usedJSHeapSize / 1024 / 1024);
            }
        } else {
            return 'NA';
        }
        return 'NA';
    },

    on_change_setting: function(key) {
        if (this.is_auto_sl_cfg()) {
            this.save_local_setting(key);
        } else {
            // ok, when this feature is disabled,
            // the saved settings should be cleared
            this.clear_local_settings();
        }
    },

    save_local_settings: function() {
        // need to specify which to be saved
        for (let i = 0; i < this.auto_sl_cfg_names.length; i++) {
            const cfg_name = this.auto_sl_cfg_names[i];
            this.save_local_setting(cfg_name);
        }
    },

    clear_local_settings: function() {
        for (let i = 0; i < this.auto_sl_cfg_names.length; i++) {
            const cfg_name = this.auto_sl_cfg_names[i];
            localStorage.removeItem(
                cfg_name
            );
        }
        console.log("* cleared all local settings");
    },

    save_local_setting: function(cfg_name) {
        let cfg_val = this.cfg[cfg_name];
        localStorage.setItem(
            cfg_name,
            cfg_val
        );
        console.log('* saved setting['+cfg_name+'='+cfg_val+'] to localStorage');
    },

    load_local_settings: function() {
        for (let i = 0; i < this.auto_sl_cfg_names.length; i++) {
            const cfg_name = this.auto_sl_cfg_names[i];
            const val = this.cfg[cfg_name];
            var local_val = localStorage.getItem(cfg_name);
            if (local_val == null) {
                // no setting yet
            } else {
                this.cfg[cfg_name] = local_val;
                console.log('* loaded local setting[cfg.' + cfg_name + '=' + local_val + ']');
            }
        }
    },

    on_click_reset_to_default_settings: function() {
        var ret = window.confirm('Attention! If you click the "Reset Settings" button, all settings will be reset to their default values. This action may affect your current annotation work, so please save your work before proceeding with the reset.\nOnce you click the button, the page will NOT refresh automatically. You will need to refresh the page.\nTo avoid losing your current annotation work, please save your progress before resetting the settings. We recommend to reset settings when not annotating.\n\nAre you sure to reset?');

        if (ret) {

        } else {
            return;
        }

        this.reset_local_settings_to_default();

        window.alert("The settings have been reset! Please refresh the page to enable the new settings.");
    },

    reset_local_settings_to_default: function() {
        // first, set values to default
        this.cfg = JSON.parse(JSON.stringify(
            this.cfg_default_vals
        ));

        // second, apply the setting
        for (let i = 0; i < this.auto_sl_cfg_names.length; i++) {
            const cfg_name = this.auto_sl_cfg_names[i];
            this.on_change_setting(cfg_name);
        }
        console.log('* reset cfg settings to default');
    },

    on_click_save_workspace_as_json: function() {
        // first, clear the setting panel
        this.cfg.enable_show_settings = false;

        // second, ask for file name
        var ret = window.prompt('Please specify the workspace name for saving. The output JSON file will be named as vpp_data_WORKSPACE.json. If the workspace name is not given, MedTator will use the schema name as the workspace name.');

        var ws_name = '';
        if (ret == '') {
            if (this.dtd == null) {
                app_hotpot.toast('No schema found for the current workspace.', 'warning');
                return;
            } else {
                ws_name = this.dtd.name;
            }
        } else {
            ws_name = ret;
        }

        jarvis.save_vpp_as(ws_name);
        app_hotpot.toast('Successfully saved workspace as ['+ws_name+']!');
    },
});

// extend the App with texts
/**
 * This is an extension for app_hotpot text contents
 */

Object.assign(app_hotpot, {
texts: {
    "sentence_splitting_algorithm": {
        title: 'Sentence Splitting Algorithm',
        html: `MedTator can display text content in different ways, which include a sentence-mode display.
To display the split sentences correctly, the original content must be tokenized in sentence level.
There are several different methods / algorithms for sentence tokenization, and these methods are implemented in different packages / libraries.
MedTator provides some options for selecting different methods.

<ul>
    <li>The default method is a simple splitting algorithm based on symbol detection. This algorithm will check each character in the given text and compare it with pre-defined schema. The result of this algorithm works for most of cases, and has great performance. </li>
    <li>The <b>Compromise NLP</b> method is implemented based on <a target="_blank" href="https://github.com/spencermountain/compromise">Compromise NLP library</a>. It provides APIs for sentence spliting and formating. For more information, its <a target="_blank" href="https://observablehq.com/@spencermountain/compromise-sentences"></a> provides more technical details.</li>
    <li>The <b>Wink NLP</b> method is based on <a target="_blank" href="https://winkjs.org/">WinkJS NLP library</a>.</li>
</ul>
`
    },

    "new_ui_for_ck": {
        title: "Enable showing Cohen's Kappa result",
        html: `This is a new module and it's under development. You can enable this for test.`
    },

    "new_ui_for_ea": {
        title: "Enable new UI for Error Analysis",
        html: `This is a new UI module error analysis and it's under development. You can enable this new UI for test.`
    },

    "new_ui_for_tk": {
        title: "Enable new UI for Toolkit",
        html: `This is a new module and it's under development. You can enable this new UI for test.`
    },

    "auto_save_current_ann": {
        title: "Enable auto-save function",
        html: "By enabling this feature, the annotation will be automatically saved while annotating. Everytime when users add/update/delete any tags in the current annotation file, MedTator will try to save the changes to local disk.<br>If the user doesn't grant the file permission yet, a dialog will be shown and no more dialog after the first one."
    },

    "linking_marks_selection": {
        title: 'Linking marks selection',
        html: `The marks shown in the tag editor can be linked with the selection with the concept list.
`
    },

    "razer_help_err_def": {
        title: 'Error Definition',
        html: `<p>Error definition describes how the error types are classified into categories. For exampel, 'Lexicon' and 'Syntactic' can be categorized as 'Linguistic'. </p>
<p>MedTator's error analysis module comes with a default error definition. You can use it directly, or you can customize your own error definition. </p>
<p>MedTator uses a simple format to organize error category, which is defined as a YAML format in the annotation schema or a seperate YAML file. For more information about the error definition format, please check our <a target='_blank' href='https://github.com/OHNLP/MedTator/wiki'>Wiki Page</a>.</p>
`
    },

    "razer_help_err_labels": {
        title: 'Error Labels',
        html: `<p>Error labels are assigned to each error tag (i.e., FP or FN tag) and MedTator will use this label information to visualize the error distribution.</p>
        <p>You can upload the error tag list with error labels for visualization. Or you can download the error tag list with empty labels for further external labeling.</p>
        <p>For more information about the error label format, please check our <a target='_blank' href='https://github.com/OHNLP/MedTator/wiki'>Wiki Page</a>.</p>
`
    },

    "avbrat_help_how_to_use": {
        title: 'How to use?',
        html: `<p>The <b><i class="fas fa-igloo"></i> Visualize</b> is designed to show the annotated tags and the context text of the current document. It supports the following features:</p>
        <ul>
            <li><b>Document visualization</b>: You can click the "<i class="fas fa-igloo"></i> Visualize" button or the "Visualize Whole Document" button to show the entire document and all of the annotated tags in the document.</li>
            <li><b>Selection visualization</b>: You can highlight a sentence or a paragraph, and then click the "<i class="fas fa-igloo"></i> Visualize" button or the "Visualize Selection" button to visualize the tags within the highlighted text.</li>
        </ul>
        <p>The visualization is implemented based on <a target='_blank' href='https://brat.nlplab.org/'>brat</a> visualization module. For more information, please visit <a target='_blank' href="https://github.com/OHNLP/MedTator/wiki">MedTator Wiki</a></p>`
    },

    "auto_sl_current_cfg": {
        title: "Auto Save/Load Configs",
        html: `<p>By enable this feature, MedTator can save some settings in <a href="">localStorage</a> while the user makes changes to default settings. When the user open MedTator next time, the settings will be automatically loaded from localStorage.</p>
        <p>Attention. At present, we only add those configs in "Settings" panel to this auto save/load feature. Other settings in tabs may be added in future.</p>
        <p>Due to the technical reasons, when loading samples, the settings would be overwritten by the configs in sample dataset.</p>`
    },

    "tk_medtaggervis_help": {
        title: "How to use MedTaggerVis",
        html: `
        <p>MedTaggerVis can help you to show the MedTagger output files (.ann) with the context text to explore the output results. You can visualize your MedTagger output as follows:
        </p>
        <ol>
            <li><b>Load raw text files</b>: Drop the folder containing .txt files to the first box.</li>
            <li><b>Load MedTagger output files</b>: Drop the folder containing .ann files to the second box. Please ensure the file names in the output folder match the file name in the raw text file folder. For example, an output file name "doc1.txt.ann" should have a raw text file named "doc1.txt" in the raw text folder.</li>
            <li><b>Visualize the result</b>: Click the file name in the output file list to show the visualized results.</li>
        </ol>
        <p>Known issues:</p>
        <ul>
            <li>Web Browser: due to the limitation of FileSystemAccess API in web browser, MedTaggerVis can only run on Chromium-based modern browsers.</li>
            <li>The number of files: the implementation of reading local files is different on different operating systems (e.g., Linux, MacOS, Windows, etc.). You may load a folder with up to 10,000 files to browse. </li>
            <li>The loading time: loading files depends on many factors, such as the file size and disk I/O speed, so the loading time varies from a few seconds to a few minutes.</li>
        </ul>
        <p>
            The visualization is implemented based on <a target='_blank' href='https://brat.nlplab.org/'>brat</a> visualization module. If you have any issues when using this function, please feel free to leave an issue report in <a target="_blank" href="https://github.com/OHNLP/MedTator/issues">MedTator Github Repo Issues</a> or contact our developers.
        </p>
`
    },

    "reset_to_default_settings": {
        title: "Reset to Default Settings",
        html: `
        <p>By clicking the 'Reset' button, MedTator will reset all settings to the default options.</p>
        <p>After reset, please reload/refresh the page to enable the default settings. Otherwise the current annotation may be affected.</p>
        `
    },

    "save_workspace_as_json": {
        title: "Save Workspace in JSON File",
        html: `
        <p><b>ALL</b> the data and settings in MedTator can be saved in a single JSON file for debug and share purpose. However, due to the limitation of HTML File System Access API, the loaded files in any tab (e.g., annotation tab, adjudication tab, error analysis, etc.) are NOT linked to their original location.</p>
        <p>The saved workspace JSON file is named as <b>vpp_data_XXXX.json</b>, where the XXXX is user-specified or the schema name. It can be loaded through the file list in annotation tab. </p>
        <p>You can drop the saved workspace JSON file in to the file list. MedTator will automatically detect the content and load the workspace.</p>
        `
    }
}});

// extend the App with codemirror editor
/**
 * This is an extension for code mirror related functions 
 */

Object.assign(app_hotpot, {
    cm_init: function() {
        // init the code mirror instance
        this.codemirror = CodeMirror(
            document.getElementById('cm_editor'), {
                lineNumbers: true,
                lineWrapping: true,
                readOnly: true,
                // readOnly: 'nocursor',
                // styleActiveLine: true,
                extraKeys: {"Alt-F": "find"}
            }
        );

        this.codemirror.on('contextmenu', function(inst, evt) {
            evt.preventDefault();

            // update the selection texts
            var selection = app_hotpot.cm_get_selection(inst);
            if (selection.sel_txts == '') {
                // if there is/are non-consuming tags
                // which makes it a document-level annotation
                // show the menu here
                if (app_hotpot.vpp.get_nc_etags().length>0) {
                    // show
                    var mouseX = evt.clientX;
                    var mouseY = evt.clientY;
                    app_hotpot.show_nce_ctxmenu(mouseX, mouseY);
                    return;

                } else {
                    // nothing selected and there is no NC etag
                    return;
                }

            }
            // show the menu
            var mouseX = evt.clientX;
            var mouseY = evt.clientY;
            app_hotpot.show_tag_ctxmenu(mouseX, mouseY);
        });
    },

    cm_set_ann: function(ann) {
        // make sure all clear
        // clear all etag markers
        this.cm_clear_etag_marks();

        // clear all link tags
        this.cm_clear_rtag_marks();

        // first, if ann is null, just remove everything in the editor
        if (ann == null) {
            this.codemirror.setValue('');
            return;
        }

        // if the current mode is 
        if (this.vpp.$data.cm.display_mode == 'document') {
            this.codemirror.setValue(
                ann.text
            );

        } else if (this.vpp.$data.cm.display_mode == 'sentences') {
            // update the sentences if not available
            if (ann._sentences_text == '') {
                ann = app_hotpot.update_ann_sentences(ann);
            }
            this.codemirror.setValue(
                ann._sentences_text
            );
        } else {
            this.codemirror.setValue('');
        }
    },

    cm_get_selection: function(inst) {
        if (typeof(inst) == 'undefined') {
            inst = this.codemirror;
        }
        // update the selection
        var selection = {
            sel_txts: inst.getSelections(),
            sel_locs: inst.listSelections()
        };
        this.selection = selection;
        // console.log("* found selection:", app_hotpot.selection);
        return selection;
    },

    cm_clear_selection: function(to_anchor=true) {
        var new_anchor = null;
        if (to_anchor) {
            new_anchor = this.selection.sel_locs[0].anchor;
        } else {
            new_anchor = this.selection.sel_locs[0].head;
        }
        this.codemirror.setSelection(new_anchor);
    },

    cm_make_basic_etag_from_selection: function() {
        var locs = [];
        var txts = [];

        // usually there is only one tag
        for (let i = 0; i < app_hotpot.selection.sel_locs.length; i++) {
            var sel_loc = app_hotpot.selection.sel_locs[i];
            var sel_txt = app_hotpot.selection.sel_txts[i];
            locs.push(
                app_hotpot.cm_range2spans(
                    sel_loc, 
                    this.vpp.$data.anns[this.vpp.$data.ann_idx]
                )
            );
            txts.push(sel_txt);
        }
        
        // now push new ann tag
        var tag = {
            'spans': locs.join(','),
            'text': txts.join(' ... ')
        };

        return tag;
    },

    cm_update_marks: function() {
        // clear all etag markers
        this.cm_clear_etag_marks();

        // clear all link tags
        this.cm_clear_rtag_marks();

        // update the hint marks
        this.cm_update_hint_marks();

        // update the tag marks
        this.cm_update_tag_marks();

        // force update UI, well ... maybe not work
        // this.vpp.$forceUpdate();

        console.log('* updated cm marks');
    },

    cm_clear_etag_marks: function() {
        var marks = this.codemirror.getAllMarks();
        for (let i = marks.length - 1; i >= 0; i--) {
            marks[i].clear();
        }
        console.log()
    },

    cm_clear_rtag_marks: function() {
        // first, check if there is a layer for the plots
        if ($('#cm_svg_plots').length == 0) {
            $('.CodeMirror-sizer').prepend(`
            <div class="CodeMirror-plots">
            <svg id="cm_svg_plots">
                <defs>
                    <marker id="arrow" viewBox="0 0 10 10" refX="5" refY="5"
                        markerWidth="6" markerHeight="6"
                        orient="auto-start-reverse">
                        <path d="M 0 0 L 10 5 L 0 10 z" />
                    </marker>
                </defs>
            </svg>
            </div>
        `);
        } else {
            $('#cm_svg_plots').html(`
                <defs>
                    <marker id="arrow" viewBox="0 0 10 10" refX="5" refY="5"
                        markerWidth="6" markerHeight="6"
                        orient="auto-start-reverse">
                        <path d="M 0 0 L 10 5 L 0 10 z" />
                    </marker>
                </defs>
            `);
        }
    },

    cm_update_hint_marks: function() {
        if (this.vpp.$data.ann_idx == null) {
            // nothing to do for empty
            return;
        }

        if (!this.vpp.$data.cm.enabled_hints ||
            this.vpp.$data.cm.hint_mode == 'off') {
            // nothing to do when turn off hint
            return;
        }

        if (this.vpp.$data.dtd == null) {
            // nothing to do if no dtd given
            return;
        }

        var focus_tags = null;
        if (app_hotpot.vpp.is_render_tags_of_all_concepts()) {

        } else {
            if (this.vpp.$data.display_tag_name == '__all__') {
                // search all tag
            } else {
                // ok, only search this tag
                focus_tags = [ this.vpp.$data.display_tag_name ];
            }
        }

        // find markable hints for this ann
        var hints = ann_parser.search_hints_in_ann(
            this.vpp.hint_dict,
            this.vpp.$data.anns[this.vpp.$data.ann_idx],
            focus_tags
        );
        console.log('* found hints', hints);

        // bind the hints to vpp
        this.vpp.$data.hints = hints;

        this.cm_mark_hints(hints);
    },

    cm_update_tag_marks: function() {
        const start = performance.now();
        if (this.vpp.$data.ann_idx == null) {
            // nothing to do for empty
            return;
        }

        // to ensure the link tag could be draw correctly,
        // draw the etags first
        this.cm_update_etag_marks();

        // since all etags have been rendered,
        // it's safe to render the link tags
        this.cm_update_rtag_marks();
        const duration = performance.now() - start;
        console.log('* marked tags in', duration);
    },

    cm_update_etag_marks: function() {
        const start = performance.now();
        if (this.vpp.$data.ann_idx == null) {
            // nothing to do for empty
            return;
        }

        // update the new marks
        var working_ann = this.vpp.$data.anns[this.vpp.$data.ann_idx];
        for (let i = 0; i < working_ann.tags.length; i++) {
            var tag = working_ann.tags[i];
            var tag_def = this.vpp.get_tag_def(tag.tag);
            if (tag_def.type == 'etag') {
                var ret = this.cm_mark_ann_etag_in_text(
                    tag, 
                    tag_def, 
                    working_ann
                );
                // console.log('* finished rendering', ret, tag);
            }
        }
        const duration = performance.now() - start;
        console.log('* marked etags in', duration);
    },

    cm_update_rtag_marks: function() {
        if (this.vpp.$data.ann_idx == null) {
            // nothing to do for empty
            return;
        }
        if (this.vpp.$data.cm.enabled_links) {
            // ok! show links
        } else {
            // well, if user doesn't want to show links,
            // it's ok
            return;
        }

        // update the new marks
        var working_ann = this.vpp.$data.anns[this.vpp.$data.ann_idx];
        for (let i = 0; i < working_ann.tags.length; i++) {
            var tag = working_ann.tags[i];
            var tag_def = this.vpp.get_tag_def(tag.tag);
            if (tag_def.type == 'rtag') {
                this.cm_mark_ann_rtag_in_text(tag, tag_def, working_ann);
            }
        }
    },

    cm_mark_hints: function(hints) {
        const start = performance.now();
        for (let i = 0; i < hints.length; i++) {
            const hint = hints[i];
            // console.log('* rendering hint', hint);
            this.cm_mark_hint_in_ann(
                hint,
                this.vpp.$data.anns[this.vpp.$data.ann_idx]
            );
        }
        const duration = performance.now() - start;
        console.log('* marked hints in', duration);
    },

    /**
     * Mark the hint in the code mirror
     * @param {object} hint it contains the range for rendering
     */
     cm_mark_hint_in_ann: function(hint, ann) {
        var range = this.cm_spans2range(hint.spans, ann);
        // console.log("* marking hint", hint, 'on', range);

        // a hover message
        var descr = [
            "" + hint.tag
        ].join('\n');
        
        if (this.vpp.$data.cm.mark_mode == 'node') {
            var hint_tag_id_prefix = dtd_parser.get_id_prefix(
                hint.tag, 
                this.vpp.$data.dtd
            );
            var markHTML = [
                '<span class="mark-hint mark-hint-'+hint.tag+'" id="mark-id-'+hint.id+'" onclick="app_hotpot.vpp.add_tag_by_hint(\''+hint.id+'\')" title="Click to add this to tags" data-descr="'+descr+'">',
                '<span class="mark-hint-info mark-tag-'+hint.tag+'">',
                    hint_tag_id_prefix,
                '</span>',
                '<span class="mark-hint-text" hint_id="'+hint.id+'">',
                    hint.text,
                '</span>',
                '</span>'
            ].join('');

            // convert this HTML to DOMElement
            var placeholder = document.createElement('div');
            placeholder.innerHTML = markHTML;
            var markNode = placeholder.firstElementChild;

            try {
                this.codemirror.markText(
                    range.anchor,
                    range.head,
                    {
                        className: 'mark-hint mark-hint-' + hint.tag,
                        replacedWith: markNode,
                        attributes: {
                            hint_id: hint.id,
    
                        }
                    }
                );
            } catch (error) {
                // sometimes, replacing DOM node may fail due to
                // Error: Inserting collapsed marker partially overlapping an existing one
                // so, just skip this for now
                console.error("! can't mark conflict hint", hint)
            }
            
        } else if (this.vpp.$data.cm.mark_mode == 'span') {
            
            this.codemirror.markText(
                range.anchor,
                range.head,
                {
                    className: 'mark-hint mark-hint-' + hint.tag,
                    attributes: {
                        hint_id: hint.id,
                        onclick: 'app_hotpot.vpp.add_tag_by_hint(\''+hint.id+'\')',
                        'data-descr': descr
                    }
                }
            );
        }
    },

    cm_mark_ann_tag_in_text: function(tag, tag_def, ann) {
        if (tag_def.type == 'etag') {
            return this.cm_mark_ann_etag_in_text(tag, tag_def, ann);
        } else {
            return this.cm_mark_ann_rtag_in_text(tag, tag_def, ann);
        }
    },

    cm_mark_ann_rtag_in_text: function(tag, tag_def, ann) {
        if (app_hotpot.vpp.is_render_tags_of_all_concepts()) {
            // ok, let's render all tags here
        } else {
            if (app_hotpot.vpp.is_display_tag_name(tag.tag)) {
                // ok
            } else {
                return [-1];
            }
        }

        this.cm_draw_rtag(tag, tag_def, ann);
    },

    cm_mark_ann_etag_in_text: function(tag, tag_def, ann) {
        var raw_spans = tag['spans'];
        // before rendering this tag
        // we need to check whether it should be rendered

        // 1. something wrong with the spans information?
        if (raw_spans == '' || raw_spans == null) { 
            return [-1]; 
        }

        // 2. document-level tag, nothing to do or render differently
        if (raw_spans == dtd_parser.NON_CONSUMING_SPANS) {
            return [-2];
        }

        // 3. is current setting to render all or only selected?
        if (app_hotpot.vpp.is_render_tags_of_all_concepts()) {
            // ok, nothing to worry, just render this tag
        } else {
            // is display this tag by the tag list filter?
            if (app_hotpot.vpp.is_display_tag_name(tag.tag)) {
                // ok
            } else {
                // the second case is quite complex.
                // to render the link tags,
                // the related entity tags are also needed to render
                // so the question is, is this tag belong to current link tag?
                if (app_hotpot.vpp.get_tag_def(app_hotpot.vpp.$data.display_tag_name).type == 'rtag') {
                    // only check this for only showing link tag.
                    // otherwise it will cost unnecessary computation
                    if (app_hotpot.vpp.is_tag_related_to_tag_name(
                        tag, 
                        [app_hotpot.vpp.$data.display_tag_name],
                        app_hotpot.vpp.$data.anns[app_hotpot.vpp.$data.ann_idx]
                    )) {
                        // ok, I don't which one, but it does belong to which link
                        // just goto render

                    } else {
                        // great, no need to render
                        return [-3];
                    }
                } else {
                    // great, no need to render
                    return [-4];
                }
            }
        }

        // the spans may contains multiple parts
        // split them first
        var spans_arr = raw_spans.split(',');
        var text_arr = tag.text.split('...');

        // hover message
        var descr = [
            "" + tag.tag + ' - ' + tag.id,
            "spans: " + tag.spans
        ];
        descr = descr.join('\n');
        
        // render every part of the spans
        for (let i = 0; i < spans_arr.length; i++) {
            const spans = spans_arr[i];
            const spans_text = text_arr[i];
            var range = this.cm_spans2range(spans, ann);

            if (this.vpp.$data.cm.mark_mode == 'node') {
                // the second step is to enhance the mark tag with more info
                var markHTML = [
                    '<span class="mark-tag mark-tag-'+tag.tag+'" '+
                        'id="mark-etag-id-'+tag.id+'" '+
                        'tag_id="'+tag.id+'" '+
                        'data-descr="'+descr+'" '+
                        'onmouseenter="app_hotpot.vpp.on_enter_tag(event)" '+
                        'onmouseleave="app_hotpot.vpp.on_leave_tag(event)">',
                    '<span onclick="app_hotpot.vpp.on_click_editor_tag(event, \''+tag.id+'\')">',
                    '<span class="mark-tag-info">',
                        '<span class="mark-tag-info-inline fg-tag-'+tag.tag+'">',
                        tag.id,
                        '</span>',
                    '</span>',
                    '<span class="mark-tag-text" tag_id="'+tag.id+'">',
                        spans_text,
                    '</span>',
                    '</span>',
                    '<span class="mark-tag-info-offset" title="Delete tag '+tag.id+'" onclick="app_hotpot.delete_tag(\''+tag.id+'\');">',
                        '<i class="fa fa-times-circle"></i>',
                    '</span>',
                    '</span>'
                ].join('');

                // convert this HTML to DOMElement
                var placeholder = document.createElement('div');
                placeholder.innerHTML = markHTML;
                var markNode = placeholder.firstElementChild;

                // add mark to text
                try {
                    this.codemirror.markText(
                        range.anchor,
                        range.head,
                        {
                            className: 'mark-tag mark-tag-' + tag.tag,
                            replacedWith: markNode,
                            attributes: {
                                tag_id: tag.id
                            }
                        }
                    );
                } catch (error) {
                    console.error("! can't mark conflict tag", tag)
                }

            } else if (this.vpp.$data.cm.mark_mode == 'span') {
                this.codemirror.markText(
                    range.anchor,
                    range.head,
                    {
                        className: 'mark-tag mark-tag-' + tag.tag + '',
                        attributes: {
                            id: 'mark-etag-id-' + tag.id,
                            tag_id: tag.id,
                            onclick: 'app_hotpot.vpp.on_click_editor_tag(event, \''+tag.id+'\')',
                            'data-descr': descr,
                            onmouseenter: 'app_hotpot.vpp.on_enter_tag(event)',
                            onmouseleave: 'app_hotpot.vpp.on_leave_tag(event)',
                        }
                    }
                );
                // add a cap of annotator for adjudication
                if (tag.hasOwnProperty('_annotator')) {
                    this.cm_draw_etag_cap(
                        tag, 
                        ann, 
                        tag._annotator.toLocaleUpperCase()
                    );
                }
            }
        }

        return [0];
    },

    cm_jump2tag: function(tag, ann) {
        // first, get the anchor location
        var range = this.cm_spans2range(
            tag.spans, ann
        );

        // set the anchor
        this.codemirror.doc.setCursor(
            range.anchor
        );
    },

    cm_spans2range: function(spans, ann) {
        // if the current mode is 
        if (this.vpp.$data.cm.display_mode == 'document') {
            return this.cm_doc_spans2range(spans, ann);

        } else if (this.vpp.$data.cm.display_mode == 'sentences') {
            return this.cm_sen_spans2range(spans, ann);

        } else {
            return this.cm_doc_spans2range(spans, ann);
        }
    },

    cm_range2spans: function(spans, ann) {
        // if the current mode is 
        if (this.vpp.$data.cm.display_mode == 'document') {
            return this.cm_doc_range2spans(spans, ann);

        } else if (this.vpp.$data.cm.display_mode == 'sentences') {
            return this.cm_sen_range2spans(spans, ann);

        } else {
            return this.cm_doc_range2spans(spans, ann);
        }
    },

    cm_sen_range2spans: function(sel_loc, ann) {
        var span0 = 0;

        // first, get the start span of this line
        var line_span0 = ann._sentences[
            sel_loc.anchor.line
        ].spans.start;
        var line_span1 = ann._sentences[
            sel_loc.head.line
        ].spans.start;

        // then move to the span of this line
        span0 = line_span0 + sel_loc.anchor.ch;
        span1 = line_span1 + sel_loc.head.ch;

        // the selection maybe from different direction
        if (span0 <= span1) {
            return span0 + '~' + span1;
        } else {
            return span1 + '~' + span0;
        }
    },

    cm_sen_spans2range: function(spans, ann) {
        var span_pos_0 = parseInt(spans.split('~')[0]);
        var span_pos_1 = parseInt(spans.split('~')[1]);

        // find the line number of span0
        var anchor = nlp_toolkit.find_linech(span_pos_0, ann._sentences);
        var head = nlp_toolkit.find_linech(span_pos_1, ann._sentences);

        return {
            anchor: anchor,
            head: head
        }
    },

    cm_doc_range2spans: function(sel_loc, ann) {
        var full_text = ann.text;
        // console.log('* calc doc range2spans: ');
        // console.log(sel_loc);
        var lines = full_text.split('\n');
        var span0 = 0;
        for (let i = 0; i < sel_loc.anchor.line; i++) {
            span0 += lines[i].length + 1;
        }
        span0 += sel_loc.anchor.ch;
        var span1 = 0;
        for (let i = 0; i < sel_loc.head.line; i++) {
            span1 += lines[i].length + 1;
        }
        span1 += sel_loc.head.ch;
        // console.log('* span0: ' + span0 + ', span1: ' + span1);

        if (span0 <= span1) {
            return span0 + '~' + span1;
        } else {
            return span1 + '~' + span0;
        }
    },

    cm_doc_spans2range: function(spans, ann) {
        var full_text = ann.text;

        // console.log('* calc doc spans2range: ');
        var span_pos_0 = parseInt(spans.split('~')[0]);
        var span_pos_1 = parseInt(spans.split('~')[1]);

        // calculate the line number
        var ln0 = full_text.substring(0, span_pos_0).split('\n').length - 1;
        var ln1 = full_text.substring(0, span_pos_1).split('\n').length - 1;

        // calculate the char location
        var ch0 = span_pos_0;
        
        // 2023-03-30: thanks to Riea's feedback!
        // when a file contains one and only one newline at the begining,
        // the ch0 cannot be calculated as the i==span_pos_0 is not reached
        // so need to set the loop end condition to i<=span_pos_0
        for (let i = 1; i <= span_pos_0; i++) {
            if (full_text[span_pos_0 - i] == '\n') {
                ch0 = i - 1;
                break;
            }
        }

        // TODO fix the potential cross lines bug
        var ch1 = ch0 + (span_pos_1 - span_pos_0);

        // return [ [ln0, ch0], [ln1, ch1] ];
        return {
            anchor: {line: ln0, ch: ch0},
            head:   {line: ln1, ch: ch1}
        }
    },

    cm_spans2coords: function(spans, ann) {
        var range = this.cm_spans2range(spans, ann);

        var coords_l = this.codemirror.charCoords(
            // { line: range[0][0], ch: range[0][1] },
            range.anchor,
            'local'
        );
        var coords_r = this.codemirror.charCoords(
            // { line: range[1][0], ch: range[1][1] },
            range.head,
            'local'
        );

        return { 
            l: coords_l, 
            r: coords_r 
        };
    },

    cm_draw_rtag: function(rtag, rtag_def, ann) {
        // for showing the rtag, we need:
        // 1. the atts for accessing the rtag
        // 2. the values of att_a and att_b, which are tag_id for etag
        // 3. get the tag, then call cm_draw_polyline

        // so, get all attrs
        var atts = this.vpp.get_idref_attrs(rtag_def);

        // next, get the values fron this rtag
        var etags = [];
        for (let i = 0; i < atts.length; i++) {
            var att = atts[i];
            var etag_id = rtag[att.name];

            if (typeof(etag_id) == 'undefined' || 
                etag_id == null || 
                etag_id == '') {
                // this att is just empty
                continue;
            }

            // check this etag
            var etag = this.vpp.get_tag_by_tag_id(etag_id, ann);
            if (etag == null) { 
                continue; 
            }
            if (etag.spans == dtd_parser.NON_CONSUMING_SPANS) {
                continue;
            }

            // ok, save this etag for later use
            etags.push(etag);
        }
        // then, check if there are more than two etags
        console.log('* found ' + etags.length + ' etags available for this link');

        // first, draw dots
        // for (let i = 0; i < etags.length; i++) {
        //     const etag = etags[i];
        //     this.cm_draw_rtag_on_etag(rtag, etag, ann);
        // }

        if (!this.vpp.$data.cm.enabled_link_complex) {
            return;
        }

        // second, draw polyline
        if (etags.length < 2) {
            // which means not enough etag for drawing line
            return;
        }
        var tag_a = etags[0];
        var tag_b = etags[1];

        console.log(
            '* try to draw line ['+rtag.id+'] between', 
            '['+tag_a.id+']-', 
            '['+tag_a.id+']'
        );

        // last, draw!
        this.cm_draw_polyline(
            rtag, tag_a, tag_b, ann
        );
    },

    cm_draw_etag_cap: function(etag, ann, cap) {
        // then get the coords
        var coords = this.cm_spans2coords(etag.spans, ann);
        // console.log('* found etag coords:', coords);

        // the basic x is just the tag left position
        var x = coords.l.left;
        // the basic y is a little higher
        var y = coords.l.top + 2.5;

        // find existing cap on this tag if there is
        // var tagcaps = $('#cm_svg_plots .tag-cap-' + etag.id);
        // for (let i = 0; i < tagcaps.length; i++) {
        //     const elem = tagcaps[i];
        //     var shape = this.get_elem_shape(elem);
        //     x += shape.width + 1;
        // }
        // find the relative x
        // var el = document.querySelector('#mark-etag-id-' + etag.id);
        // x = el.offsetLeft;

        // make a cap for this etag
        var svg_text = document.createElementNS(
            'http://www.w3.org/2000/svg', 'text'
        );
        svg_text.setAttribute('id', 'mark-tag-cap-id-' + etag.id);
        svg_text.setAttribute('text-anchor', 'left');
        svg_text.setAttribute('alignment-baseline', 'middle');
        svg_text.setAttribute('x', x);
        svg_text.setAttribute('y', y);
        svg_text.setAttribute('class', 
            "tag-cap border-tag-" + etag.tag + 
            " tag-cap-id-" + etag.id +
            " tag-cap-" + cap
        );
        // put the text in this cap
        var text_node_content = cap;
        svg_text.append(document.createTextNode(text_node_content));

        $('#cm_svg_plots').append(
            svg_text
        );
    },

    cm_draw_rtag_on_etag: function(rtag, tag, ann) {
        // then get the coords
        var coords = this.cm_spans2coords(tag.spans, ann);
        // console.log('* found etag coords:', coords);

        // the basic x is just the tag left position
        var x = coords.l.left;
        // move to middle
        x += (coords.l.right - coords.l.left) / 2 + 1;

        // the basic y is a little higher
        var y = coords.l.top + 2;

        // find existing linkdot on this tag if there is
        var linkdots = $('#cm_svg_plots .tag-linkdot-' + tag.id);

        // add offset to x
        for (let i = 0; i < linkdots.length; i++) {
            const elem = linkdots[i];
            var shape = this.get_elem_shape(elem);
            x += shape.width + 1;
        }

        // make a text
        var svg_text = document.createElementNS(
            'http://www.w3.org/2000/svg', 'text'
        );
        svg_text.setAttribute('id', 'mark-link-dot-id-' + rtag.id + '-' + tag.id);
        svg_text.setAttribute('text-anchor', 'left');
        svg_text.setAttribute('alignment-baseline', 'middle');
        svg_text.setAttribute('x', x);
        svg_text.setAttribute('y', y);
        svg_text.setAttribute('class', "tag-linkdot border-tag-" + tag.tag + " tag-linkdot-" + tag.id);

        // put the text
        var text_node_content = " ";
        if (this.vpp.$data.cm.enabled_link_name) {
            text_node_content = " " + rtag.id;
        }
        svg_text.append(document.createTextNode(text_node_content));

        $('#cm_svg_plots').append(
            svg_text
        );

        // this.make_svg_text_bg(svg_text, 'svgmark-tag-' + rtag.tag);
    },

    cm_draw_polyline: function(rtag, tag_a, tag_b, ann) {
        // then get the coords of both tags
        var coords_a = this.cm_spans2coords(tag_a.spans, ann);
        var coords_b = this.cm_spans2coords(tag_b.spans, ann);

        // the setting for the polyline
        var delta_height = 2;
        var delta_width = 0;

        // get the upper coords, which is the lower one
        var upper_top = coords_a.l.top < coords_b.l.top ? 
            coords_a.l.top : coords_b.l.top;
        upper_top = upper_top - delta_height;

        // get the sign for relative location
        var sign = coords_b.l.left - coords_a.l.left > 0 ? 1 : -1;

        // then calc the points for the polyline
        var xys = [
            // point, start
            [
                (coords_a.l.left + coords_a.r.left)/2,
                (coords_a.l.top + 4)
            ],
            // point joint 1
            [
                (coords_a.l.left + coords_a.r.left)/2 + sign * delta_width,
                upper_top
            ],
            // point, joint 2
            [
                ((coords_b.l.left + coords_b.r.left)/2 - sign * delta_width),
                upper_top
            ],
            // point, end
            [
                (coords_b.l.left + coords_b.r.left)/2,
                (coords_b.l.top + 3)
            ]
        ];

        // put all points togather
        var points = [];
        for (let i = 0; i < xys.length; i++) {
            const xy = xys[i];
            // convert to int for better display
            var x = Math.floor(xy[0]);
            var y = Math.floor(xy[1]);
            points.push(x + ',' + y);
        }

        // convert to a string
        points = points.join(' ');

        // create a poly line and add to svg
        // Thanks to the post!
        // https://stackoverflow.com/questions/15980648/jquery-added-svg-elements-do-not-show-up
        var svg_polyline = document.createElementNS(
            'http://www.w3.org/2000/svg', 'polyline'
        );
        svg_polyline.setAttribute('id', 'mark-link-line-id-' + rtag.id);
        svg_polyline.setAttribute('points', points);
        svg_polyline.setAttribute('class', "tag-polyline");
        // svg_polyline.setAttribute('marker-end', "url(#arrow)");

        $('#cm_svg_plots').append(
            svg_polyline
        );

        // NEXT, draw a text
        var svg_text = document.createElementNS(
            'http://www.w3.org/2000/svg', 'text'
        );
        svg_text.setAttribute('id', 'mark-link-text-id-' + rtag.id);
        svg_text.setAttribute('text-anchor', 'middle');
        svg_text.setAttribute('alignment-baseline', 'middle');
        svg_text.setAttribute('x', (xys[0][0] + xys[3][0]) / 2);
        svg_text.setAttribute('y', xys[1][1] + delta_height);
        svg_text.setAttribute('class', "tag-linktext");

        // put the text
        var text_node_content = rtag.id;
        // if (this.vpp.$data.cm.enabled_link_name) {
        //     text_node_content = rtag.tag + ': ' + rtag.id;
        // }
        svg_text.append(document.createTextNode(text_node_content));

        $('#cm_svg_plots').append(
            svg_text
        );

        // then create a background color
        this.make_svg_text_bg(svg_text, 'svgmark-tag-' + rtag.tag);
    },

    cm_calc_points: function(coords_a, coords_b) {

    },



    cm_highlight_editor_tag: function(tag_id) {
        // get this tag in editor
        var elm = $('#mark-etag-id-' + tag_id);
        if (elm.length != 1) {
            // which means no such element
            return; 
        }
        var flag_actived = elm.hasClass('mark-tag-active');

        // remove other class
        $('.mark-tag-active').removeClass('mark-tag-active');

        // add a class to this dom
        if (flag_actived) {

        } else {
            elm.addClass('mark-tag-active');
        }
    },

    // cm_draw_rtag_first_two: function(rtag, rtag_def, ann) {
    //     // for showing the polyline, we need:
    //     // 1. the att_a and att_b for accessing the rtag
    //     // 2. the values of att_a and att_b, which are tag_id for etag
    //     // 3. get the tag, then call cm_draw_polyline

    //     // so, get the att_a and att_b first
    //     var att_a = this.vpp.get_idref_attr_by_seq(rtag_def, 0);
    //     var att_b = this.vpp.get_idref_attr_by_seq(rtag_def, 1);

    //     // next, get the values
    //     var etag_a_id = rtag[att_a.name];
    //     var etag_b_id = rtag[att_b.name];
    //     // console.log(
    //     //     '* try to draw line ['+rtag.id+'] between', 
    //     //     att_a.name, '['+etag_a_id+']-', 
    //     //     att_b.name, '['+etag_b_id+']'
    //     // );

    //     // if the value is null or empty, just skip
    //     if (etag_a_id == null || etag_a_id == '') { return; }
    //     if (etag_b_id == null || etag_b_id == '') { return; }

    //     // convert the tag_id to tag
    //     var tag_a = this.vpp.get_tag_by_tag_id(etag_a_id, ann);
    //     var tag_b = this.vpp.get_tag_by_tag_id(etag_b_id, ann);

    //     // if the tag is not available, just skip
    //     if (tag_a == null || tag_b == null) { return; }

    //     // if one of the tags is non-consuming tag, just skip
    //     if (tag_a.spans == dtd_parser.NON_CONSUMING_SPANS ||
    //         tag_b.spans == dtd_parser.NON_CONSUMING_SPANS) {
    //         return;
    //     }

    //     // last, draw!
    //     this.cm_draw_polyline(
    //         rtag, tag_a, tag_b, ann
    //     );
    // },
});

// extend the App with statistics
Object.assign(app_hotpot.vpp_methods, {
    update_whole_hint_dict: function() {
        // app_hotpot.update_hint_dict_by_anns();
        if (this.anns.length == 0) {
            this.hint_dict = {};
            return;
        }
        var hint_dict = ann_parser.anns2hint_dict(
            this.dtd, 
            this.anns
        );
        this.hint_dict = hint_dict;
        console.log('* updated hint_dict by anns', this.hint_dict);
    },

    download_stat_summary: function() {
        var json = [];

        var stat_items = stat_helper.get_stat_items(
            this.anns,
            this.dtd
        );

        for (let i = 0; i < stat_items.length; i++) {
            const stat_item = stat_items[i];
            json.push({
                item: stat_item[0],
                result: stat_item[1]
            });
        }

        // then convert the json to csv
        var csv = Papa.unparse(json, {
        });

        // download this csv
        var blob = new Blob([csv], {type: "text/tsv;charset=utf-8"});
        var fn = this.get_ruleset_base_name() + '-statistics.csv';
        saveAs(blob, fn);
    },

    download_stat_details: function() {
        // create each sheet 
        // sheet 1. the summary
        var ws_summary = stat_helper.get_stat_summary_excelws(
            stat_helper.get_stat_items(
                this.anns,
                this.dtd
            )
        );

        // sheet 2. the tags
        var ws_docbtag = stat_helper.get_stat_docs_by_tags_excelws(
            this.anns,
            this.dtd
        );

        // create the wb for download
        var wb = {
            SheetNames: [
                "Summary",
                "Documents"
            ],
            Sheets: {
                Summary: ws_summary,
                Documents: ws_docbtag
            }
        };
        console.log(wb);

        // decide the file name for this export
        var fn = this.dtd.name + '-annotation-statistics.xlsx';

        // download this wb
        XLSX.writeFile(wb, fn);
    },

    sort_text_dict_in_hint_dict: function(text_dict) {
        var text_info_list = [];
        for (const text in text_dict) {
            if (Object.hasOwnProperty.call(text_dict, text)) {
                const dict = text_dict[text];
                text_info_list.push({
                    text: text,
                    // that's what we want to sort
                    count: dict.count
                });
            }
        }

        // sort desc
        text_info_list.sort(function(a, b) {
            return b.count - a.count;
        });

        return text_info_list;
    },

    reset_stat_filters: function() {
        // reset stat_filter_min_tokens
        this.stat_filter_min_tokens = 0;
    },

    count_texts_by_stat_fileter: function(tag_def) {
        var cnt = 0;
        
        for (const text in this.hint_dict[tag_def.name].text_dict) {
            // count each text
            if (this.stat_filter_min_tokens == 0 || this.hint_dict[tag_def.name].text_dict[text].count <= this.stat_filter_min_tokens) {
                cnt += 1;
            }
        }
        return cnt;
    },

    on_change_stat_filters: function() {

    },
});

// extend the App with exporter
Object.assign(app_hotpot.vpp_methods, {
    get_ruleset_base_name: function() {
        var fn = this.dtd.name + '-' + this.anns.length;
        return fn;
    },

    download_text_tsv: function() {
        var fn = this.get_ruleset_base_name() + '_text.tsv';
        var txt_tsv = nlp_toolkit.download_text_tsv(
            this.anns,
            this.dtd,
            this.hint_dict,
            fn
        );

        // update the text
        this.export_text = txt_tsv;
    },

    download_text_sent_tsv: function() {
        var fn = this.get_ruleset_base_name() + '_text_sentence.tsv';
        
        var tsv = nlp_toolkit.download_sentence_tsv(
            this.anns,
            this.dtd,
            fn
        );

        // update the text
        this.export_text = tsv;
    },
    
    download_dataset_iob2: function() {
        var txt_dataset = nlp_toolkit.download_dataset_bio(
            this.anns,
            this.dtd,
            'dataset-' + this.get_ruleset_base_name() + '-BIO.zip'
        );

        // update the text
        this.export_text = txt_dataset;
    },

    download_dataset_bioc: function() {
        var txt_dataset = bioc_parser.download_dataset_bioc(
            this.anns,
            this.dtd,   
            'dataset-' + this.get_ruleset_base_name() + '-BioC.xml'
        );

        // update the text
        this.export_text = txt_dataset;
    },

    download_ruleset_medtagger_zip: function() {
        var rulepack = erp_toolkit.download_anns_as_zip(
            this.anns,
            this.dtd,
            'ruleset-medtagger-' + this.get_ruleset_base_name() + '.zip'
        );

        // update the text
        this.export_text = "Please unzip the file and check details";
    },

    download_ruleset_spacy_jsonl: function() {
        var text = spacy_toolkit.download_anns_as_jsonl(
            this.anns,
            this.dtd,
            'ruleset-spacy-' + this.get_ruleset_base_name() + '.jsonl'
        );

        // update the text
        this.export_text = text;
    },
});

// extend the App with IAA
/**
 * This is an extension for IAA calculator 
 */

/////////////////////////////////////////////////////////////////
// IAA related variables
/////////////////////////////////////////////////////////////////
Object.assign(app_hotpot.vpp_data, {
    // for iaa
    iaa_ann_list: [
        {anns: [], name: 'A'}, // for annotator A
        {anns: [], name: 'B'}, // for annotator B
    ],

    // loading status
    // null: nothing
    // 0: loading iaa a
    // 1: loading iaa b
    iaa_loading_status: null,

    // iaa results
    iaa_dict: null,

    // display which tag(concept)
    iaa_display_tag_name: '__all__',

    // match entity by overlap or exact match?
    iaa_match_mode: 'overlap', // overlap / exact
    iaa_overlap_ratio: 50,
    iaa_overlap_ratio_default: 50,

    // result display settings
    iaa_display_hashcode: null,
    iaa_display_tags_context: true,
    iaa_display_tags_tp: false,
    iaa_display_adj_panel: true,
    iaa_display_adj_detail: false,

    // sort anns
    // - default: how the anns are imported into tool
    // - a.alphabet: A-Z
    // - a.alphabet_r: Z-A
    // - a.tags: 0-N
    // - a.tags_r: N-0
    iaa_sort_anns_by: 'default',

    // for iaa adjudication
    iaa_gs_dict: null,

    // for using attributes in IAA
    iaa_use_attributes: false,

    // remove the tag when low_overlap for calcuting
    // this can remove the duplicated results in FN
    // so the IAA calculation result will be different
    // the 
    iaa_remove_tag_b_when_low_overlap: true,

    // for using attributes in IAA a selection map
    // {
    //    tag_name: {
    //        attr_name: true / false
    //    }
    // }
    iaa_use_tag_attrs: {},

    // for IAA display mode, show F1 or other indicators
    iaa_display_measure: 'f1',
});


/////////////////////////////////////////////////////////////////
// IAA related functions
/////////////////////////////////////////////////////////////////
Object.assign(app_hotpot, {
    
});

Object.assign(app_hotpot.vpp_methods, {
    clear_iaa_all: function(which) {
        if (typeof(which) == 'undefined') {
            which = null;
        }
        // clear everything related to iaa
        if (which == null || which == 0) {
            // just clear a
            this.iaa_ann_list[0].anns = [];
        }
        if (which == null || which == 1) {
            // just clear b
            this.iaa_ann_list[1].anns = [];
        }

        this.iaa_dict = null;
        this.iaa_gs_dict = null;

        this.iaa_display_tag_name = '__all__';
        this.iaa_display_hashcode = null;
    },

    on_drop_dropzone_iaa: function(event, iaa_id) {
        // stop the download event
        event.preventDefault();
        const items = event.dataTransfer.items;

        // set loading status
        this.iaa_loading_status = iaa_id;

        // set loading iaa_id
        var promise_files = fs_get_file_texts_by_items(
            items,
            // only accept xml for iaa
            function(fn) {
                if (app_hotpot.is_file_ext_xml(fn)) {
                    return true;
                }
                return false;
            }
        );
        promise_files.then(function(files) {
            app_hotpot.vpp.add_files_to_iaa_anns(files, iaa_id);
        });
    },

    add_files_to_iaa_anns: function(files, iaa_id) {
        console.log('* adding '+files.length+' files to iaa anns ' + iaa_id);
        for (let i = 0; i < files.length; i++) {
            const file = files[i];
            var ann = app_hotpot.parse_file2ann(
                file,
                this.dtd
            );

            // it is possible that something wrong
            if (ann == null) {
                continue;
            }

            // save this ann
            this.iaa_ann_list[iaa_id].anns[
                this.iaa_ann_list[iaa_id].anns.length
            ] = ann;
        }

        // done
        this.iaa_loading_status = null;
    },

    calc_iaa: function() {
        var iaa_dict = iaa_calculator.evaluate_anns_on_dtd(
            this.dtd,
            this.iaa_ann_list[0].anns,
            this.iaa_ann_list[1].anns,
            this.iaa_match_mode,
            this.iaa_overlap_ratio / 100,
            this.iaa_use_attributes?
                this.iaa_use_tag_attrs:
                null,
            this.iaa_remove_tag_b_when_low_overlap
        );
        this.iaa_dict = iaa_dict;
        console.log('* iaa result:', iaa_dict);

        // and create
        this.make_iaa_gs_dict();
    },

    iaa_sort_filelist_by: function(sort_by) {
        this.iaa_sort_anns_by = sort_by;
    },

    iaa_get_sort_by: function() {
        if (this.hasOwnProperty('iaa_sort_anns_by')) {
            return this.iaa_sort_anns_by;
        } else {
            return 'default';
        }
    },
    
    iaa_get_sort_by_label: function(sort_by) {
        return {
            'default': 'Sort',
            'label': 'Label',
            'f1_asc': 'F1 0-1',
            'f1_desc': 'F1 1-0',

            // for A
            'a.alphabet': 'A|A-Z',
            'a.alphabet_r': 'A|Z-A',

            // for B
            'b.alphabet': 'B|A-Z',
            'b.alphabet_r': 'B|Z-A',
        }[sort_by];
    },

    iaa_sort_v_anns: function(iaa_dict) {
        var sort_by = this.iaa_get_sort_by();

        // a virtual list of ann, just contain the file name
        // this is prepared for sorting only
        // because the sort is an in-place sort
        // we can't modify the order in the original anns
        var v_anns = [];
        for (const ann_hashcode in iaa_dict.ann) {
            const ann_rst = iaa_dict.ann[ann_hashcode];
            v_anns.push({
                // hashtag
                ann_hashcode: ann_hashcode,

                // the f1
                f1: this.iaa_display_tag_name == '__all__'? 
                    ann_rst.rst.all.f1 : ann_rst.rst.tag[this.iaa_display_tag_name].f1,

                // number of annotated tags
                ann_a: {
                    _filename: ann_rst.anns[0]._filename
                },
                ann_b: {
                    _filename: ann_rst.anns[1]._filename
                }
            });
        }

        // now sort
        if (sort_by == 'default') {
            return v_anns;

        } else if (sort_by == 'f1_asc') {
            console.log('* sorting f1_asc', isNaN(0));
            v_anns.sort(function(a, b) {
                var v = (isNaN(a.f1)?0:a.f1) - (isNaN(b.f1)?0:b.f1);
                return v;
            });
            return v_anns;

        } else if (sort_by == 'f1_desc') {
            console.log('* sorting f1_desc', isNaN(NaN));
            v_anns.sort(function(a, b) {
                var v = (isNaN(b.f1)?0:b.f1) - (isNaN(a.f1)?0:a.f1);
                return v;
            });
            return v_anns;

        } else if (sort_by == 'a.alphabet') {
            v_anns.sort(function(a, b) {
                return a.ann_a._filename.localeCompare(
                    b.ann_a._filename
                )
            });
            return v_anns;

        } else if (sort_by == 'a.alphabet_r') {
            v_anns.sort(function(a, b) {
                return -a.ann_a._filename.localeCompare(
                    b.ann_a._filename
                )
            });
            return v_anns;
            
        } else if (sort_by == 'b.alphabet') {
            v_anns.sort(function(a, b) {
                return a.ann_b._filename.localeCompare(
                    b.ann_b._filename
                )
            });
            return v_anns;

        } else if (sort_by == 'b.alphabet_r') {
            v_anns.sort(function(a, b) {
                return -a.ann_b._filename.localeCompare(
                    b.ann_b._filename
                )
            });
            return v_anns;
            
        } else {
            return v_anns;
        }
    },

    get_rst: function(obj) {
        if (this.iaa_display_tag_name == '__all__') {
            return obj.all;
        } else {
            return obj.tag[this.iaa_display_tag_name];
        }
    },

    on_change_iaa_settings: function(event) {
        console.log('* changed attr in', event.target);
        
    },

    on_change_iaa_use_attributes: function(event) {
        console.log('* changed iaa_use_attributes=', this.iaa_use_attributes);

        // update the settings of iaa_use_tag_attrs
        if (this.dtd == null) {
            return;
        }

        if (Object.keys(this.iaa_use_tag_attrs).length != 0) {
            // which means this has been inited
            return;
        }

        this.init_iaa_use_tag_attrs();
    },

    init_iaa_use_tag_attrs: function() {
        // update the values
        for (const tag_name in this.dtd.tag_dict) {
            if (Object.hasOwnProperty.call(this.dtd.tag_dict, tag_name)) {
                const tag = this.dtd.tag_dict[tag_name];
                this.iaa_use_tag_attrs[tag_name] = {};

                // update all the attributes
                for (let i = 0; i < tag.attrs.length; i++) {
                    const att = tag.attrs[i];
                    // set all to true
                    this.iaa_use_tag_attrs[tag_name][att.name] = true;
                }
            }
        }
    },

    set_iaa_display_measure: function(m) {
        this.iaa_display_measure = m;
    },

    set_all_iaa_use_tag_attrs: function(selection) {
        for (const tag_name in this.iaa_use_tag_attrs) {
            if (Object.hasOwnProperty.call(this.iaa_use_tag_attrs, tag_name)) {
                const tag_attrs = this.iaa_use_tag_attrs[tag_name];
                for (const att_name in tag_attrs) {
                    if (Object.hasOwnProperty.call(tag_attrs, att_name)) {
                        this.iaa_use_tag_attrs[tag_name][att_name] = selection;
                    }
                }
            }
        }

        // due to deep update, need to update manually
        this.$forceUpdate();
    },

    toggle_iaa_tag_attrs: function(tag_name, att_name) {
        if (this.iaa_use_tag_attrs.hasOwnProperty(tag_name)) {
            if (this.iaa_use_tag_attrs[tag_name].hasOwnProperty(att_name)) {
                this.iaa_use_tag_attrs[tag_name][att_name] = 
                    !this.iaa_use_tag_attrs[tag_name][att_name];
            }
        }
        // console.log('* set iaa_use_tag_attrs['+tag_name+']['+att_name+']='+this.iaa_use_tag_attrs[tag_name][att_name]);

        // due to deep update, need to update manually
        this.$forceUpdate();
    },

    transfer_to_annotation_tab: function() {
        // confirm first if there are annotations
        var len = app_hotpot.vpp.$data.anns.length;
        if (len > 0) {
            var msg = 'There are ' + len + ' documents in your annotation tab. Editing adjudication copy needs to remove those documents. Are you sure to continue?';
            var ret = app_hotpot.confirm(msg);
            if (ret) {

            } else {
                // ok, let's stop
                return;
            }
        }

        // check iaa_gs_dict status
        if (this.iaa_gs_dict == null) {
            // OK, nothing to do with an empty iaa_gs_dict

            // maybe say something?
            app_hotpot.msg('Adjudication copy is not found', 'warning');
            return;
        }

        // convert the current gs dict
        var gs_list = Object.values(
            this.iaa_gs_dict
        );

        // then create ann list for update
        var anns = [];

        // check each item in this iaa_gs
        for (let i = 0; i < gs_list.length; i++) {
            const gs = gs_list[i];

            // create a new ann
            var ann = gs.ann;

            // copy the rst of initial 
            for (const tag_name in gs.rst) {
                if (Object.hasOwnProperty.call(gs.rst, tag_name)) {
                    const r = gs.rst[tag_name];
                    // check each cm, fn, fp, and tp
                    for (const cm in r) {
                        if (Object.hasOwnProperty.call(r, cm)) {
                            const ds = r[cm];
                            for (let j = 0; j < ds.length; j++) {
                                const d = ds[j];

                                // it's possible that this decision have been removed
                                if (d == null) {
                                    continue;
                                }
                                // there are two attributes:
                                // from: a or b
                                // tag: the tag itself
                                // copy a new one
                                var tag = JSON.parse(JSON.stringify(d.tag));

                                // then need to update the id?
                                var etag_def = this.get_tag_def(tag_name);
                                if (etag_def == null) {
                                    // what????
                                } else {
                                    var new_tag_id = ann_parser.get_next_tag_id(
                                        ann,
                                        etag_def
                                    );
                                    tag.id = new_tag_id;
                                }

                                // update the tag info for annotator
                                if (cm == 'tp') {
                                    // which means this tag is agreed by both
                                    tag._annotator = 'AB';
                                } else {
                                    // which means this tag is added by A or B
                                    // or they don't have an agreement
                                    tag._annotator = d.from;
                                }

                                // save this tag
                                ann.tags.push(tag);
                            }
                        }
                    }
                }
            }
            
            anns.push(ann);
        }

        // replace 
        this.set_ann_idx(null);
        this.anns = [];

        // set to span tag mode
        this.cm.mark_mode = 'span';

        // bind the ann
        this.anns = anns;

        // update the UI
        this.ann_idx = 0;

        // switch to ann tab
        this.switch_mui('annotation');
    },

    make_iaa_gs_dict: function() {
        this.iaa_gs_dict = iaa_calculator.get_default_gs_dict(
            this.dtd, this.iaa_dict
        );
    },

    get_new_xml_filename: function(fn, ext='.xml') {
        var prefix = this.txt_xml_prefix.trim();
        var suffix = this.txt_xml_suffix.trim();
        var new_fn = fn;

        // add prefix
        if (prefix == '') {
            // nothing to do
        } else {
            new_fn = prefix + '_' + new_fn;
        }

        // add suffix
        if (suffix == '') {
            // nothing to do
            new_fn = new_fn + ext;
        } else {
            new_fn = new_fn + '_' + suffix + ext;
        }

        return new_fn;
    },

    get_new_xmls_zipfile_folder_name: function() {
        var fn = this.dtd.name + '-' + this.txt_anns.length;
        fn = this.get_new_xml_filename(fn, '');
        return fn + '-xmls';
    },

    download_gs_file: function(hashcode) {
        // get this gs
        const ann_rst = this.iaa_gs_dict[hashcode];
        
        // change to an ann obj
        var ann = iaa_calculator.make_ann_by_rst(
            ann_rst, 
            this.dtd
        );

        // get the xmlText
        var xml_doc = ann_parser.ann2xml(ann, this.dtd);
        var xml_text = ann_parser.xml2str(xml_doc);

        // download this xml
        var blob = new Blob([xml_text], {type: "text/xml;charset=utf-8"});
        var fn = ann_rst.ann._filename;
        saveAs(blob, fn);            
    },

    download_all_gs: function() {
        // create an empty zip pack
        var zip = new JSZip();
        var folder_name = this.get_gs_zipfile_folder_name();

        // add files to zip pack
        for (const hashcode in this.iaa_gs_dict) {
            if (Object.hasOwnProperty.call(this.iaa_gs_dict, hashcode)) {
                const ann_rst = this.iaa_gs_dict[hashcode];
                
                // change to an ann obj
                var ann = iaa_calculator.make_ann_by_rst(
                    ann_rst, 
                    this.dtd
                );

                // get the xmlText
                var xml_doc = ann_parser.ann2xml(ann, this.dtd);
                var xml_text = ann_parser.xml2str(xml_doc);

                // put this xml in folder (virtually)
                var ffn = folder_name + '/' + ann._filename;
                
                // put this xml to zip
                zip.file(ffn, xml_text);
            }
        }

        // create zip file
        zip.generateAsync({ type: "blob" }).then(function (content) {
            saveAs(
                content, 
                app_hotpot.vpp.get_new_xmls_zipfile_folder_name() + 
                '-' +
                app_hotpot.vpp.get_date_now() + 
                '.zip'
            );
        });
    },

    download_all_iaa_anns: function() {
        // create an empty zip pack
        var zip = new JSZip();
        var folder_name = this.get_gs_zipfile_folder_name() + '_ALL';

        // add files to zip pack
        for (const hashcode in this.iaa_gs_dict) {
            if (Object.hasOwnProperty.call(this.iaa_gs_dict, hashcode)) {
                const ann_rst = this.iaa_gs_dict[hashcode];
                const ann_iaa = this.iaa_dict.ann[hashcode];
                
                // change to an ann obj
                var ann = iaa_calculator.make_ann_by_iaa(
                    ann_rst, 
                    ann_iaa,
                    this.dtd
                );

                // get the xmlText
                var xml_doc = ann_parser.ann2xml(ann, this.dtd);
                var xml_text = ann_parser.xml2str(xml_doc);

                // put this xml in folder (virtually)
                var ffn = folder_name + '/' + ann._filename;
                
                // put this xml to zip
                zip.file(ffn, xml_text);
            }
        }

        // create zip file
        zip.generateAsync({ type: "blob" }).then(function (content) {
            saveAs(
                content, 
                app_hotpot.vpp.get_new_xmls_zipfile_folder_name() + 
                '-' +
                app_hotpot.vpp.get_date_now() + 
                '-ALL.zip'
            );
        });
    },

    export_iaa_report: function() {
        
        // // Acquire Data (reference to the HTML table)
        // var table_elt = document.getElementById("table_cohen_kappa_confusion_matrix");

        // // Extract Data (create a workbook object from the table)
        // var workbook = XLSX.utils.table_to_book(table_elt);

        // // Process Data (add a new row)
        // var ws_cohen = workbook.Sheets["Sheet1"];

        // create each sheet
        // sheet 1. the summary
        // var ws_summary = XLSX.utils.json_to_sheet([{'a':1}]);
        var ws_summary = iaa_calculator.get_iaa_report_summary_excelws(
            this.iaa_dict,
            this.dtd
        );

        // sheet 1.1 the cohen's kappa
        var ws_cohen = iaa_calculator.get_iaa_report_cohen_kappa_excelws(
            this.iaa_dict,
            this.dtd
        );

        // sheet 2. the files
        // var ws_files = XLSX.utils.json_to_sheet([{'a':1}]);
        var ws_files = iaa_calculator.get_iaa_report_files_excelws(
            this.iaa_dict,
            this.dtd
        );

        // sheet 3. the tags
        // var ws_tags = XLSX.utils.json_to_sheet([{'a':1}]);
        var ws_tags = iaa_calculator.get_iaa_report_tags_excelws(
            this.iaa_dict,
            this.dtd
        );

        // sheet 4. the adjudication
        var ws_adj = iaa_calculator.get_iaa_report_adjudication_excelws(
            this.iaa_dict,
            this.dtd
        );

        // create wb for download
        var wb = {
            SheetNames: [
                "F1-Score",
                "Cohen Kappa",
                "Files",
                "Tags",
                "Adjudication"
            ],
            Sheets: {
                "F1-Score": ws_summary,
                "Cohen Kappa": ws_cohen,
                Files: ws_files,
                Tags: ws_tags,
                Adjudication: ws_adj
            }
        };
        console.log(wb);

        // decide the file name for this export
        var fn = this.dtd.name + '-iaa-report.xlsx';

        // download this wb
        XLSX.writeFile(wb, fn);
    },

    get_gs_zipfile_folder_name: function() {
        return this.dtd.name + '-goldstandards';
    },

    count_gs_tags: function(ann_hashcode) {
        if (this.iaa_display_tag_name == '__all__') {
            return this.count_iaa_gs_notnull(this.iaa_gs_dict[ann_hashcode]);
        } else {
            return this.count_iaa_gs_tag_notnull(
                this.iaa_gs_dict[ann_hashcode].rst[this.iaa_display_tag_name]
            );
        }
    },

    count_iaa_gs_notnull: function(ann_rst) {
        var cnt = 0;
        for (const tag_name in ann_rst.rst) {
            if (Object.hasOwnProperty.call(ann_rst.rst, tag_name)) {
                const tag_rst = ann_rst.rst[tag_name];
                cnt += this.count_iaa_gs_tag_notnull(tag_rst);
            }
        }
        return cnt;
    },

    count_iaa_gs_tag_notnull: function(tag_rst) {
        var cnt = 0;
        for (const cm in tag_rst) {
            if (Object.hasOwnProperty.call(tag_rst, cm)) {
                const tags = tag_rst[cm];
                
                for (let i = 0; i < tags.length; i++) {
                    if (tags[i] != null) {
                        cnt += 1;
                    }
                }
            }
        }
        return cnt;
    },

    accept_iaa_tag: function(hashcode, tag_name, cm, tag_idx, from) {
        console.log('* accept', hashcode, tag_name, cm, tag_idx, from);
        this.iaa_gs_dict[hashcode].rst[tag_name][cm][tag_idx] = {
            tag: this.iaa_dict.ann[hashcode].rst.tag[tag_name].cm.tags[cm][tag_idx][
                {'A':0, 'B':1}[from]
            ],
            from: from
        };
        this.force_module_update = Math.random();
    },

    reject_iaa_tag: function(hashcode, tag_name, cm ,tag_idx) {
        console.log('* reject', hashcode, tag_name, cm, tag_idx);
        this.iaa_gs_dict[hashcode].rst[tag_name][cm][tag_idx] = null;
        this.force_module_update = Math.random();
    },

    count_tags_in_anns: function(anns) {
        return iaa_calculator.count_tags_in_anns(anns);
    },
});

// extend the App with error analysis
/**
 * This is an extension for the error analysis in app_hotpot
 */

/////////////////////////////////////////////////////////////////
// Error Analysis related variables
/////////////////////////////////////////////////////////////////
Object.assign(app_hotpot.vpp_data, {

    // loading files 
    // null: not loading
    // any number: loading
    razer_loading_status: null,

    // input data 1 and 2
    // for holding the uploaded anns
    razer_ann_list: [
        // the first one must be the GSC
        { anns: [], name: 'Gold Standard Corpus' },
        // others follow the same structure
        { anns: [], name: 'Dataset 1' }
    ],

    // input data 3 (optional)
    // the err def for analysis
    razer_err_def: null,
    razer_err_def_dict: {
        shortcut: {},
        adv_def: {}
    },

    // input data 3 (optional)
    // the err labels
    razer_err_labels_file: null,

    // for all razer information
    // the structure looks like:
    // {
    //     // this is the result of dataset 1
    //     // it's a err_dict
    //     1: {
    //         err_stat: {},
    //         err_dict: { uid: {} },
    //         iaa_dict: { }, // same iaa_dict
    //     },
    //     2: {}
    // },
    // 
    // we don't want to save extra information here
    razer_dict: null,

    // by default, just use the first dataset
    // the rid is this razer id or resource id
    razer_idx: 1,

    // show panel for add label
    is_shown_razer_pan_err_def: false,
    razer_active_err_uid: null,
    razer_pan_err_def_right: 0,
    razer_pan_err_def_top: 0,

    // flag for showing tsne
    razer_flag_has_embedding_tsne: false,

    // flag for showing the details in tag list
    razer_flag_show_taglist_context: true,

    // flag for showing the labels in tag list
    razer_flag_show_taglist_labels: true,

    // the fig obj for sankey
    razer_fig_sankey: null,

    // the fig obj for pie
    razer_fig_donut: null,

    // the fig obj for doc distribution
    razer_fig_doc_scatter: null,

    // the fig obj for doc heatmap
    razer_fig_doc_heatmap: null,

    // the fig obj for tag scatter
    razer_fig_tag_scatter: null,
    razer_fig_tag_scatter_clr: 'by_err',

    // the uids for checking
    razer_err_list_uids: null,

    // the EA service url
    razer_ea_ws_url: 'http://localhost:8808/eva_tags',

    // the TE service url
    razer_te_ws_url: 'http://localhost:8809/embedding'
});


/////////////////////////////////////////////////////////////////
// Error Analysis related functions
/////////////////////////////////////////////////////////////////
Object.assign(app_hotpot.vpp_computed, {
    razer_err_def_info: function() {
        return error_analyzer.get_stat_of_err_def(
            this.razer_err_def
        );
    },

    razer_err_tag_top_10: function() {
        return error_analyzer.get_top_10_tokens(
            this.razer_dict[this.razer_idx].err_stat.by_txt
        );
    }
});

Object.assign(app_hotpot.vpp_methods, {

    set_razer_err_def: function(err_def) {
        this.razer_err_def = err_def;
    },

    get_razer_rst: function() {
        if (this.razer_dict == null) {
            return null;
        } else {
            return this.razer_dict[this.razer_idx];
        }
    },

    get_razer_err: function(uid) {
        var rr = this.get_razer_rst();
        if (rr == null) {
            return null;
        }
        if (rr.err_dict.hasOwnProperty(uid)) {
            return rr.err_dict[uid];
        }
        return null;
    },

    get_razer_n_stat_by_err_type: function(err_type, err) {
        var stat = this.get_razer_stat_by_err_type(err_type, err);

        if (stat == null) {
            return null;
        } else {
            return stat.length;
        }
    },

    get_razer_stat_by_err_type: function(err_type, err) {
        var rr = this.get_razer_rst();
        if (rr == null) {
            return null;
        }
        if (!rr.err_stat.by_err.hasOwnProperty(err_type)) {
            return null;
        }

        // err is FP or FN
        if (typeof(err)=='undefined') {
            return rr.err_stat.by_err[err_type].FP.concat(
                rr.err_stat.by_err[err_type].FN
            );
        }
        return rr.err_stat.by_err[err_type][err];
    },

    clear_razer_all: function() {
        // clear input
        this.razer_ann_list = [
            // the first one must be the GSC
            { anns: [], name: 'Gold Standard Corpus' },
            // others follow the same structure
            { anns: [], name: 'Dataset 1' }
        ];
        this.razer_err_labels_file = null;

        // clear data
        this.razer_idx = 1;
        this.razer_dict = null;
        this.razer_err_def = null;
        if (this.razer_fig_sankey != null) {
            this.razer_fig_sankey.clear();
            this.razer_fig_sankey = null;
        }
    },

    on_drop_dropzone_razer: function(event, rid) {
        // stop the download event
        event.preventDefault();
        const items = event.dataTransfer.items;

        // set loading status
        this.razer_loading_status = rid;

        // set loading rid
        var promise_files = fs_get_file_texts_by_items(
            items,
            // only accept xml for iaa
            function(fn) {
                if (app_hotpot.is_file_ext_xml(fn)) {
                    return true;
                }
                return false;
            }
        );
        promise_files.then(function(files) {
            app_hotpot.vpp.add_files_to_razer_anns(files, rid);
        });
    },

    add_files_to_razer_anns: function(files, rid) {
        console.log('* adding '+files.length+' files to razer anns ' + rid);
        // it's possible that the `rid` slot is not ready
        if (this.razer_ann_list.length <= rid) {
            this.razer_ann_list.push({
                anns: [],
                name: 'Dataset ' + rid
            });
        }
        for (let i = 0; i < files.length; i++) {
            const file = files[i];
            var ann = app_hotpot.parse_file2ann(
                file,
                this.dtd
            );

            // it is possible that something wrong
            if (ann == null) {
                continue;
            }

            // save this ann
            this.razer_ann_list[rid].anns[
                this.razer_ann_list[rid].anns.length
            ] = ann;
        }

        // done and set loading finished
        this.razer_loading_status = null;
    },

    on_drop_dropzone_razer_err_def: function(event) {
        // stop the download event
        event.preventDefault();
        const items = event.dataTransfer.items;
        
        // set loading status
        this.razer_loading_status = Math.random();

        // set loading rid
        var promise_files = fs_get_file_texts_by_items(
            items,
            // only accept xml for iaa
            function(fn) {
                if (app_hotpot.is_file_ext_yaml(fn)) {
                    return true;
                }
                return false;
            }
        );
        promise_files.then(function(files) {
            // for error labels, just use one file?
            app_hotpot.vpp.set_file_to_razer_err_def(files[0]);
        });
    },

    set_file_to_razer_err_def: function(file) {
        var tmp = null;
        try {
            tmp = jsyaml.load(file.text);

        } catch (error) {
            console.log('* invalid YAML content');
            return null;
        }

        this.set_razer_err_def(tmp);
        this.razer_loading_status = null;
    },

    on_drop_dropzone_razer_err_labels: function(event) {
        // stop the download event
        event.preventDefault();
        const items = event.dataTransfer.items;
        
        // set loading status
        this.razer_loading_status = Math.random();

        // set loading rid
        var promise_files = fs_get_file_texts_by_items(
            items,
            // only accept xml for iaa
            function(fn) {
                if (app_hotpot.is_file_ext_json(fn)) {
                    return true;
                }
                return false;
            }
        );
        promise_files.then(function(files) {
            // for error labels, just use one file?
            app_hotpot.vpp.set_file_to_razer_err_labels(files[0]);
        });
    },

    set_file_to_razer_err_labels: function(file) {
        var obj = JSON.parse(file.text);

        this.razer_err_labels_file = {
            _fh: file.fh,
            tags: obj.tags
        };

        // done and set loading finished
        this.razer_loading_status = null;
    },

    on_click_razer_load_err_labels: function() {

    },

    parse_razer_files: function() {
        var is_reparse = false;
        if (this.razer_dict != null) {
            // which means there is something analyzed
            var ret = app_hotpot.confirm(
                'Re-Analyze will overwrite ALL of the existing error labels. You can save the current first before doing this. Are you sure to continue?'
            );

            if (ret) {
                // OK, just re-parse everything
                is_reparse = true;
            } else {
                return;
            }
        }

        // first, get the IAA result 
        var iaa_dict = iaa_calculator.evaluate_anns_on_dtd(
            this.dtd,
            // using 1 as dataset for eva
            this.razer_ann_list[1].anns,
            // using 0 as GSC
            this.razer_ann_list[0].anns,
            'overlap',
            iaa_calculator.default_overlap_ratio,
            null,
            true
        );

        // second, get the err_dict and doc_dict
        var err_doc = iaa_calculator.get_iaa_error_tags(
            iaa_dict,
            this.dtd
        );

        // then, check if the error definition
        if (this.razer_err_def == null) {
            this.razer_err_def = JSON.parse(JSON.stringify(
                error_analyzer.DEFAULT_ERROR_DEF
            ));
        }

        // add UNKNOWN for err_def
        this.razer_err_def[error_analyzer.UNK_ERROR_CATE] = [error_analyzer.UNK_ERROR_TYPE];

        // add mapping for shortcut keys
        var shortcut = 1;
        for (const err_cate in this.razer_err_def) {
            this.razer_err_def_dict.shortcut[shortcut] = err_cate;
            shortcut += 1;
        }

        // add color mapping
        var err_cate_clr_idx = 0;
        for (const err_cate in this.razer_err_def) {
            if (err_cate == 'UNK') {
                this.razer_err_def_dict.adv_def[err_cate] = {
                    level: 'category',
                    category: null,
                    types: ['UNKNOWN'],
                    color: '#999999'
                }
            } else {
                this.razer_err_def_dict.adv_def[err_cate] = {
                    level: 'category',
                    category: null,
                    types: this.razer_err_def[err_cate],
                    color: error_analyzer.ERROR_COLOR_SCHEMA[err_cate_clr_idx].c_cate
                };
            }
            // add color for each type
            for (let i = 0; i < this.razer_err_def[err_cate].length; i++) {
                var err_type = this.razer_err_def[err_cate][i];
                if (err_type == 'UNKNOWN') {
                    this.razer_err_def_dict.adv_def[err_type] = {
                        level: 'type',
                        category: 'UNK',
                        types: null,
                        color: '#999999'
                    }
                } else {
                    this.razer_err_def_dict.adv_def[err_type] = {
                        level: 'type',
                        category: err_cate,
                        types: null,
                        color: error_analyzer.ERROR_COLOR_SCHEMA[err_cate_clr_idx].c_type[i]
                    };
                }
            }
            err_cate_clr_idx += 1;
        }

        // then, check if there is tags
        // a flag for indicating if there is embedding for tsne?
        var razer_flag_has_embedding_tsne = false;
        if (this.razer_err_labels_file != null) {
            // ok, let's use the given labels to update err
            for (let i = 0; i < this.razer_err_labels_file.tags.length; i++) {
                const t = this.razer_err_labels_file.tags[i];
                if (t.hasOwnProperty('errors')) {
                    // oh, this tag doesn't have error labels,
                    // just skip it
                    // now let's check if there is a same uid tag
                    if (err_doc.err_dict.hasOwnProperty(t.uid)) {
                        // great! let's update this uid
                        err_doc.err_dict[t.uid]['errors'] = t.errors;
                    }
                }

                // add embedding if any
                if (t.hasOwnProperty('embedding_tsne')) {
                    razer_flag_has_embedding_tsne = true;
                    if (err_doc.err_dict.hasOwnProperty(t.uid)) {
                        // great! let's update this uid
                        err_doc.err_dict[t.uid]['embedding_tsne'] = t.embedding_tsne;
                    }
                }
            }
        }

        // then, get the stat
        var err_stat = error_analyzer.get_err_stat(
            iaa_dict,
            err_doc.err_dict,
            this.dtd
        );

        // last, set to razer_dict
        if (this.razer_dict == null) {
            this.razer_dict = {};
        }

        // update the razer_dict for data
        this.razer_dict[
            this.razer_idx
        ] = {
            iaa_dict: iaa_dict,
            err_dict: err_doc.err_dict,
            doc_dict: err_doc.doc_dict,
            err_stat: err_stat
        };

        // update flag
        this.razer_flag_has_embedding_tsne = razer_flag_has_embedding_tsne;

        // draw?
        this.update_plots();

        // force update if re-parse
        if (is_reparse) {
            this.$forceUpdate();
        }
    },

    update_razer_dict_stats: function() {
        // then, get the stat
        var err_stat = error_analyzer.get_err_stat(
            this.razer_dict[this.razer_idx].iaa_dict,
            this.razer_dict[this.razer_idx].err_dict,
            this.dtd
        );

        // just update stats
        this.razer_dict[
            this.razer_idx
        ].err_stat = err_stat;

        // draw?
        this.update_plots();
    },

    update_plots: function() {
        // this.draw_razer_fig_donut();
        this.draw_razer_fig_sankey();
        // this.draw_razer_fig_doc_scatter();
        this.draw_razer_fig_doc_heatmap();
        this.draw_razer_fig_tag_scatter();
    },

    /////////////////////////////////////////////////////////////////
    // Sankey related functions
    /////////////////////////////////////////////////////////////////
    draw_razer_fig_sankey: function() {
        var data_sankey = error_analyzer.get_sankey_data(
            this.get_razer_rst().err_stat.by_rel,
            this.razer_err_def_dict
        );
        console.log('* got data for sankey diagram', data_sankey);

        if (this.razer_fig_sankey == null) {
            // make a new sankey figure
            this.razer_fig_sankey = figmker_sankey.make_fig(
                'razer_sankey_diagram'
            );
            this.razer_fig_sankey.headers = [
                'Error',
                'Error Category',
                'Error Type',
                'Concept'
            ]

            // bind click events
            this.razer_fig_sankey.on_click_node = this.on_click_razer_sankey_node;
            this.razer_fig_sankey.on_click_link = this.on_click_razer_sankey_link;

            // init!
            this.razer_fig_sankey.init();
        }

        this.razer_fig_sankey.draw(data_sankey);
    },

    on_click_razer_sankey_node: function(event, d) {
        console.log('* clicked node', event, d);
        this.show_uids_in_razer_err_list(
            d.uids,
            null
        );
    },

    on_click_razer_sankey_link: function(event, d) {
        console.log('* clicked link', event, d);
        this.show_uids_in_razer_err_list(
            d.uids,
            null
        );
    },

    draw_razer_fig_donut: function() {
        if (this.razer_fig_donut != null) {
            // ??
        }

        // init the chart
        this.razer_fig_donut = {
            option: {
                // grid: {
                //     top: 10,
                //     left: 10,
                //     right: 10,
                //     bottom: 10
                // },
                color: [
                    '#EDC4B3',
                    '#E6B8A2',
                    '#DEAB90',
                    '#D69F7E',
                    '#CD9777',
                    '#C38E70',
                    '#B07D62',
                    '#9D6B53',
                    '#8A5A44',
                    '#774936',
                ],
                tooltip: {
                    trigger: 'item',
                },
                legend: {
                    show: false,
                },
                series: [
                    {
                        name: '',
                        type: 'pie',
                        radius: ['60%', '95%'],
                        avoidLabelOverlap: false,
                        label: {
                            show: false,
                            position: 'center'
                        },
                        emphasis: {
                            label: {
                                show: true,
                                fontSize: '14',
                                fontWeight: 'bold'
                            }
                        },
                        labelLine: {
                            show: false
                        },
                        data: [
                            { value: 1048, name: 'Search Engine' },
                            { value: 735, name: 'Direct' },
                            { value: 580, name: 'Email' },
                            { value: 484, name: 'Union Ads' },
                            { value: 300, name: 'Video Ads' }
                        ]
                    }
                ]
            },
            chart: echarts.init(
                // the default box_id starts with #
                document.getElementById('razer_donut_chart')
            )
        };

        // draw it
        this.razer_fig_donut.chart.setOption(this.razer_fig_donut.option);
    },

    draw_razer_fig_doc_scatter: function() {
        // prepare data first

        // get data
        var data = [];
        var stat = this.razer_dict[this.razer_idx].err_stat.by_doc;
        var max_xy = 5;
        for (const file_hash in stat) {
            var x = stat[file_hash].FP.length;
            var y = stat[file_hash].FN.length;
            if (x > max_xy) {max_xy = x;}
            if (y > max_xy) {max_xy = y;}
            data.push([
                x, y, file_hash
            ]);
        }

        // then check figure status
        if (this.razer_fig_doc_scatter != null) {
            // ??
            this.razer_fig_doc_scatter.option.series[0].data = data;
            this.razer_fig_doc_scatter.chart.setOption(
                this.razer_fig_doc_scatter.option
            );
            return;
        }

        // init the chart
        this.razer_fig_doc_scatter = {
            option: {
                grid: {
                    top: 10,
                    left: 35,
                    right: 10,
                    bottom: 35
                },
                xAxis: {
                    type: 'value',
                    max: max_xy,
                    name: 'False Positive',
                    nameLocation: 'center',
                    nameGap: 20
                },
                yAxis: {
                    type: 'value',
                    max: max_xy,
                    name: 'False Negative',
                    nameLocation: 'center',
                    nameGap: 20
                },
                tooltip: {
                    trigger: 'item',
                    // to avoid CSS z-index overlay issue
                    renderMode: 'richText',
                    formatter: function(params) {
                        // console.log('* hover at', params);
                        var html = [
                            // '<h6>' + params.data[2] + '</h6>',
                            // '<p>- FP Tags: ' + params.data[0] + '<br>', 
                            // '- FN Tags: ' + params.data[1] + '</p>'
                            '' + params.data[2] + '\n',
                            '- FP Tags: ' + params.data[0] + '\n', 
                            '- FN Tags: ' + params.data[1]
                        ].join('');
                        return html;
                    }
                },
                legend: {
                    show: false,
                },
                series: [{
                    name: 'File',
                    type: 'scatter',
                    symbolSize: 5,
                    labelLine: {
                        show: false
                    },
                    data: data
                }]
            },
            chart: echarts.init(
                // the default box_id starts with #
                document.getElementById('razer_fig_doc_scatter')
            )
        };

        // draw it
        this.razer_fig_doc_scatter.chart.setOption(
            this.razer_fig_doc_scatter.option
        );
    },

    draw_razer_fig_doc_heatmap: function() {
        // prepare data first

        // get data 
        // please ensure Math.js is imported
        var vals = {};
        var stat = this.razer_dict[this.razer_idx].err_stat.by_doc;
        for (const file_hash in stat) {
            var x = stat[file_hash].FP.length;
            var y = stat[file_hash].FN.length;
            
            // resize to 10x10
            var _x = x;
            var _y = y;
            if (_x > 10) { _x = 10; };
            if (_y > 10) { _y = 10; };
            
            if (!vals.hasOwnProperty(_x)) {
                vals[_x] = {};
            }
            if (!vals[_x].hasOwnProperty(_y)) {
                vals[_x][_y] = [];
            }
            vals[_x][_y].push(file_hash);
        }
        console.log(vals);
        // get all values
        var data = [];
        var max_n = 10;
        for (let i = 0; i < 11; i++) {
            for (let j = 0; j < 11; j++) {
                if (vals.hasOwnProperty(i) && vals[i].hasOwnProperty(j)) {
                    data.push([
                        i,
                        j,
                        vals[i][j].length
                    ]);
                    if (vals[i][j].length > max_n) {
                        max_n = vals[i][j].length;
                    }
                } else {
                    data.push([
                        i,
                        j,
                        '-'
                    ]);
                }
            }
        }

        // then check figure status
        if (this.razer_fig_doc_heatmap != null) {
            // ??
            this.razer_fig_doc_heatmap.option.series[0].data = data;
            this.razer_fig_doc_heatmap.chart.setOption(
                this.razer_fig_doc_heatmap.option
            );
            return;
        }
        
        var axis_labels = Array.from(Array(11).keys()).map(v=>''+v);
        axis_labels[10] = '10+';
        // init the chart
        this.razer_fig_doc_heatmap = {
            data: data,
            option: {
                grid: {
                    top: 0,
                    left: 35,
                    right: 0,
                    bottom: 80
                },
                visualMap: {
                    min: 0,
                    max: max_n,
                    calculable: true,
                    itemWidth: 15,
                    itemHeight: 180,
                    orient: 'horizontal',
                    left: 30,
                    bottom: 0
                },
                xAxis: {
                    type: 'category',
                    data: axis_labels,
                    name: 'False Positive',
                    nameLocation: 'center',
                    nameGap: 20,
                    axisLabel: {
                        interval: 0,
                    },
                    splitArea: {
                        show: true
                    }
                },
                yAxis: {
                    type: 'category',
                    data: axis_labels,
                    name: 'False Negative',
                    nameLocation: 'center',
                    nameGap: 20,
                    axisLabel: {
                        interval: 0,
                    },
                    splitArea: {
                        show: true
                    }
                },
                tooltip: {
                    trigger: 'item',
                    // to avoid CSS z-index overlay issue
                    renderMode: 'richText',
                    formatter: function(params) {
                        // console.log('* hover at', params);
                        var html = [
                            // '<h6>' + params.data[2] + '</h6>',
                            // '<p>- FP Tags: ' + params.data[0] + '<br>', 
                            // '- FN Tags: ' + params.data[1] + '</p>'
                            '' + params.data[2] + ' file(s) have:\n',
                            '- FP Tags: ' + params.data[0] + '\n', 
                            '- FN Tags: ' + params.data[1]
                        ].join('');
                        return html;
                    }
                },
                legend: {
                    show: false,
                },
                series: [{
                    name: 'File',
                    type: 'heatmap',
                    label: {
                        show: true
                    },
                    data: data,
                    emphasis: {
                        itemStyle: {
                            shadowBlur: 10,
                            shadowColor: 'rgba(0, 0, 0, 0.5)'
                        }
                    }
                }]
            },
            chart: echarts.init(
                // the default box_id starts with #
                document.getElementById('razer_fig_doc_heatmap')
            )
        };

        // draw it
        this.razer_fig_doc_heatmap.chart.setOption(
            this.razer_fig_doc_heatmap.option
        );
    },

    

    draw_razer_fig_tag_scatter: function() {
        // prepare data first
        if (!this.razer_flag_has_embedding_tsne) {
            // if no embedding data, just skip
            return;
        }

        // get data
        var data = [];
        var err_dict = this.razer_dict[this.razer_idx].err_dict;
        for (const uid in err_dict) {
            var x = err_dict[uid].embedding_tsne[0];
            var y = err_dict[uid].embedding_tsne[1];
            var color = {FP: '#F98686', FN: '#56B3F6'}[err_dict[uid]._judgement];

            if (this.razer_fig_tag_scatter_clr == 'by_err') {
                // nothing
            } else if (this.razer_fig_tag_scatter_clr == 'by_err_cate') {
                if (err_dict[uid].hasOwnProperty('errors') && 
                    err_dict[uid].errors.length > 0) {
                    color = this.razer_err_def_dict.adv_def[
                        err_dict[uid].errors[0].category
                    ].color;
                } else {
                    color = this.razer_err_def_dict.adv_def.UNK.color;
                }
            } else if (this.razer_fig_tag_scatter_clr == 'by_err_type') {
                if (err_dict[uid].hasOwnProperty('errors') && 
                    err_dict[uid].errors.length > 0) {
                    color = this.razer_err_def_dict.adv_def[
                        err_dict[uid].errors[0].type
                    ].color;
                } else {
                    color = this.razer_err_def_dict.adv_def.UNKNOWN.color;
                }
            } else if (this.razer_fig_tag_scatter_clr == 'by_concept') {
                color = this.dtd.tag_dict[
                    err_dict[uid].tag
                ].style.color
            } 
            data.push([
                x, y, uid, color
            ]);
        }

        // then check figure status
        if (this.razer_fig_tag_scatter != null) {
            this.razer_fig_tag_scatter.option.series[0].data = data;
            this.razer_fig_tag_scatter.chart.setOption(
                this.razer_fig_tag_scatter.option
            );
            return;
        }

        // init the chart
        this.razer_fig_tag_scatter = {
            data: data,
            option: {
                grid: {
                    top: 10,
                    left: 25,
                    right: 10,
                    bottom: 25
                },
                toolbox: {
                    feature: {
                        dataZoom: {},
                        brush: {
                            type: ['rect', 'polygon', 'clear']
                        }
                    }
                },
                brush: {},
                xAxis: {
                    type: 'value',
                },
                yAxis: {
                    type: 'value',
                },
                tooltip: {
                    trigger: 'item',
                    // to avoid CSS z-index overlay issue
                    renderMode: 'richText',
                    formatter: function(params) {
                        // console.log('* hover at', params);
                        var tag = app_hotpot.vpp.get_razer_err(params.data[2]);
                        var html = [
                            '' + tag.text + '\n',
                            '* Concept: ' + tag.tag, 
                        ].join('');
                        return html;
                    }
                },
                legend: {
                    show: false,
                },
                series: [{
                    name: 'Tag',
                    type: 'scatter',
                    symbolSize: 5,
                    labelLine: {
                        show: false
                    },
                    itemStyle: {
                        color: function(params) {
                            return params.data[3];
                        }
                    },
                    data: data
                }]
            },
            chart: echarts.init(
                // the default box_id starts with #
                document.getElementById('razer_tag_scatter')
            ),

            // for interaction
            selected_indices: []
        };

        // draw it
        this.razer_fig_tag_scatter.chart.setOption(
            this.razer_fig_tag_scatter.option
        );

        // bind event
        this.razer_fig_tag_scatter.chart.on('brushSelected', function(params) {
            var brushComponent = params.batch[0];
            // console.log('* brush selected:', brushComponent);

            // get all indices
            var selected_indices = [];
            for (var seriesIdx = 0; seriesIdx < brushComponent.selected.length; seriesIdx++) {
                var dataIndices = brushComponent.selected[seriesIdx].dataIndex;
                for (var i = 0; i < dataIndices.length; i++) {
                    var dataIndex = dataIndices[i];
                    selected_indices.push(dataIndex);
                }
            }

            // bind to app_hotpot
            app_hotpot.vpp.$data
                .razer_fig_tag_scatter
                .selected_indices = selected_indices;
        });
    },

    on_change_razer_fig_tag_scatter_color_encoding: function(event) {
        // event.target.value
        this.draw_razer_fig_tag_scatter();
    },

    close_razer_pan_err_def: function() {
        this.is_shown_razer_pan_err_def = false;
        this.razer_active_err_uid = null;
    },

    show_razer_pan_err_def_for_uid: function(event, uid) {
        // set the working uid
        this.razer_active_err_uid = uid;

        // get mouse position
        var x = event.clientX;
        var y = event.clientY;

        this.razer_pan_err_def_right = 5;

        var new_top = y - 110;
        if (new_top + $('#razer_pan_err_def').height() > $('#main_ui').height()) {
            new_top = $('#main_ui').height() - $('#razer_pan_err_def').height() - 1;
        }
        this.razer_pan_err_def_top = new_top;

        // ok, show it
        this.is_shown_razer_pan_err_def = true;
    },

    show_uids_in_razer_err_list: function(uids1, uids2) {
        // empty the current list
        // this.razer_err_list_uids = [];

        if (uids1 == null) {
            if (uids2 == null) {

            } else {
                this.razer_err_list_uids = uids2;
            }
        } else {
            if (uids2 == null) {
                this.razer_err_list_uids = uids1;

            } else {
                this.razer_err_list_uids = uids1.concat(uids2);
            }
        }
    },

    get_html_sentag_by_err: function(err) {
        var tag = err.tag;
        var txt = err.text;
        var sen = err.sentence;

        var colored_txt = '<span class="clr-black mark-tag-' + tag + '">' + 
            txt + 
            '</span>';

        var html = sen.replace(txt, colored_txt);

        return '<span>' + html + '</html>';
    },

    add_razer_err_label: function(err_cate, err_type, uid) {
        var rr = this.get_razer_rst();
        if (rr == null) {
            return null;
        }

        // ok, let's check errors label
        if (!rr.err_dict[uid].hasOwnProperty('errors')) {
            rr.err_dict[uid]['errors'] = [];
        }

        // add this tag?
        rr.err_dict[uid]['errors'].push({
            category: err_cate,
            type: err_type
        });

        // close?
        this.close_razer_pan_err_def();

        // update UI?
        this.update_razer_dict_stats();
    },

    remove_razer_err_label: function(uid, e_idx) {
        this.razer_dict[this.razer_idx].err_dict[uid].errors.splice(e_idx, 1);

        // update UI?
        this.update_razer_dict_stats();
        this.$forceUpdate();

        console.log('* removed error label for ' + uid);
    },

    set_razer_err_labels: function(uid, errors, is_update_ui) {
        if (typeof(is_update_ui) == 'undefined') {
            is_update_ui = false;
        }
        this.razer_dict[this.razer_idx].err_dict[uid]['errors'] = errors;

        if (is_update_ui) {
            this.update_razer_dict_stats();
            this.$forceUpdate();
        }
    },

    set_razer_err_embedding: function(uid, embedding, is_update_ui) {
        if (typeof(is_update_ui) == 'undefined') {
            is_update_ui = false;
        }
        this.razer_dict[this.razer_idx].err_dict[uid]['embedding_tsne'] = embedding

        if (is_update_ui) {
            this.update_razer_dict_stats();
            this.$forceUpdate();
        }
    },

    update_razer_ui: function() {
        this.update_razer_dict_stats();
        this.$forceUpdate();
    },

    download_razer_err_labels: function() {
        var obj = {
            tags: []
        };

        // check all results
        for (const uid in this.razer_dict[this.razer_idx].err_dict) {
            var tag = this.razer_dict[this.razer_idx].err_dict[uid];
            obj.tags.push(tag);
        }

        // let's save
        var fn = this.dtd.name + 
            '-error-labels.' + 
            this.get_date_now() + 
            '.json';
            
        var json_text = JSON.stringify(obj, null, 4);
        var blob = new Blob([json_text], {type: "text/json;charset=utf-8"});
        saveAs(blob, fn);
    },

    show_razer_eaws_panel: function() {
        Metro.dialog.open('#dlg_razer_robot_iet');
    },

    show_razer_embedding_panel: function() {
        Metro.dialog.open('#dlg_razer_embedding_srv');
    },

    show_razer_selected_tags_in_fig_tag_scatter: function() {
        // get the uids
        var uids = [];

        for (let i = 0; i < this.razer_fig_tag_scatter.selected_indices.length; i++) {
            const idx = this.razer_fig_tag_scatter.selected_indices[i];
            // get the data item of this idx
            var d = this.razer_fig_tag_scatter.option.series[0].data[idx];
            // get the uid
            var uid = d[2];
            uids.push(uid);
        }

        // last, call the show function
        this.show_uids_in_razer_err_list(uids, null);
    },

    show_razer_tag_full_text: function(event, uid) {
        console.log('* showing full text for', 
            this.razer_dict[this.razer_idx].err_dict[uid]
        );
    },

    start_razer_eaws: function() {
        var tags = [];
        var docs = {};
        for (const uid in this.razer_dict[this.razer_idx].err_dict) {
            var tag = this.razer_dict[this.razer_idx].err_dict[uid];
            if (tag.hasOwnProperty('errors')) {
                // what to do?
                continue;
            }

            tags.push(tag);
            docs[tag.file_name] = this.razer_dict[this.razer_idx].doc_dict[tag.file_name];
        }

        error_analyzer.use_eaws(
            this.razer_ea_ws_url,
            {
                tags: tags,
                docs: docs
            },
            function(data) {
                console.log('* EAWS returns', data);

                for (let i = 0; i < data.tags.length; i++) {
                    const t = data.tags[i];
                    
                    app_hotpot.vpp.set_razer_err_labels(
                        t.uid,
                        t.errors
                    );

                }
                app_hotpot.vpp.update_razer_ui();
            }
        );
    },

    /**
     * Text Embedding Web Service
     */
    start_razer_tews: function() {
        var tags = [];
        for (const uid in this.razer_dict[this.razer_idx].err_dict) {
            var tag = this.razer_dict[this.razer_idx].err_dict[uid];
            tags.push({
                uid: tag.uid,
                text: tag.text
            });
        }

        error_analyzer.use_tews(
            this.razer_te_ws_url,
            {
                tags: tags,
                is_tsne: true
            },
            function(data) {
                console.log('* TEWS returns', data);

                for (let i = 0; i < data.tags.length; i++) {
                    const t = data.tags[i];
                    
                    app_hotpot.vpp.set_razer_err_embedding(
                        t.uid,
                        t.embedding_tsne
                    );
                }
                app_hotpot.vpp.$data.razer_flag_has_embedding_tsne = true;
                app_hotpot.vpp.update_razer_ui();
            }
        );
    },

    export_razer_report: function() {
        // create each sheet
        var ws_summary = error_analyzer.get_razer_report_summary(
            this.razer_dict[this.razer_idx], 
            'excelws'
        );
        var ws_stat_by_concept = error_analyzer.get_razer_report_stat_by_concept(
            this.razer_dict[this.razer_idx], 
            'excelws'
        );
        var ws_stat_by_err_type = error_analyzer.get_razer_report_stat_by_err_type(
            this.razer_dict[this.razer_idx], 
            this.razer_err_def,
            'excelws'
        );
        var ws_tag_list = error_analyzer.get_razer_report_tag_list(
            this.razer_dict[this.razer_idx], 
            'excelws'
        );

        // create wb for download
        var wb = {
            SheetNames: [
                "Summary",
                "By Concept",
                "By Error Types",
                "Tags and Labels"
            ],
            Sheets: {
                "Summary": ws_summary,
                "By Concept": ws_stat_by_concept,
                "By Error Types": ws_stat_by_err_type,
                "Tags and Labels": ws_tag_list
            }
        };
        console.log(wb);

        // decide the file name for this export
        var fn = this.dtd.name + '-error-analysis-report-' + this.get_date_now() + '.xlsx';

        // download this wb
        XLSX.writeFile(wb, fn);
    }
});

// extend the App with converter
/**
 * This is an extension for converter 
 */

/////////////////////////////////////////////////////////////////
// Corpus converter related variables
/////////////////////////////////////////////////////////////////
Object.assign(app_hotpot, {
    // for medtagger
    converter_corpus_medtagger_txt_files: [],
    converter_corpus_medtagger_ann_files: [],

    // for pure raw text
    converter_corpus_raw_txt_files: [],

    // for results
    converter_results: [],
});

Object.assign(app_hotpot.vpp_data, {
    // tasks
    // 1. medtagger: txt+ann
    // 2. raw: txt
    converter_corpus_task: 'raw',
    max_converter_display_files: 100,

    // for medtagger
    is_converter_loading_medtagger_txt_files: false,
    is_converter_loading_medtagger_ann_files: false,
    n_converter_corpus_medtagger_txt_files: 0,
    n_converter_corpus_medtagger_ann_files: 0,
    converter_corpus_medtagger_txt_files: [],
    converter_corpus_medtagger_ann_files: [],

    // for pure raw text
    is_converter_loading_raw_txt_files: false,
    n_converter_corpus_raw_txt_files: 0,
    converter_corpus_raw_txt_files: [],

    // for results
    n_converter_results: 0,
    converter_results: [],
});

/////////////////////////////////////////////////////////////////
// Corpus converter related functions
/////////////////////////////////////////////////////////////////

Object.assign(app_hotpot, {

    /////////////////////////////////////////////////////////////////
    // Raw text format related functions
    /////////////////////////////////////////////////////////////////
    add_files_to_converter_raw_txts: function(files) {
        console.log('* adding '+files.length+' files to converter raw txts');
        for (let i = 0; i < files.length; i++) {
            const file = files[i];
            this.converter_corpus_raw_txt_files[
                this.converter_corpus_raw_txt_files.length
            ] = file;
        }
        
        // update the number
        app_hotpot.vpp.$data.n_converter_corpus_raw_txt_files = this.converter_corpus_raw_txt_files.length;

        // update some sample data
        app_hotpot.vpp.$data.converter_corpus_raw_txt_files = this.hard_slice(
            this.converter_corpus_raw_txt_files,
            this.vpp.$data.max_converter_display_files
        );

        // reset loading status
        app_hotpot.vpp.$data.is_converter_loading_raw_txt_files = false;
    },

    convert_from_raw_txt: function() {
        if (this.converter_corpus_raw_txt_files.length == 0) {
            app_hotpot.toast('Conversion is terminated. The .txt text files are needed for conversion.', 'alert');
            return;
        }

        // just call the function
        this.converter_results = [];

        for (let i = 0; i < this.converter_corpus_raw_txt_files.length; i++) {
            var file = this.converter_corpus_raw_txt_files[i];
            
            var ann = ann_parser.txt2ann(
                file.text,
                this.vpp.$data.dtd
            );
            ann._filename = file.fn + '.xml';

            this.converter_results[
                this.converter_results.length
            ] = ann;
        }

        // update the number
        app_hotpot.vpp.$data.n_converter_results = this.converter_results.length;

        // copy to vpp
        app_hotpot.vpp.$data.converter_results = this.hard_slice(
            this.converter_results,
            this.vpp.$data.max_converter_display_files
        );
    },

    /////////////////////////////////////////////////////////////////
    // MedTagger format related functions
    /////////////////////////////////////////////////////////////////

    add_files_to_converter_medtagger_txts: function(files) {
        console.log('* adding '+files.length+' files to converter medtagger txts');
        for (let i = 0; i < files.length; i++) {
            const file = files[i];
            
            // save this file
            this.converter_corpus_medtagger_txt_files[
                this.converter_corpus_medtagger_txt_files.length
            ] = file;
        }

        // update numbers and samples
        app_hotpot.vpp.$data.n_converter_corpus_medtagger_txt_files = this.converter_corpus_medtagger_txt_files.length;

        // update some sample data
        app_hotpot.vpp.$data.converter_corpus_medtagger_txt_files = this.hard_slice(
            this.converter_corpus_medtagger_txt_files,
            this.vpp.$data.max_converter_display_files
        );

        // reset loading status
        this.vpp.$data.is_converter_loading_medtagger_txt_files = false;
    },

    add_files_to_converter_medtagger_anns: function(files) {
        console.log('* adding '+files.length+' files to converter medtagger anns');
        for (let i = 0; i < files.length; i++) {
            var file = files[i];

            // add more information for ann
            file.text = file.text.trim();
            file.lines = file.text.split('\n');
            
            // save this file
            this.converter_corpus_medtagger_ann_files[
                this.converter_corpus_medtagger_ann_files.length
            ] = file;
        }

        // update numbers and samples
        app_hotpot.vpp.$data.n_converter_corpus_medtagger_ann_files = this.converter_corpus_medtagger_ann_files.length;

        // update some sample data
        app_hotpot.vpp.$data.converter_corpus_medtagger_ann_files = this.hard_slice(
            this.converter_corpus_medtagger_ann_files,
            this.vpp.$data.max_converter_display_files
        );

        // reset loading status
        this.vpp.$data.is_converter_loading_medtagger_ann_files = false;
    },

    convert_from_medtagger_txt_and_ann: function() {
        if (this.converter_corpus_medtagger_txt_files.length == 0) {
            app_hotpot.toast('Conversion is terminated. The .txt text files are needed for conversion.', 'alert');
            return;
        }
        if (this.converter_corpus_medtagger_ann_files.length == 0) {
            app_hotpot.toast('Conversion is terminated. The .ann output files are needed for conversion.', 'alert');
            return;
        }
        this.converter_results = medtagger_toolkit.convert_medtagger_files_to_anns(
            this.converter_corpus_medtagger_txt_files,
            this.converter_corpus_medtagger_ann_files,
            this.vpp.$data.dtd
        );

        // update the number
        app_hotpot.vpp.$data.n_converter_results = this.converter_results.length;

        // copy to vpp
        app_hotpot.vpp.$data.converter_results = this.hard_slice(
            this.converter_results,
            this.vpp.$data.max_converter_display_files
        );
    },

    /////////////////////////////////////////////////////////////////
    // General functions
    /////////////////////////////////////////////////////////////////

    clear_converter_corpus_all: function() {
        // remove the medtagger files
        this.converter_corpus_medtagger_txt_files = [];
        this.converter_corpus_medtagger_ann_files = [];
        
        // remove the raw files
        this.converter_corpus_raw_txt_files = [];

        // remove the results
        this.converter_results = [];
    },

    download_converted_results_as_zip: function() {
        if (this.converter_results.length == 0) {
            app_hotpot.toast('Download is terminated. No converted files are found for conversion.', 'alert');
            return;
        }

        // create filename
        var fn = this.vpp.$data.dtd.name + '-' +
            this.vpp.converter_corpus_task + '-' +
            this.vpp.get_date_now() +
            '.zip';
        
        // donwload!
        var file_list = nlp_toolkit.download_dataset_raw(
            this.converter_results,
            this.vpp.$data.dtd,
            fn,
            true
        );
        
        console.log('* downloaded converted files as a zip:', file_list);
    },
});

Object.assign(app_hotpot.vpp_methods, {

    /////////////////////////////////////////////////////////////////
    // Raw text format related functions
    /////////////////////////////////////////////////////////////////
    on_drop_converter_raw_txt: function(event) {
        // prevent the default download event
        event.preventDefault();
        // get all dropped items
        let items = event.dataTransfer.items;
        // set loading status
        this.is_converter_loading_raw_txt_files = true;

        // set loading iaa_id
        var promise_files = fs_get_file_texts_by_items(
            items,
            // only accept xml for iaa
            function(fn) {
                if (app_hotpot.is_file_ext_txt(fn)) {
                    return true;
                }
                return false;
            }
        );
        promise_files.then(function(files) {
            app_hotpot.add_files_to_converter_raw_txts(files);
        });
    },

    /////////////////////////////////////////////////////////////////
    // MedTagger format related functions
    /////////////////////////////////////////////////////////////////
    on_drop_converter_medtagger_txt: function(event) {
        // prevent the default download event
        event.preventDefault();
        // get all dropped items
        let items = event.dataTransfer.items;
        // set loading status
        this.is_converter_loading_medtagger_txt_files = true;

        // set loading iaa_id
        var promise_files = fs_get_file_texts_by_items(
            items,
            // only accept xml for iaa
            function(fn) {
                if (app_hotpot.is_file_ext_txt(fn)) {
                    return true;
                }
                return false;
            }
        );
        promise_files.then(function(files) {
            app_hotpot.add_files_to_converter_medtagger_txts(files);
        });
    },

    // callback for loading ann files
    on_drop_converter_medtagger_ann: function(event) {
        // prevent the default download event
        event.preventDefault();
        // get all dropped items
        let items = event.dataTransfer.items;
        // set loading status
        this.is_converter_loading_medtagger_ann_files = true;

        // set loading iaa_id
        var promise_files = fs_get_file_texts_by_items(
            items,
            // only accept xml for iaa
            function(fn) {
                if (app_hotpot.is_file_ext_ann(fn)) {
                    return true;
                }
                return false;
            }
        );
        promise_files.then(function(files) {
            app_hotpot.add_files_to_converter_medtagger_anns(files);
        });
    },
    

    /////////////////////////////////////////////////////////////////
    // General converter functions
    /////////////////////////////////////////////////////////////////
    /**
     * Quick view the converted ann
     * 
     * @param {Object} event click event
     * @param {Object} ann an annotation
     */
    qv_converter_result_ann: function(event, ann) {
        // get position
        var x = event.clientX;
        var y = event.clientY;
        console.log('* show tqv at (' + x + ', ' + y + ')');

        // get the content to show
        var xmlstr = ann_parser.xml2str(
            ann_parser.ann2xml(
                ann,
                this.dtd
            )
        );

        // show content
        this.show_tqv_at(
            xmlstr,
            x,
            y,
            ann._filename,
            'File Size: ' + (xmlstr.length / 1024).toFixed(2) + 'kb'
        );
    },

    qv_converter_txt: function(event, file) {
        // get position
        var x = event.clientX;
        var y = event.clientY;
        console.log('* show tqv at (' + x + ', ' + y + ')');

        // show content
        this.show_tqv_at(
            file.text,
            x,
            y,
            file.fn,
            'File Size: ' + (file.text.length / 1024).toFixed(2) + 'kb'
        );
    },

    switch_corpus: function(corpus_task) {
        this.converter_corpus_task = corpus_task;
    },

    clear_converter_corpus_all: function() {
        // remove outside data
        app_hotpot.clear_converter_corpus_all();

        // remove vpp data
        // remove the medtagger files
        this.n_converter_corpus_medtagger_txt_files = 0;
        this.n_converter_corpus_medtagger_ann_files = 0;
        this.converter_corpus_medtagger_txt_files = [];
        this.converter_corpus_medtagger_ann_files = [];
        
        // remove the raw files
        this.n_converter_corpus_raw_txt_files = 0;
        this.converter_corpus_raw_txt_files = [];

        // remove the results
        this.n_converter_results = 0;
        this.converter_results = [];
    },

    convert_corpus_to_medtator_format: function() {
        if (this.converter_corpus_task == 'medtagger') {
            app_hotpot.convert_from_medtagger_txt_and_ann();

        } else if (this.converter_corpus_task == 'raw') {
            app_hotpot.convert_from_raw_txt();
        }
    },

    download_converted_result: function(ann) {
        // convert to xml first
        var xmlDoc = ann_parser.ann2xml(ann, this.dtd);

        // convert xml to string
        var xmlStr = ann_parser.xml2str(xmlDoc, false);

        // save this
        var blob = new Blob(
            [xmlStr], 
            {type: "text/xml;charset=utf-8"}
        );
        saveAs(blob, ann._filename);
    },

    download_converted_results_as_zip: function() {
        app_hotpot.download_converted_results_as_zip();
    },

    show_converter_how_to_user: function() {
        window.open(
            'https://github.com/OHNLP/MedTator/wiki/Manual#converter-tab',
            '_blank'
        );
    },
});

// extend the App with schema editor
/**
 * This is an extension for schema editor 
 */

/////////////////////////////////////////////////////////////////
// schema editor related variables
/////////////////////////////////////////////////////////////////
Object.assign(app_hotpot.vpp_data, {
    // for schema editor dtd
    se_dtd: null,

    // for making schema from templates
    se_dtd_tpl_id: null,
});

/////////////////////////////////////////////////////////////////
// Schema editor related functions
/////////////////////////////////////////////////////////////////
Object.assign(app_hotpot.vpp_methods, {

    set_se_dtd: function(se_dtd) {
        this.se_dtd = se_dtd;
    },

    create_new_se_dtd: function() {
        var new_se_dtd = dtd_parser.mk_base_dtd('NEW_SCHEMA');

        this.set_se_dtd(new_se_dtd);
    },

    show_schema_editor: function(mode) {
        if (typeof(mode) == 'undefined') {
            mode = 0;
        }

        if (mode == 0) {
            // just open as it is

        } else if (mode == 1) {
            // create a new
            this.create_new_se_dtd();

        } else if (mode == 2) {
            // copy current dtd
            this.se_dtd = JSON.parse(JSON.stringify(this.dtd));

        } else {
            // ?
        }

        // open the dialog
        // Metro.dialog.open('#schema_editor');
        $('.schema-editor').show();
    },

    open_se_dtd: function() {
        // the settings for dtd file
        var pickerOpts = {
            types: [
                {
                    description: 'Annotation Schema File',
                    accept: {
                        'text/dtd': ['.dtd', '.json', '.yaml', '.yml']
                    }
                },
            ],
            excludeAcceptAllOption: true,
            multiple: false
        };

        // get the file handles
        var promise_fileHandles = fs_open_files(pickerOpts);

        promise_fileHandles.then(function(fileHandles) {
            // read the fh and set dtd
            // in fact, there is only one file for this dtd
            for (let i = 0; i < fileHandles.length; i++) {
                const fh = fileHandles[i];

                // read the file
                var p_dtd = fs_read_dtd_file_handle(fh);

                p_dtd.then((function(){
                    return function(dtd) {
                        if (dtd == null) {
                            // must be something wrong
                            app_hotpot.msg(
                                'Something wrong with the dropped file, please check the schema format.', 
                                'warning'
                            );
                            return;
                        }
                        // just set the dtd
                        app_hotpot.vpp.set_se_dtd(dtd);
                    }
                })());
                
                // just one file
                break;
            }
        });

    },

    load_se_dtd_sample: function() {
        if (this.se_dtd_tpl_id == null) {
            // ok, skip this
            app_hotpot.toast('Please select a sample schema');
            return;
        }

        // just alias name
        var sample_name = this.se_dtd_tpl_id;

        // ok, we have some selection here ...
        // for local version, load text through binding
        if (jarvis.hasOwnProperty('sample_dtd')) {
            // get the text from jarvis sample
            var sample_dtd_txt = jarvis.sample_dtd[sample_name];

            // parse the dtd from data
            var dtd = dtd_parser.parse(sample_dtd_txt);

            // set the se dtd
            app_hotpot.vpp.set_se_dtd(dtd);

            return;
        }

        // for web version, just load data through AJAX
        $.ajax({
            url: './static/data/' + sample_name + '.dtd',
            dataType: "text",
            success: function(data, status, xhr) {
                // parse the dtd from data
                var dtd = dtd_parser.parse(data);

                // set the se dtd
                app_hotpot.vpp.set_se_dtd(dtd);

                // toast?
                app_hotpot.toast(
                    'Loaded DTD content',
                    'info'
                );
            },
            error: function (xhr, status, error) {
                console.error(error);

                app_hotpot.toast(
                    'Something wrong when loading DTD, try later?',
                    'warning'
                );
            }
        });
    },

    use_se_dtd_for_annotation: function(se_dtd) {
        // check some conditions
        if (this.dtd == null) {
            // 
        } else {
            if (this.anns.length == 0) {

            } else {
                var ret = window.confirm(
                    'Using this new schema need to clear all annotation files in the list to avoid schema conflicts.\nAre you sure to continue?'
                );

                if (ret) {

                } else {
                    return;
                }

                this.remove_all_ann_files(true);

            }
        }

        // clear other iaa to avoid issues
        this.clear_iaa_all();

        // convert to full dtd first
        var dtd = dtd_parser.extend_base_dtd(se_dtd);
        
        // set dtd
        app_hotpot.set_dtd(dtd);

        // close
        this.close_schema_editor();
    },

    download_se_dtd: function(base_dtd) {
        this.download_se_dtd_as_yaml(base_dtd);
    },

    download_se_dtd_as_yaml: function(base_dtd) {
        // first, convert the base_dtd to text
        var text = dtd_parser.stringify_yaml(
            base_dtd
        );

        // then save it
        // get the current file name
        var fn = base_dtd.name + '.yaml';

        // download this dtd text
        var blob = new Blob(
            [text], 
            {type: "text/txt;charset=utf-8"}
        );
        saveAs(blob, fn);
    },

    download_se_dtd_as_json: function(base_dtd) {
        // first, convert the base_dtd to text
        var text = dtd_parser.stringify_json(
            base_dtd
        );

        // then save it
        // get the current file name
        var fn = base_dtd.name + '.json';

        // download this dtd text
        var blob = new Blob(
            [text], 
            {type: "text/txt;charset=utf-8"}
        );
        saveAs(blob, fn);
    },

    download_se_dtd_as_dtd: function(base_dtd) {
        // first, convert the base_dtd to text
        var text = dtd_parser.stringify(
            base_dtd
        );

        // then save it
        // get the current file name
        var fn = base_dtd.name + '.dtd';

        // download this dtd text
        var blob = new Blob(
            [text], 
            {type: "text/txt;charset=utf-8"}
        );
        saveAs(blob, fn);

    },

    close_schema_editor: function() {
        $('.schema-editor').hide();
    },

    show_att_list_editor: function(att) {
        // get the current value
        var val = att.values.join('|');

        // show the promp
        var ret = window.prompt(
            'Set the items for attribute [' + att.name + ']. Seperate them by "|". \nFor example, apple|banana',
            val
        );

        // update the att values
        if (ret) {
            att.values = ret.split('|');
        } else {
            // nothing to do when no update
        }
    },

    add_se_dtd_tag: function(dtd, etag_or_rtag) {
        if (typeof(etag_or_rtag) == 'undefined') {
            // 0: etag
            // 1: rtag
            etag_or_rtag = 0;
        }

        var tag_type = '';
        if (etag_or_rtag == 0) {
            tag_type = 'etag';
            tag_name = 'NEW_ETAG_' + (dtd.etags.length+1);
        } else {
            tag_type = 'rtag';
            tag_name = 'NEW_RTAG_' + (dtd.rtags.length+1);
        }

        var base_tag = dtd_parser.mk_base_tag(
            tag_name, 
            tag_type
        );

        // add to dtd directly?
        if (etag_or_rtag == 0) {
            dtd.etags.push(base_tag);

        } else {
            dtd.rtags.push(base_tag);
        }
    },

    add_se_dtd_tag_attr: function(dtd, tag_def) {
        var att = dtd_parser.mk_base_attr(
            dtd.name,
            'new_attr_' + (tag_def.attrs.length+1),
            'text'
        )
        
        // add to the given tag??
        tag_def.attrs.push(att);
    },

    remove_se_dtd_tag: function(dtd, tag_def, etag_or_rtag, tag_idx) {
        var ret = window.confirm('Are you sure to remove the tag [' + tag_def.name + ']?');

        if (ret) {
            // ok, go ahead
        } else {
            return;
        }

        if (etag_or_rtag == 0) {
            // etag
            dtd.etags.splice(tag_idx, 1);

        } else {
            dtd.rtags.splice(tag_idx, 1);
        }
    },

    remove_se_dtd_tag_attr: function(dtd, tag_def, att, etag_or_rtag, tag_idx, att_idx) {
        if (att.vtype == 'list') {
            var ret = window.confirm('This attribute contains a list of values ['+att.values.join('|')+']. Are you sure to remove the attribute [' + tag_def.name + '.' + att.name + ']?');

            if (ret) {
                // ok, go ahead
            } else {
                return;
            }
        }
        if (etag_or_rtag == 0) {
            // etag
            dtd.etags[tag_idx].attrs.splice(att_idx, 1);

        } else {
            dtd.rtags[tag_idx].attrs.splice(att_idx, 1);
        }
    },

    is_valid_letter_for_dtd: function(char) {
        if (/^[A-Za-z0-9_]+$/.test(char)) {
            return true;
        } else {
            // Hmm, not match
            return false;
        }
    },

    on_keypress_se_dtd_input: function(event) {
        // get the character
        var char = String.fromCharCode(event.keyCode); 

        if (this.is_valid_letter_for_dtd(char)) {
            return true;
        } else {
            event.preventDefault(); 
        }
    },

    show_se_help: function() {
        // app_hotpot.start_tour_annotation();
        window.open(
            'https://github.com/OHNLP/MedTator/wiki/Annotation-Schema#schema-editor',
            '_blank'
        );
    },
});

// extend the App with annviewer-bratvis
/**
 * This is an extension for annviewer brat vis
 */

/////////////////////////////////////////////////////////////////
// annviewer-bratvis related variables
/////////////////////////////////////////////////////////////////
Object.assign(app_hotpot.vpp_data, {
    avbrat_is_rendering: true
});


/////////////////////////////////////////////////////////////////
// annviewer-bratvis related functions
/////////////////////////////////////////////////////////////////
Object.assign(app_hotpot.vpp_methods, {

    show_avbrat: function(flag_enable_selection_vis) {
        if (this.dtd == null || 
            this.anns.length == 0 || 
            this.ann_idx == null) {
            // when no schema, not ann, or no selected
            // just skip
            app_hotpot.toast(
                'Please ensure the annotation schema is loaded and a document is selected for visualization.',
                'warning'
            );
            return;
        }
        if (typeof(flag_enable_selection_vis) == 'undefined') {
            flag_enable_selection_vis = true;
        }
        // init the brat if not
        // fig_bratvis.init();
        $('.annviewer-bratvis').show();

        // get default conversion
        var text = this.anns[this.ann_idx].text;
        var tags = this.anns[this.ann_idx].tags;

        // first, get the selection
        if (flag_enable_selection_vis) {
            
        var cms = app_hotpot.cm_get_selection();

            if (cms.sel_txts[0] == '') {
                // which means the selection is empty
                // nothing to do, just use the whole document for visualization
                // still need to do sentence split? no

            } else {
                // need to convert to sentence
                var spans = app_hotpot.cm_range2spans(
                    cms.sel_locs[0],
                    this.anns[this.ann_idx]
                );
                // update the text
                text = ann_parser.get_text_by_spans(
                    spans,
                    this.anns[this.ann_idx].text
                );
                // update the tags
                tags = ann_parser.get_subtags_of_substr_in_ann(
                    spans,
                    this.anns[this.ann_idx],
                    this.dtd,
                    true, // update the offset of tags to the substring
                );
            }
        }

        // for brat vis:
        // 1. get coll data
        var col_data = brat_parser.make_collection_data_by_dtd(
            this.dtd
        );
        console.log('* get brat col_data:', col_data);

        // 2. get doc data
        var doc_data = brat_parser.make_document_data(
            text,
            tags,
            this.dtd
        );
        console.log('* get brat doc_data:', doc_data);

        // 3. vis!
        fig_bratvis.visualize(
            col_data,
            doc_data
        );

        this.avbrat_is_rendering = false;
    },

    export_avbrat_figure: function() {

    },

    show_avbrat_help: function() {
        this.show_help('avbrat_help_how_to_use');
    },

    close_avbrat: function() {
        $('.annviewer-bratvis').hide();
    },

});

// extend the App with text quick viewer
/**
 * This is an extension for text quick viewer 
 */

Object.assign(app_hotpot.vpp_data, {
    // for text quick viewer (tqv)
    show_text_quick_viewer: false,
    tqv_header: '',
    tqv_content: '',
    tqv_footer: '',
    tqv_pos_x: -999,
    tqv_pos_y: -999,
});


Object.assign(app_hotpot, {
    bind_tqv_dragable: function() {
        $( ".tq-viewer-box" ).draggable({ handle: ".tq-viewer-header" });
    },
});


Object.assign(app_hotpot.vpp_methods, {
    hide_tqv: function() {
        this.show_text_quick_viewer = false;
    },

    on_drag_tqv: function(event) {
        var x = event.clientX;
        var y = event.clientY;
        console.log('* show tqv at (' + x + ', ' + y + ')');
    },

    show_tqv_at: function(text, x, y, header, footer) {
        if (typeof(x) == 'undefined') {
            x = ($(window).width() - 500) / 2;
        }
        if (typeof(y) == 'undefined') {
            y = ($(window).height() - 250) / 2;
        }
        if (typeof(header) == 'undefined') {
            header = 'Text';
        }
        if (typeof(footer) == 'undefined') {
            footer = '';
        }

        // update display content
        this.tqv_header = header;
        this.tqv_content = text;
        this.tqv_footer = footer;

        // update the position
        this.tqv_pos_x = x + 10;

        if ((y+220) < $(window).height()) {
            this.tqv_pos_y = y;
        } else {
            this.tqv_pos_y = $(window).height() - 220;
        }

        this.show_text_quick_viewer = true;
    }
});

// extend the App with tour
/**
 * This is an extension for annotation basic tour 
 */

 Object.assign(app_hotpot, {
    start_tour_annotation: function() {
        if (this.tour.annotation == null) {
            this.tour.annotation = new Shepherd.Tour({
                defaultStepOptions: {
                    classes: '',
                    scrollTo: true
                }
            });

            // add step for dtd
            this.tour.annotation.addStep({
                id: 'tour-step1',
                text: 'Welcome! 🎉 🎉 🎉  MedTator is very easy to use!<br>First, you can drop a schema file here (.yaml/.json/.dtd) .<br>The schema file defines all of the concepts you want to annotate in the documents.',
                attachTo: {
                  element: '#dropzone_dtd',
                  on: 'right'
                },
                classes: '',
                buttons: [{
                    text: 'Close',
                    classes: 'bg-gray', 
                    action: this.tour.annotation.complete
                }, {
                    text: 'Next <i class="fa fa-arrow-right"></i>',
                    action: this.tour.annotation.next
                }]
            });

            // add step for text
            this.tour.annotation.addStep({
                id: 'tour-step2',
                text: 'Second, you need to drop some annotation files here.<br>You can drop MedTator XML format files to start annotation. <br>MedTator can save your annotations in those xml files directly.<br>Moreover, you can also drop raw text files (.txt), <br>or use the <b><i class="fas fa-mortar-pestle"></i> Converter</b> Tab to convert .txt files to XML format.',
                attachTo: {
                  element: '#mui_filelist_list',
                  on: 'right'
                },
                classes: '',
                buttons: [{
                    text: 'Close',
                    classes: 'bg-gray', 
                    action: this.tour.annotation.complete
                }, {
                    text: '<i class="fa fa-arrow-left"></i> Prev',
                    action: this.tour.annotation.back
                }, {
                    text: 'Next <i class="fa fa-arrow-right"></i>',
                    action: this.tour.annotation.next
                }]
            });

            // add step for text
            this.tour.annotation.addStep({
                id: 'tour-step3',
                text: "That's all to start a new annotation task!<br>If you are not sure what each button does, here are some sample datasets for you to try all the functions. You could play with the sample datasets freely to see how each function works.<br>Have fun! 😁 <br><br>And if you have any questions or issues, please feel free to <a target='_blank' href='https://github.com/OHNLP/MedTator/issues'>let us know</a>!",
                attachTo: {
                  element: '#btn_annotation_load_sample',
                  on: 'left'
                },
                classes: '',
                buttons: [{
                    text: '<i class="fa fa-arrow-left"></i> Prev',
                    action: this.tour.annotation.back
                }, {
                    text: 'Close',
                    classes: 'bg-gray', 
                    action: this.tour.annotation.complete
                }]
            });
        }

        this.tour.annotation.start();
    }
 });

// extend the App with toolkits
Object.assign(app_hotpot.vpp_data, {
    // toolkit
    // 1. medtaggervis
    // 2. iob2editor
    // 3. ruleseteditor
    // 4. 
    toolkit_section: 'medtaggervis',

    // for medtaggervis
    tk_medtaggervis_is_loading_txt_files: false,
    tk_medtaggervis_is_loading_ann_files: false,
    tk_medtaggervis_txt_files: [],
    tk_medtaggervis_ann_files: [],
    tk_medtaggervis_force_module_update: 0,
    tk_medtaggervis_show_attr_certainty: true,
    tk_medtaggervis_show_attr_status: true,

    // for iob2editor
    tk_iob2editor_is_loading_iob_files: false,
    tk_iob2editor_iob_files: [],
    tk_iob2editor_force_module_update: 0,

    // for ruleseteditor
});


Object.assign(app_hotpot.vpp_methods, {

    tk_show_section: function(sec_name) {
        this.toolkit_section = sec_name;
    },


    /////////////////////////////////////////////////////////////////
    // MedTaggerVis related functions
    /////////////////////////////////////////////////////////////////

    tk_medtaggervis_on_drop_txt_files: function(event) {
        // prevent the default download event
        event.preventDefault();

        // get items
        const items = event.dataTransfer.items;
        console.log('* dropped ' + items.length + ' items but maybe not all are acceptable.');

        // first, set to loading status and init the values
        this.tk_medtaggervis_is_loading_txt_files = true;

        var promise_files = fs_get_file_texts_by_items(
            items,
            function(fn) {
                if (app_hotpot.is_file_ext_txt(fn)) {
                    return true;
                }
                return false;
            }
        );

        // call back
        promise_files.then(function(files) {
            app_hotpot.vpp.tk_medtaggervis_add_txt_files(files);
        });
    },

    tk_medtaggervis_add_txt_files: function(files) {
        console.log('* adding '+files.length+' txt files to medtaggervis');
        for (let i = 0; i < files.length; i++) {
            const file = files[i];
            
            // save this file
            this.tk_medtaggervis_txt_files[
                this.tk_medtaggervis_txt_files.length
            ] = file;
        }

        // reset loading status
        this.tk_medtaggervis_is_loading_txt_files = false;

        // force update
        this.force_module_update = Math.random();
    },
    

    tk_medtaggervis_on_drop_ann_files: function(event) {
        // prevent the default download event
        event.preventDefault();

        // get items
        const items = event.dataTransfer.items;
        console.log('* dropped ' + items.length + ' items but maybe not all are acceptable.');

        // first, set to loading status and init the values
        this.tk_medtaggervis_is_loading_ann_files = true;

        var promise_files = fs_get_file_texts_by_items(
            items,
            function(fn) {
                if (app_hotpot.is_file_ext_ann(fn)) {
                    return true;
                }
                return false;
            }
        );

        // call back
        promise_files.then(function(files) {
            app_hotpot.vpp.tk_medtaggervis_add_ann_files(files);
        });
    },

    tk_medtaggervis_add_ann_files: function(files) {
        console.log('* adding '+files.length+' ann files to medtaggervis');
        for (let i = 0; i < files.length; i++) {
            const file = files[i];
            
            // save this file
            this.tk_medtaggervis_ann_files[
                this.tk_medtaggervis_ann_files.length
            ] = file;
        }

        // reset loading status
        this.tk_medtaggervis_is_loading_ann_files = false;

        // force update
        this.tk_medtaggervis_force_module_update = Math.random();
    },

    tk_medtaggervis_clear_all: function() {
        // clear data
        this.tk_medtaggervis_txt_files = [];
        this.tk_medtaggervis_ann_files = [];

        // clear figure
        fig_bratvis.clear('tk_medtaggervis_brat_fig');

        // force update
        this.tk_medtaggervis_force_module_update = Math.random();
    },

    tk_medtaggervis_on_click_txt_file: function(file) {
        console.log('* clicked tk medtaggervis txt file', file);
    },

    tk_medtaggervis_on_click_ann_file: function(file) {
        var fn_ann = file.fn;

        // OK, next need to search 
        var fn_txt = fn_ann.substring(0, fn_ann.length-4);

        // get this file
        function _ff(fn, list) {
            for (let i = 0; i < list.length; i++) {
                var file = list[i];
                if (file.fn == fn) {
                    return file
                }
            }
            return null;
        }
        var f_ann = _ff(fn_ann, this.tk_medtaggervis_ann_files);
        var f_txt = _ff(fn_txt, this.tk_medtaggervis_txt_files);
        if (f_txt == null) {
            app_hotpot.toast(
                '[' + fn_txt + '] is not found in your uploaded files, please ensure the file is uploaded or the file name is correct.',
                'warning'
            );
            return;
        }
        console.log('* found ann file', f_ann, ' and txt file', f_txt);

        // get the collection and document data
        var text = f_txt.text;
        var ann_rs = medtagger_toolkit.parse_ann_file(f_ann);
        var brat_vis_obj = brat_parser.medtagger2brat(
            text,
            ann_rs,
            {
                'certainty': this.tk_medtaggervis_show_attr_certainty,
                'status': this.tk_medtaggervis_show_attr_status,
            }
        );
        console.log('* got brat vis obj', brat_vis_obj);

        // Now let's create the visualization?
        // clear figure if any
        fig_bratvis.clear('tk_medtaggervis_brat_fig');

        // then draw a new one
        fig_bratvis.visualize(
            brat_vis_obj.col_data,
            brat_vis_obj.doc_data,
            'tk_medtaggervis_brat_fig'
        );
    },

    tk_medtaggervis_parse_files: function() {

    },

    tk_medtaggervis_how_to_use: function() {
        this.show_help('tk_medtaggervis_help');
    },

    tk_medtaggervis_on_change_settings: function() {

    },

    /////////////////////////////////////////////////////////////////
    // IOB2Editor related functions
    /////////////////////////////////////////////////////////////////


    tk_iob2editor_on_drop_iob_files: function(event) {
        // prevent the default download event
        event.preventDefault();

        // get items
        const items = event.dataTransfer.items;
        console.log('* dropped ' + items.length + ' items but maybe not all are acceptable.');

        // first, set to loading status and init the values
        this.tk_iob2editor_is_loading_iob_files = true;

        var promise_files = fs_get_file_texts_by_items(
            items,
            function(fn) {
                // no file name extension requirement for iob2/bio
                return true;
            }
        );

        // call back
        promise_files.then(function(files) {
            app_hotpot.vpp.tk_iob2editor_add_iob_files(files);
        });
    },

    tk_iob2editor_add_iob_files: function(files) {
        console.log('* adding '+files.length+' iob files to iob2editor');
        for (let i = 0; i < files.length; i++) {
            var file = files[i];

            // add status
            file.has_saved = false;
            
            // save this file
            this.tk_iob2editor_iob_files[
                this.tk_iob2editor_iob_files.length
            ] = file;
        }

        // reset loading status
        this.tk_iob2editor_is_loading_iob_files = false;

        // force update
        this.tk_iob2editor_force_module_update = Math.random();
    },

    tk_iob2editor_clear_all: function() {
        // clear data
        this.tk_iob2editor_iob_files = [];

        // force update
        this.tk_iob2editor_force_module_update = Math.random();
    },

    tk_iob2editor_on_click_iob_file: function(file) {

    },


    /////////////////////////////////////////////////////////////////
    // Rule editor related functions
    /////////////////////////////////////////////////////////////////
    tk_ruleseteditor_clear_all: function() {

    },

    tk_ruleseteditor_how_to_use: function() {
        
    }
});

// The Tag Info Vue Module
Vue.component('iaa-tag-info', {
    data: function () {
        return {
            update: 0,
        }
    },
    methods: {
        /**
         * Create a context HTML for showing the tag information
         * @param {Object} tag the annotated tag
         * @param {Object} ann the ann object
         */
         get_iaa_context_html: function(tag, ann) {
            // first, convert the tag spans for locating
            var loc = iaa_calculator.spans2loc(tag.spans);
            var spans_text = tag.text;

            // get the context start
            var c_start = loc[0] - 200;
            if (c_start < 0) { c_start = 0; }

            // get the context end
            var c_end = loc[1] + 200;
            if (c_end > ann.text.length) { c_end = ann.text.length; }

            // now create a text
            var html = [
                // the context before tag spans
                ann.text.substring(c_start, loc[0]),

                // the tag itself
                '<span class="mark-tag mark-tag-' + tag.tag + '">',
                spans_text,
                '</span>',

                // the context after tag spans
                ann.text.substring(loc[1], c_end)
            ];

            return html.join('');
        },

        accept_tag: function(hashcode, tag_name, cm, tag_idx, from) {
            // call app_hotpot directly
            app_hotpot.vpp.accept_iaa_tag(hashcode, tag_name, cm, tag_idx, from);
        },

        get_tag_spans_html: function(tag) {
            if (tag.spans == '-1~-1') {
                return 'DOCLEVEL';
            } else {
                return tag.spans;
            }
        }
    },

    computed: {
        
    },

    props: [
        'cm',
        'hashcode',
        'from',
        'tag',
        'tag_idx',
        'ann',
        'dtd',
        'iaa_display_tags_context',
        'force_module_update',
    ],

    template: `
<div class="iaa-tag-detail-info w-100 d-flex flex-column" 
    v-bind:class="'iaa-tag-detail-info-' + cm"
    :force_module_update="force_module_update">
    <div class="d-flex flex-row flex-wrap flex-align-end">

        <div class="iaa-tag-detail-oper">
            <button class="btn btn-xs"
                :title="'Accept this [' + tag.text + '] in goldstandard'"
                v-on:click="accept_tag(hashcode, tag.tag, cm, tag_idx, from)">
                Accept This
            </button>
        </div>

        <div class="iaa-tag-detail-info-text-ab mr-2">
            <span class="mr-1"
                v-bind:class="'mark-tag-' + tag.tag">
                {{ tag.id }}
            </span>
            <span>
                {{ get_tag_spans_html(tag) }}: 
                <b>
                    {{ tag.text }}
                </b>
            </span>
        </div>
        
        <div v-for="(attr, attr_idx) in dtd.tag_dict[tag.tag].attrs"
            v-if="!['id','spans','text','tag'].contains(attr.name)"
            class="iaa-tag-attr mr-1 ml-1 d-flex flex-column">

            <div class="iaa-tag-attr-name">
                &nbsp;{{ attr.name }}:
            </div> 

            <div>
                &nbsp;{{ tag[attr.name] }}
            </div>
            
        </div>
    </div>

    <div v-if="iaa_display_tags_context"
        v-html="get_iaa_context_html(tag, ann)"
        class="iaa-tag-context mt-1">
    </div>  
</div>   
`
});

// The Tag Info Vue Module for Gold Standard
Vue.component('iaa-tag-info-gs', {
    data: function () {
        return {
            update: 0,
        }
    },
    methods: {

        reject_tag: function(hashcode, tag_name, cm, tag_idx) {
            // call app_hotpot directly
            tag_idx = parseInt(tag_idx);
            app_hotpot.vpp.reject_iaa_tag(hashcode, tag_name, cm, tag_idx);
        },

        upper: function(v) {
            return v.toLocaleUpperCase();
        }
    },

    computed: {
        
    },

    props: [
        'cm',
        'from',
        'hashcode',
        'tag_obj',
        'tag_idx',
        'ann',
        'dtd',
        'force_module_update',
    ],

    template: `
<div v-if="tag_obj != null"
    class="iaa-tag-detail-info w-100 d-flex flex-column" 
    v-bind:class="'iaa-tag-detail-info-gs'"
    :force_module_update="force_module_update">
    <div class="d-flex flex-row flex-wrap flex-align-end">
    
        <div class="iaa-tag-detail-oper">
            <button class="btn btn-xs"
                :title="'Remove this [' + tag_obj.tag.text + ']'"
                v-on:click="reject_tag(hashcode, tag_obj.tag.tag, cm, tag_idx)">
                Remove
            </button>
        </div>

        <div class="iaa-tag-detail-info-text-gs mr-2">
            <span class="mr-1">
                <i class="fa fa-user"></i>
                <b>
                {{ upper(tag_obj.from) }}
                </b>
            </span>
            <span>
                {{ tag_obj.tag.spans }}: 
                <b>
                    {{ tag_obj.tag.text }}
                </b>
            </span>
        </div>
        
    </div>
</div>
<div v-else
    class="iaa-tag-detail-info w-100 d-flex flex-column">
    Rejected or Not Decided
</div>
`
});

// The Vue.js module for showing item list
Vue.component('simple-item-list', {
    data: function () {
        return {
            page_num: 1,
            keyword: '',

            // which file is clicked
            current_item: null,
        }
    },
    methods: {
        upper: function(v) {
            return v.toLocaleUpperCase();
        },

        clear_keyword: function() {
            this.keyword = '';
        },

        on_click_item: function(vi) {
            console.log('* clicked vi', vi);
            // send the back the item itself
            this.callback_on_click_item(vi.item);

            if (this.readonly) {

            } else {
                this.current_item = vi;
            }
        },

        on_click_save_item: function(vi) {
            // vi.file.has_saved = true;
            console.log('* saved item', vi);
            // just for update
            this.force_module_update = Math.random();
        }
    },

    computed: {
        page_count: function() {
            this.force_module_update;
            return Math.ceil(this.v_filtered_items.length / this.page_size);
        },

        v_filtered_items: function() {
            // just for update
            this.force_module_update;

            var v_filtered_items = [];

            for (let i = 0; i < this.items.length; i++) {
                var css_class = '';
                if (this.current_item != null &&
                    this.items[i][this.name_attr] == this.current_item.item[this.name_attr]) {
                    css_class = 'item-selected';
                }
                if (this.keyword == '' || this.items[i][this.name_attr].indexOf(this.keyword) >= 0) {
                    // for perf issue, use this instead of push
                    // this is the virtual item that contains more info
                    v_filtered_items[v_filtered_items.length] = {
                        // the original item index
                        idx: i,

                        // the link to the original item object
                        item: this.items[i],

                        // a status for show different style
                        css_class: css_class,
                    };
                }
            }

            return v_filtered_items;
        },

        v_paged_items: function() {
            // just for update
            this.force_module_update;

            if (this.items.length == 0) {
                return [];
            }

            // ok, let's do paging
            var pitems = this.v_filtered_items;

            if (this.page_count > 1) {
                pitems = this.v_filtered_items.slice(
                    (this.page_num - 1) * this.page_size,
                    this.page_num * this.page_size
                );
            }

            return pitems;
        },
    },

    props: {
        items: {
            default: [],
        },
        name_attr: {
            default: 'fn'
        },
        readonly: {
            type: Boolean,
            default: false,
        },
        page_size: {
            default: 50
        },
        force_module_update: {},
        callback_on_click_item: {}
    },

    template: `
<div :force_module_update="force_module_update"
    class="simple-item-list">

    <div class="simple-item-list-header">
        <span class="mr-1"
            title="Filter by keyword">
            Filter: 
        </span>
        <input type="text" 
            class="ipt-xs"
            style="width: 55px;"
            v-model="keyword">

        <button class="btn btn-xs"
            v-on:click="clear_keyword()">
            <i class="fa fa-times"></i>
        </button>
    </div>

    <div class="simple-item-list-body"
        style="">
        <ul class="w-100 item-list">
            <li v-for="vi in v_paged_items"
                v-bind:class="vi.css_class"
                v-on:click="on_click_item(vi)"
                class="item-list-row">
                <div class="d-flex flex-row flex-justify-between">
                    <div class="item-list-row-name"
                        v-bind:class="{'item-list-row-name-unsaved': !vi.item.has_saved}">

                        <span v-if="!vi.item.has_saved" 
                            v-on:click="on_click_save_item(vi)"
                            title="Save the changes"
                            class="icon-fg-unsaved mr-1">
                            <i class="fa fa-save"></i>
                        </span>

                        <span>
                        {{ vi.item[name_attr] }}
                        </span>
                    </div>
                </div>
            </li>
        </ul>
    </div>

    <div class="simple-item-list-footer" 
        style="text-align: center;">

        {{ v_filtered_items.length }}

        <button class="btn btn-xs"
            v-on:click="page_num = 1">
            <i class="fas fa-step-backward"></i>
        </button>

        <button class="btn btn-xs"
            v-bind:disabled="page_num == 1"
            v-on:click="page_num -= 1">
            <i class="fas fa-caret-left"></i>
        </button>

        <select v-model="page_num"
            class="select-xs"
            style="width: 40px;">
            <option v-for="pn in page_count"
                v-bind:value="pn">
                {{ pn }}
            </option>
        </select>
        / {{ page_count }}

        <button class="btn btn-xs"
            v-bind:disabled="page_num == page_count"
            v-on:click="page_num += 1">
            <i class="fas fa-caret-right"></i>
        </button>
        
        <button class="btn btn-xs"
            v-on:click="page_num = page_count">
            <i class="fas fa-step-forward"></i>
        </button>

    </div>
</div>
    `
});

// The helper for brat toolkits
/**
 * brat standoff format annotation file parser
 * 
 * The format details can be found at:
 * http://brat.nlplab.org/standoff.html
 * 
 * At present, only two types of annotation are supported:
 * 
 * - T: text-bound annotation
 * - R: relation
 * - A: the attribure for annotations
 * 
 * We are using v1.3 which supports discontinuous text-bound annotations, 
 * where the annotation involves more than one continuous span of characters.
 */
var brat_parser = {

    /**
     * Parse the brat ann format
     * 
     * @param {string} ann_text the text content of a given ann
     * @returns document_data object
     */
    parse_ann: function(ann_text) {
        var doc_data = {
            text: '',
            entities: [],
            relations: [],
            attributes: [],
            events: [],
            triggers: []
        };

        let lines = ann_text.split('\n');
        for (let i = 0; i < lines.length; i++) {
            var line = lines[i];
            line = line.trim();

            if (line == '') {
                // it's empty
                continue;
            }
            
            if (line.startsWith('#')) {
                // it's a note
                continue;
            }

            // the first letter must be the line code
            let annotation_type_id = line[0];
            
            if (annotation_type_id == 'T') {
                var r = this._parse_ann_line_type_text(line);
                doc_data.entities.push(r);
            }
        }

        return doc_data;
    },

    _parse_ann_line_type_text: function(line) {
        var ps = line.split('\t');

        // first must be the ID
        var id = ps[0];

        // third must be the token
        var token = ps[2];
        
        // now parse the type and span
        var first_space_idx = ps[1].indexOf(' ');

        // the type is the first char to first space
        var type = ps[1].substring(0, first_space_idx);

        // the rest are spans
        var spans_txt = ps[1].substring(first_space_idx + 1, );

        // for brat v1.3 and later, it can be a multi-part text
        var spans_ps = spans_txt.split(';');

        var locs = [];
        for (let i = 0; i < spans_ps.length; i++) {
            const spans_p = spans_ps[i];
            var sps = spans_p.split(' ');
            
            var a = parseInt(sps[0]);
            var b = parseInt(sps[1]);

            locs.push([a, b]);
        }

        return [
            id,
            type,
            locs,
            token, // which is not required, but I just leave it here
        ]
    },

    // for managing colors
    colors: [
        "#a6cee3",
        "#1f78b4",
        "#b2df8a",
        "#33a02c",
        "#fb9a99",
        "#e31a1c",
        "#fdbf6f",
        "#ff7f00",
        "#cab2d6",
        "#6a3d9a",
        "#ffff99",
        "#b15928",
        "#8dd3c7",
        "#ffffb3",
        "#bebada",
        "#fb8072",
        "#80b1d3",
        "#fdb462",
        "#b3de69",
        "#fccde5",
        "#d9d9d9",
        "#bc80bd",
        "#ccebc5",
        "#ffed6f",
    ],
    // for holding temp color info
    color_mapping: {},

    reset_color_mapping: function() {
        this.color_mapping = {};
    },

    get_color: function(name) {
        if (this.color_mapping.hasOwnProperty(name)) {
            // good, we already have this color
        } else {
            // need to get a new color
            var n_assigned = Object.keys(this.color_mapping).length;
            // need to check whether is available color
            if (n_assigned < this.colors.length) {
                // yes! there is available color
                // assign an pre-defined color
                this.color_mapping[name] = this.colors[n_assigned];
            } else {
                // no ... just generate a random color
                // but we prefer a lighter, but not too bright
                var clr = '#' + Math.floor(Math.random()*8388608 + 4388607).toString(16);

                this.color_mapping[name] = clr;
            }
        }
        return this.color_mapping[name];
    },

    /**
     * Convert an annotation data file to a brat format string
     * 
     * @param {object} ann an annotation object from MedTator
     * @param {object} dtd the dtd schema
     */
    ann2brat: function(ann, dtd) {
        // the global count for 
        var cnt = {
            // the text annotation
            T: 0,
            // the relation annotation
            R: 0,
            // the attribute
            A: 0
        };
        // we need to record the mapping from tag.id to brat ID
        var id_mapping = {}

        // hold all records
        // each recrod contains one row of the format required by brat
        var rs = [];
        for (let i = 0; i < ann.tags.length; i++) {
            // for each tag, there may be more than one record
            // the first record is the tag itself
            const tag = ann.tags[i];

            // ok, let's output this tag
            // first of all, create a new ID as the first column
            var new_ID = null;
            if (dtd.tag_dict[tag.tag].type == 'etag') {
                cnt.T++;
                new_ID = 'T'+cnt.T;

            } else if (dtd.tag_dict[tag.tag].type == 'rtag') {
                cnt.R++;
                new_ID = 'R'+cnt.R;
            }
            // update the mapping
            id_mapping[tag.id] = new_ID;

            // now, put the text for the second column if etag

            // now, put the attributes for more rows
        }

        return rs;
    },

    /**
     * Convert the MedTagger output to brat format
     * 
     * @param {string} text the text content
     * @param {list} ann_rs a list of k-v pairs of MedTagger format
     * @returns {object} {col_data: col_data, doc_data: doc_data}
     */
    medtagger2brat: function(text, ann_rs, flag_attrs) {
        if (typeof(flag_attrs)=='undefined') {
            flag_attrs = {
                certainty: true,
                status: true
            }
        }
        var col_data = {
            // all the entities
            entity_types: [],

            // all attributes for entities
            entity_attribute_types: []
        };

        if (flag_attrs.certainty) {
            col_data.entity_attribute_types.push({
                type: 'Certainty',
                values: {
                    'Positive': {
                        glyph: '➕',
                        glyphColor: 'red',
                    },
                    'Negated': {
                        glyph: '➖',
                        glyphColor: 'green',
                    },
                    'Hypothetical': {
                        glyph: '❓',
                        glyphColor: 'orange',
                    },
                    'Possible': {
                        glyph: '%',
                        glyphColor: 'yellow'
                    }
                }
            });
        }

        if (flag_attrs.status) {
            col_data.entity_attribute_types.push({
                type: 'Status',
                values: {
                    'Present': {
                        glyph: 'P',
                    },
                    'HistoryOf': {
                        glyph: 'H'
                    }
                }
            });
        }

        var doc_data = {
            text: text,

            // all entities
            entities: [],

            // all attributes
            attributes: []
        };

        // for creating new entity
        // we need to track all the 
        var norm_dict = {};

        // prepare the document data
        // MedTagger only contains the entities
        for (let i = 0; i < ann_rs.length; i++) {
            const r = ann_rs[i];

            // update the collection
            if (!norm_dict.hasOwnProperty(r.norm)) {                
                // get a color for this entity
                var bgColor = this.get_color(r.norm);

                // create a new item for collection
                var ent_def = {
                    type: r.norm,
                    labels: [ r.norm ],
                    bgColor: bgColor,
                    borderColor: 'darken'
                }

                // save to collection
                col_data.entity_types.push(ent_def);

                // save to dict
                norm_dict[r.norm] = ent_def;
            }
            
            let entity_id = 'E' + i;

            // update the document
            doc_data.entities.push([
                // 1. id just use the sequence number
                entity_id,
                // 2. use norm as the tag name 
                r.norm,
                // 3. locs are the MedTagger offset
                [ [
                    parseInt(r.start),
                    parseInt(r.end),
                ] ]
            ]);

            // update attributes
            // update the certainty
            if (flag_attrs.certainty) {
                doc_data.attributes.push([
                    'A'+doc_data.attributes.length, 
                    'Certainty', 
                    entity_id, 
                    r.certainty,
                ]);
            }

            // update the status
            if (flag_attrs.status) {
                doc_data.attributes.push([
                    'A'+doc_data.attributes.length, 
                    'Status', 
                    entity_id, 
                    r.status,
                ]);
            }
        }

        return {
            col_data: col_data,
            doc_data: doc_data
        }
    },

    /**
     * Convert an annotation schema file to a brat collection data
     * 
     * The sample col_data is like the following:
     * 
     * var col_data = {
          entity_types: [ {
            type   : 'Person',
            // The labels are used when displaying the annotion, in this case
            // we also provide a short-hand "Per" for cases where
            // abbreviations are preferable 
            labels : ['Person', 'Per'],

            // Blue is a nice colour for a person?
            bgColor: '#7fa2ff',

            // Use a slightly darker version of the bgColor for the border
            borderColor: 'darken'
          }],
          relation_types: [{

          }]
     * };
     * 
     * The sample is from: https://brat.nlplab.org/embed.html
     * @param {object} dtd an annotation object from MedTator
     * @param {string} relation_creation_mode 'all_combos', 'first_others' (default)
     */
    make_collection_data_by_dtd: function(dtd, relation_creation_mode) {
        if (typeof(relation_creation_mode) == 'undefined') {
            relation_creation_mode = 'first_others';
        }
        var col_data = {
            // all the entities
            entity_types: [],

            // all the relations
            relation_types: []
        };

        // first, convert all entities
        for (let i = 0; i < dtd.etags.length; i++) {
            const tag = dtd.etags[i];
            col_data.entity_types.push({
                type: tag.name,
                labels : [tag.name],
                bgColor: tag.style.color,
                borderColor: 'darken'
            });
        }

        // second, convert all relations
        // due the complixity of the schema, we will convert all combos
        for (let i = 0; i < dtd.rtags.length; i++) {
            const tag = dtd.rtags[i];

            // depends on which mode
            if (relation_creation_mode == 'all_combos') {

            } else if (relation_creation_mode == 'first_others') {

                // find the first attr
                for (let j = 0; j < tag.attrs.length; j++) {
                    const attr_j = tag.attrs[j];
                    if (attr_j.vtype == 'idref') {
                        // just use the attribute name as the role
                        
                        // ok, find others from next
                        for (let k = j+1; k < tag.attrs.length; k++) {
                            const attr_k = tag.attrs[k];
                            if (attr_k.vtype == 'idref') {
                                let rel_type = {
                                    // create a subtype for this relation
                                    type: tag.name + '.' + attr_j.name + '-' + attr_j.name,
                                    // the label should be the relation name
                                    labels : [tag.name],
                                    color: tag.style.color,
                                    // the arch is from j to k
                                    args: [
                                        { role: attr_j.name },
                                        { role: attr_k.name }
                                    ]
                                };
                                // save this relation
                                col_data.relation_types.push(rel_type);
                            }
                        }
                        // ok, all first - others are found
                        break;
                    }
                    // if this attr is not idref, just check next one
                    continue;
                }
            }
        }

        return col_data;
    },


    /**
     * Convert an annotation object to a brat document data for brat vis
     * 
     * For most of time, you can use this directly
     * 
     * @param {object} ann the annotation data object containing text and tags
     * @param {object} dtd the annotation schema object
     */
    make_document_data_by_ann: function(ann, dtd) {
        return this.make_document_data
    },

    /**
     * Converting a text and related annotated tags to brat document data for vis
     * 
     * @param {string} text the text string containing the annotated tags
     * @param {list} tags a list of annotated tags, including etags and rtags
     * @param {object} dtd the annotation schema object
     * @returns brat document data object for vis
     */
     make_document_data: function(text, tags, dtd) {
        var doc_data = {
            // text it self
            text: text,
            
            // all entities
            entities: [],

            // all relations
            relations: []

            // no triggers and events
        };

        // create a dict for accessing etags later
        let etag_dict = {};

        // first check all entities
        for (let i = 0; i < tags.length; i++) {
            const tag = tags[i];

            if (dtd.tag_dict[tag.tag].type != 'etag') {
                // skip relation in the first round
                continue;
            }

            // ok, save this etag
            etag_dict[tag.id] = tag;
            
            // get locs
            let locs = ann_parser.spans2locs(tag.spans);

            // put this tag into entities
            doc_data.entities.push([
                // 1. id
                tag.id,
                // 2. tag name
                tag.tag,
                // 3. locs
                locs
            ]);
        }

        // second, check all relations
        for (let i = 0; i < tags.length; i++) {
            const tag = tags[i];

            // get the tag defination
            let tag_def = dtd.tag_dict[tag.tag];
            if (tag_def.type != 'rtag') {
                // skip entity in the second round
                continue;
            }

            let arcs = [];
            // find the arcs in this relationship
            for (const attr_name in tag) {
                if (!tag_def.attr_dict.hasOwnProperty(attr_name)) {
                    // which means this attr_name is just id or tag or other
                    continue;
                }
                // find the attr def
                let attr_def = tag_def.attr_dict[attr_name];
                // let's see what's this attr?
                if (attr_def.vtype != 'idref') {
                    // this is just a text or other type
                    continue;
                }
                // then let's put this attr to arcs
                arcs.push([
                    // the attr name is used as the role in brat
                    attr_name,
                    // the attr value is the entity id
                    tag[attr_name]
                ]);
            }

            // create a new relation obj
            let rel = [
                // 1. id
                tag.id,
                // 2. type, which is the tag name
                tag.tag,
                // 3. two entities
                arcs
            ];

            // ok, save this relation
            doc_data.relations.push(rel);
        }

        return doc_data;
    }
};

// The helper for brat visualization
var fig_bratvis = {
    plot_id: 'fig_bratvis',

    // as we revised the brat code,
    // we need to use local version.
    brat_location: './static/lib/brat',

    // the brat_util obj
    util: null,

    init: function () {
        if (this.util != null) {
            return;
        }

        // init if util is null
        head.js(
            // External libraries
            this.brat_location + '/lib/jquery.svg.min.js',
            this.brat_location + '/lib/jquery.svgdom.min.js',

            // brat helper modules
            this.brat_location + '/src/util.js',
            this.brat_location + '/src/configuration.js',
            this.brat_location + '/src/annotation_log.js',
            this.brat_location + '/lib/webfont.js',

            // brat modules
            this.brat_location + '/src/dispatcher.js',
            this.brat_location + '/src/url_monitor.js',
            this.brat_location + '/src/visualizer.js'
        );

        head.ready(function () {
            // bind to local variable
            fig_bratvis.util = BratUtil;
        });
    },

    /**
     * Visualize the annotation data in a SVG image
     * 
     * @param {object} col_data collection data for brat
     * @param {object} doc_date document data for brat
     * @param {string} plot_id optional DOM ID for the plot
     * @returns None
     */
    visualize: function (col_data, doc_date, plot_id) {
        if (this.util == null) {
            return;
        }

        if (typeof(plot_id) == 'undefined') {
            plot_id = this.plot_id
        }

        // update data
        this.col_data = col_data;
        this.doc_date = doc_date;

        // clear the old one
        $('#' + plot_id).html('');

        // create a new div id
        var new_div_id = plot_id + '_' + (Math.random() * 100000).toFixed(0);
        $('#' + plot_id).html(
            `<div id="${new_div_id}" class="brat-vis" style="width:100%;"></div>`
        );

        // use brat to render
        this.util.embed(
            new_div_id,
            $.extend({}, col_data),
            $.extend({}, doc_date),
            [
                this.brat_location + '/css/fonts/Astloch-Bold.ttf',
                this.brat_location + '/css/fonts/PT_Sans-Caption-Web-Regular.ttf',
                this.brat_location + '/css/fonts/Liberation_Sans-Regular.ttf'
            ]
        )
    },

    /**
     * Clear the brat visualization
     * 
     * @param {string} plot_id optional DOM ID for the plot
     */
    clear: function(plot_id) {

        if (typeof(plot_id) == 'undefined') {
            plot_id = this.plot_id
        }

        // clear the old one
        $('#' + plot_id).html('');
    }
};

// The Jarvis for init
var jarvis = {
    // for annotating test
    sample_text: {},

    // for log
    changelog_latest: '',

    init: function() {
        // too bad ...
        if (isIE) { 
            this.ssmsg(_NOT_SUPPORT_MSG);
            return 0; 
        }

        app_hotpot.init();

        if (isCHROME) { 

            if (isFSA_API_OK) {
                jarvis.ssmsg('Initializated')
                setTimeout('jarvis.ssclose();', 500);

            } else {
                // this can be many reasons
                if (isHTTPS) {
                    // 2022-03-24: Thanks to Adam Cross@UIC who reported this bug!
                    jarvis.ssmsg(_DISABLED_API_MSG);

                } else if (isLOCALFILE) {
                    // 2022-03-24: Thanks to Adam Cross@UIC who reported this bug!
                    jarvis.ssmsg(_DISABLED_API_MSG);

                } else if (!isLOCALHOST) {
                    // not HTTPs and not localhost
                    // so can not use FSA API
                    jarvis.ssmsg(_SEC_LMT_MSG);

                } else {
                    // ?
                    jarvis.ssmsg(_DISABLED_API_MSG);
                }
            }
        } else {

            if (isFSA_API_OK) {
                jarvis.ssmsg('Initializated')
                setTimeout('jarvis.ssclose();', 500);
                
            } else {
                jarvis.ssmsg(_LMT_SUPPORT_MSG);
            }

        }

        $(window).resize(function() {
            app_hotpot.resize();
        });

        // get some settings here

        // the default sample dataset for demo
        var sample_ds = this.get_url_paramter('ds');
        if (sample_ds == '') {
            sample_ds = 'MINIMAL_TASK';
        }

        // show sample dataset at beginning or not
        var show_sample = this.get_url_paramter('ss');
        if (show_sample == 'yes') {
            app_hotpot.vpp.load_sample_ds(sample_ds);
        }

        // show the tour?
        var show_tour = this.get_url_paramter('st');
        if (show_tour == 'yes') {
            setTimeout('app_hotpot.start_tour_annotation();', 550);
        }
    },

    get_url_paramter: function(name) {
        name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
        var regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
        var results = regex.exec(location.search);
        return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
    },

    ssmsg: function(msg) {
        $('#ss-msg').html(msg);
    },

    ssclose: function() {
        $('#start-screen').hide();
    },

    save_json: function(obj, fn) {
        var json_text = JSON.stringify(obj, null, 4);
        var blob = new Blob([json_text], {type: "text/json;charset=utf-8"});
        saveAs(blob, fn);
    },

    save_vpp_as: function(name) {
        if (app_hotpot.vpp.$data.dtd == null) {
            console.log('* no dtd yet');
            return;
        }
        var dtd_name = app_hotpot.vpp.$data.dtd.name;

        if (typeof(name) == 'undefined') {
            name = dtd_name;
        }

        // change to upper case for better looking
        name = name.toLocaleUpperCase();

        // save it!
        this.save_json(
            app_hotpot.vpp.$data,
            'vpp_data_'+name+'.json'
        );
    }
}

// The Jarvis extension for samples
/**
 * This is an extension for jarvis
 */

/////////////////////////////////////////////////////////////////
// Sample Texts for annotation test
/////////////////////////////////////////////////////////////////
Object.assign(jarvis.sample_text, {
    'covid_vax': `Positive COVID-19 test with symptoms; 

The patient had MS & ache (UoL < 2.4 & T'x > 5.5, with "AoE" found) was immune compromised; 

This is a spontaneous report from a contactable consumer (patient). This female consumer of unspecified age received the first single dose of BNT162B2 (PFIZER-BIONTECH COVID-19 VACCINE) on 04Jan2021, for COVID-19 immunization. She had MS and was immune compromised. Concomitant medications were not reported. On 07Jan2021 the patient woke up with headache, runny nose, groggy and muscle aches. She went to pharmacy and got a rapid COVID test that resulted positive. She was asking if the 1st dose could have caused her to be positive on the test. Events outcome was unknown.  

Information on the batch/lot number has been requested.

Sender's Comments: 

Based on the information available, a possible contributory role of the suspect products cannot be excluded for the reported event of positive for corona virus infection for the lack of efficacy of the vaccine. However, based on the mechanism of action of the vaccine, it is unlikely the patient would have fully developed immunity for the vaccine to be effective, due to the number of days passed since the vaccine is given. Case will be reevaluated based on follow-up information.

As she was in D.C. on Wed. to attend Mr. LASTNAME's wedding at 9 A.M. to 14 P.M. with Ms. LASTNAME from Wash., Dr. LASTNAME updated the No. C8's comments and re-scheduled a virtual visit on Mon. of next week (Jul. 19th). 
    `
});

// update the log
jarvis.changelog_latest = `
1.3.15 (2023-02-26)

- Added workspace JSON drag and drop on file list
- Added workspace saving function
- Added workspace loading function
- Added schema drag and drop on file list
- Added shortcut ALT +	&amp;uarr; / &amp;darr; to move to prev / next file
- Added Toolkit/MedTaggerVis for checking .ann files (experimental)
- Added local setting cache for auto save/load (experimental)
- Fixed error analysis Sankey link bug
- Fixed error analysis SVG height bug
- Fixed error analysis popup box bug
- Updated design for .ann/.txt conversion
- Updated FAQ in MedTator Wiki 
- Updated scripts for downstream tasks
- Updated sample datasets for new settings


`;

// extend the App with data if needed



// init the whole document
$(document).ready(function () {
    jarvis.init();
})
</script>

    
</body>
</html>